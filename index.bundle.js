var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

// Generated by Haxe 3.4.4
var hsluv = hsluv || {};
hsluv.Geometry = function() { };
hsluv.Geometry.intersectLineLine = function(a,b) {
	var x = (a.intercept - b.intercept) / (b.slope - a.slope);
	var y = a.slope * x + a.intercept;
	return { x : x, y : y};
};
hsluv.Geometry.distanceFromOrigin = function(point) {
	return Math.sqrt(Math.pow(point.x,2) + Math.pow(point.y,2));
};
hsluv.Geometry.distanceLineFromOrigin = function(line) {
	return Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope,2) + 1);
};
hsluv.Geometry.perpendicularThroughPoint = function(line,point) {
	var slope = -1 / line.slope;
	var intercept = point.y - slope * point.x;
	return { slope : slope, intercept : intercept};
};
hsluv.Geometry.angleFromOrigin = function(point) {
	return Math.atan2(point.y,point.x);
};
hsluv.Geometry.normalizeAngle = function(angle) {
	var m = 2 * Math.PI;
	return (angle % m + m) % m;
};
hsluv.Geometry.lengthOfRayUntilIntersect = function(theta,line) {
	return line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));
};
hsluv.Hsluv = function() { };
hsluv.Hsluv.getBounds = function(L) {
	var result = [];
	var sub1 = Math.pow(L + 16,3) / 1560896;
	var sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;
	var _g = 0;
	while(_g < 3) {
		var c = _g++;
		var m1 = hsluv.Hsluv.m[c][0];
		var m2 = hsluv.Hsluv.m[c][1];
		var m3 = hsluv.Hsluv.m[c][2];
		var _g1 = 0;
		while(_g1 < 2) {
			var t = _g1++;
			var top1 = (284517 * m1 - 94839 * m3) * sub2;
			var top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;
			var bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;
			result.push({ slope : top1 / bottom, intercept : top2 / bottom});
		}
	}
	return result;
};
hsluv.Hsluv.maxSafeChromaForL = function(L) {
	var bounds = hsluv.Hsluv.getBounds(L);
	var min = Infinity;
	var _g = 0;
	while(_g < bounds.length) {
		var bound = bounds[_g];
		++_g;
		var length = hsluv.Geometry.distanceLineFromOrigin(bound);
		min = Math.min(min,length);
	}
	return min;
};
hsluv.Hsluv.maxChromaForLH = function(L,H) {
	var hrad = H / 360 * Math.PI * 2;
	var bounds = hsluv.Hsluv.getBounds(L);
	var min = Infinity;
	var _g = 0;
	while(_g < bounds.length) {
		var bound = bounds[_g];
		++_g;
		var length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad,bound);
		if(length >= 0) {
			min = Math.min(min,length);
		}
	}
	return min;
};
hsluv.Hsluv.dotProduct = function(a,b) {
	var sum = 0;
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		sum += a[i] * b[i];
	}
	return sum;
};
hsluv.Hsluv.fromLinear = function(c) {
	if(c <= 0.0031308) {
		return 12.92 * c;
	} else {
		return 1.055 * Math.pow(c,0.416666666666666685) - 0.055;
	}
};
hsluv.Hsluv.toLinear = function(c) {
	if(c > 0.04045) {
		return Math.pow((c + 0.055) / 1.055,2.4);
	} else {
		return c / 12.92;
	}
};
hsluv.Hsluv.xyzToRgb = function(tuple) {
	return [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2],tuple))];
};
hsluv.Hsluv.rgbToXyz = function(tuple) {
	var rgbl = [hsluv.Hsluv.toLinear(tuple[0]),hsluv.Hsluv.toLinear(tuple[1]),hsluv.Hsluv.toLinear(tuple[2])];
	return [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2],rgbl)];
};
hsluv.Hsluv.yToL = function(Y) {
	if(Y <= hsluv.Hsluv.epsilon) {
		return Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;
	} else {
		return 116 * Math.pow(Y / hsluv.Hsluv.refY,0.333333333333333315) - 16;
	}
};
hsluv.Hsluv.lToY = function(L) {
	if(L <= 8) {
		return hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;
	} else {
		return hsluv.Hsluv.refY * Math.pow((L + 16) / 116,3);
	}
};
hsluv.Hsluv.xyzToLuv = function(tuple) {
	var X = tuple[0];
	var Y = tuple[1];
	var Z = tuple[2];
	var divider = X + 15 * Y + 3 * Z;
	var varU = 4 * X;
	var varV = 9 * Y;
	if(divider != 0) {
		varU /= divider;
		varV /= divider;
	} else {
		varU = NaN;
		varV = NaN;
	}
	var L = hsluv.Hsluv.yToL(Y);
	if(L == 0) {
		return [0,0,0];
	}
	var U = 13 * L * (varU - hsluv.Hsluv.refU);
	var V = 13 * L * (varV - hsluv.Hsluv.refV);
	return [L,U,V];
};
hsluv.Hsluv.luvToXyz = function(tuple) {
	var L = tuple[0];
	var U = tuple[1];
	var V = tuple[2];
	if(L == 0) {
		return [0,0,0];
	}
	var varU = U / (13 * L) + hsluv.Hsluv.refU;
	var varV = V / (13 * L) + hsluv.Hsluv.refV;
	var Y = hsluv.Hsluv.lToY(L);
	var X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);
	var Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);
	return [X,Y,Z];
};
hsluv.Hsluv.luvToLch = function(tuple) {
	var L = tuple[0];
	var U = tuple[1];
	var V = tuple[2];
	var C = Math.sqrt(U * U + V * V);
	var H;
	if(C < 0.00000001) {
		H = 0;
	} else {
		var Hrad = Math.atan2(V,U);
		H = Hrad * 180.0 / Math.PI;
		if(H < 0) {
			H = 360 + H;
		}
	}
	return [L,C,H];
};
hsluv.Hsluv.lchToLuv = function(tuple) {
	var L = tuple[0];
	var C = tuple[1];
	var H = tuple[2];
	var Hrad = H / 360.0 * 2 * Math.PI;
	var U = Math.cos(Hrad) * C;
	var V = Math.sin(Hrad) * C;
	return [L,U,V];
};
hsluv.Hsluv.hsluvToLch = function(tuple) {
	var H = tuple[0];
	var S = tuple[1];
	var L = tuple[2];
	if(L > 99.9999999) {
		return [100,0,H];
	}
	if(L < 0.00000001) {
		return [0,0,H];
	}
	var max = hsluv.Hsluv.maxChromaForLH(L,H);
	var C = max / 100 * S;
	return [L,C,H];
};
hsluv.Hsluv.lchToHsluv = function(tuple) {
	var L = tuple[0];
	var C = tuple[1];
	var H = tuple[2];
	if(L > 99.9999999) {
		return [H,0,100];
	}
	if(L < 0.00000001) {
		return [H,0,0];
	}
	var max = hsluv.Hsluv.maxChromaForLH(L,H);
	var S = C / max * 100;
	return [H,S,L];
};
hsluv.Hsluv.hpluvToLch = function(tuple) {
	var H = tuple[0];
	var S = tuple[1];
	var L = tuple[2];
	if(L > 99.9999999) {
		return [100,0,H];
	}
	if(L < 0.00000001) {
		return [0,0,H];
	}
	var max = hsluv.Hsluv.maxSafeChromaForL(L);
	var C = max / 100 * S;
	return [L,C,H];
};
hsluv.Hsluv.lchToHpluv = function(tuple) {
	var L = tuple[0];
	var C = tuple[1];
	var H = tuple[2];
	if(L > 99.9999999) {
		return [H,0,100];
	}
	if(L < 0.00000001) {
		return [H,0,0];
	}
	var max = hsluv.Hsluv.maxSafeChromaForL(L);
	var S = C / max * 100;
	return [H,S,L];
};
hsluv.Hsluv.rgbToHex = function(tuple) {
	var h = "#";
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var chan = tuple[i];
		var c = Math.round(chan * 255);
		var digit2 = c % 16;
		var digit1 = (c - digit2) / 16 | 0;
		h += hsluv.Hsluv.hexChars.charAt(digit1) + hsluv.Hsluv.hexChars.charAt(digit2);
	}
	return h;
};
hsluv.Hsluv.hexToRgb = function(hex) {
	hex = hex.toLowerCase();
	var ret = [];
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var digit1 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 1));
		var digit2 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 2));
		var n = digit1 * 16 + digit2;
		ret.push(n / 255.0);
	}
	return ret;
};
hsluv.Hsluv.lchToRgb = function(tuple) {
	return hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));
};
hsluv.Hsluv.rgbToLch = function(tuple) {
	return hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));
};
hsluv.Hsluv.hsluvToRgb = function(tuple) {
	return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));
};
hsluv.Hsluv.rgbToHsluv = function(tuple) {
	return hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));
};
hsluv.Hsluv.hpluvToRgb = function(tuple) {
	return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));
};
hsluv.Hsluv.rgbToHpluv = function(tuple) {
	return hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));
};
hsluv.Hsluv.hsluvToHex = function(tuple) {
	return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));
};
hsluv.Hsluv.hpluvToHex = function(tuple) {
	return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));
};
hsluv.Hsluv.hexToHsluv = function(s) {
	return hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));
};
hsluv.Hsluv.hexToHpluv = function(s) {
	return hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));
};
hsluv.Hsluv.m = [[3.240969941904521,-1.537383177570093,-0.498610760293],[-0.96924363628087,1.87596750150772,0.041555057407175],[0.055630079696993,-0.20397695888897,1.056971514242878]];
hsluv.Hsluv.minv = [[0.41239079926595,0.35758433938387,0.18048078840183],[0.21263900587151,0.71516867876775,0.072192315360733],[0.019330818715591,0.11919477979462,0.95053215224966]];
hsluv.Hsluv.refY = 1.0;
hsluv.Hsluv.refU = 0.19783000664283;
hsluv.Hsluv.refV = 0.46831999493879;
hsluv.Hsluv.kappa = 903.2962962;
hsluv.Hsluv.epsilon = 0.0088564516;
hsluv.Hsluv.hexChars = "0123456789abcdef";
var root = {
    "hsluvToRgb": hsluv.Hsluv.hsluvToRgb,
    "rgbToHsluv": hsluv.Hsluv.rgbToHsluv,
    "hpluvToRgb": hsluv.Hsluv.hpluvToRgb,
    "rgbToHpluv": hsluv.Hsluv.rgbToHpluv,
    "hsluvToHex": hsluv.Hsluv.hsluvToHex,
    "hexToHsluv": hsluv.Hsluv.hexToHsluv,
    "hpluvToHex": hsluv.Hsluv.hpluvToHex,
    "hexToHpluv": hsluv.Hsluv.hexToHpluv,
    "lchToHpluv": hsluv.Hsluv.lchToHpluv,
    "hpluvToLch": hsluv.Hsluv.hpluvToLch,
    "lchToHsluv": hsluv.Hsluv.lchToHsluv,
    "hsluvToLch": hsluv.Hsluv.hsluvToLch,
    "lchToLuv": hsluv.Hsluv.lchToLuv,
    "luvToLch": hsluv.Hsluv.luvToLch,
    "xyzToLuv": hsluv.Hsluv.xyzToLuv,
    "luvToXyz": hsluv.Hsluv.luvToXyz,
    "xyzToRgb": hsluv.Hsluv.xyzToRgb,
    "rgbToXyz": hsluv.Hsluv.rgbToXyz,
    "lchToRgb": hsluv.Hsluv.lchToRgb,
    "rgbToLch": hsluv.Hsluv.rgbToLch
};

var hsluv_1 = root;

// @ts-check

/** @template T
 * @typedef {(
 * | {value: T, err?: never}
 * | {err: Error, value?: never}
 * )} Result */

/**
 * @template T
 * @param {Result<T>} res
 */
function toValue({ err, value }) {
  if (err) {
    throw err;
  } else {
    return value;
  }
}

/**
 * @template T
 * @param {T} value
 * @returns {Result<T>}
 */
function just(value) {
  return { value };
}

/**
 * @param {Error} err
 * @returns {Result<never>}
 */
function error(err) {
  return { err };
}

/**
 * @template T
 * @param {() => Result<T>} body
 * @returns {Result<T>}
 */
function catchErr(body) {
  try {
    return body();
  } catch (err) {
    return error(err instanceof Error ? err : new Error(`${err}`));
  }
}

/**
 * @template T
 * @param {(...args: any[]) => T} func
 * @returns {(...args: any[]) => Result<T>}
 */
function lift(func) {
  /** @this {any} */
  return function rezultLifted(...args) {
    return catchErr(() => just(func.apply(this, args)));
  };
}

/**
 * @template T, S
 * @param {Result<T>} res
 * @param {(t: T) => Result<S>} next
 * @returns {Result<S>}
 */
function bind(res, next) {
  return res.err ? res : next(res.value);
}

// @ts-check

/** A color tuple in some color space (e.g. rgb or hsl)
 *
 * @typedef {[a: number, b: number, c: number]} ColorTuple
 */

/** A function which can generate N color tuples
 *
 * @typedef {(n: number) => IterableIterator<ColorTuple>} ColorGen
 */

/** A factory for creating N-color generators for a given intensity level
 *
 * The view module currently uses these intensity levels for fixed roles:
 * 0: empty cells
 * 1: ant traced cells
 * 2: ant body
 * 3: ant head
 *
 * @typedef {object} ColorGenMaker
 * @prop {(intensity: number) => ColorGen} makeColorGen
 * @prop {() => string} toString
 */

/** A family of N-color-generator factories, parameterized by 2 arguments
 *
 * Family implementations must provide argument defaults
 *
 * Family aguments are presumabley 2 fixed color space but not necessarily so...
 *
 * @typedef {(a?: number, b?: number) => ColorGenMaker} ColorGenFam2
 */

/** @type {Map<string, ColorGenFam2>} */
const gens = new Map();

/**
 * @param {string} str
 * @returns {rezult.Result<ColorGenMaker>}
 */
function parse$2(str) {
  const match = /^(\w+)(?:\((.*)\))?$/.exec(str);
  if (!match) {
    return error(new Error('invalid color spec'));
  }

  const name = match[1] || '';
  const gen = gens.get(name);
  if (!gen) {
    const choices = Object.keys(gens).sort().join(', ');
    return error(new Error(
      `no such color scheme ${JSON.stringify(name)}, valid choices: ${choices}`
    ));
  }

  const args = match[2] ? match[2].split(/, */) : [];
  const a = args[0] ? parseInt(args[0], 10) : undefined;
  const b = args[1] ? parseInt(args[1], 10) : undefined;

  return just(gen(a, b));
}

gens.set('light', (hue = 0, sat = 100) => {
  if (hue === 0) {
    hue = 360;
  }
  return {
    toString() {
      return `light(${hue}, ${sat})`;
    },
    makeColorGen(intensity) {
      const h = hue * (1 + (intensity - 1) / 3) % 360;
      return function*(ncolors) {
        const step = 100 / (ncolors + 1);
        for (let i = 0, l = step; i < ncolors; l += step, i++) {
          yield hsluv_1.hsluvToRgb([h, sat, l]);
        }
      };
    },
  };
});

gens.set('hue', (sat = 70, light = 40) => {
  const satDelta = sat > 70 ? -10 : 10;
  const lightDelta = light > 70 ? -10 : 10;
  return {
    toString() {
      return `hue(${sat}, ${light})`;
    },
    makeColorGen(intensity) {
      const mySat = sat + satDelta * intensity;
      const myLight = light + lightDelta * intensity;
      return function*(ncolors) {
        const step = 360 / ncolors;
        for (let i = 0, h = 0; i < ncolors; h += step, i++) {
          yield [h, mySat, myLight];
        }
      };
    },
  };
});

// TODO: implement a 'hsluv' family

// @ts-check

/**
 * @template {abstract new(...args: any[]) => any} T
 * @param {HTMLElement} el
 * @param {string} selector
 * @param {T} type
 * @returns {InstanceType<T>}
 */
function mustQuery(el, selector, type) {
  const res = el.querySelector(selector);
  if (!res) {
    throw new Error(`unable to find a ${selector}`);
  }
  if (!(res instanceof type)) {
    throw new Error(`invalid ${selector} element, must be a ${type.name} instance`);
  }
  return /** @type {InstanceType<T>} */ (res);
}

/**
 * @template {abstract new(...args: any[]) => any} T
 * @param {HTMLElement} el
 * @param {string} selector
 * @param {T} type
 * @returns {InstanceType<T>|null}
 */
function mayQuery(el, selector, type) {
  const res = el.querySelector(selector);
  if (!res) {
    return null;
  }
  if (!(res instanceof type)) {
    throw new Error(`invalid ${selector} element, must be a ${type.name} instance`);
  }
  return /** @type {InstanceType<T>} */ (res);
}

// @ts-check

/** @param {Window} window */
function makeHash(window) {
  const codecs = makeCodecSuite();

  codecs.addCodec('', {
    encodeKeys(keyvals) {
      const parts = [];
      for (const [key, val] of keyvals) {
        let part = encodeURIComponent(key);
        if (val !== undefined && val !== '') {
          part += '=' + encodeURIComponent(val);
        }
        parts.push(part);
      }
      return parts.join('&');
    },
    *decodeKeys(str) {
      for (const part of str.split('&')) {
        let [key, val] = part.split('=');
        key = decodeURIComponent(key || '');
        val = decodeURIComponent(val || '');
        if (key) {
          yield [key, val];
        }
      }
    },
  });

  codecs.addCodec('b64:', {
    encode: btoa,
    decode: atob,
    // TODO direct key codec is possible, no need to url-escape under base64
  });

  /** @type {Map<string, string>} */
  const cache = new Map();

  /** @type {Map<string, any>} */
  const values = new Map();

  /** @type {Map<string, any>} */
  const defaults = new Map();

  /** @type {Map<string, (s: string) => rezult.Result<any>>} */
  const parsers = new Map();

  /** @type {Map<string, (val: any) => (string|undefined)>} */
  const stringers = new Map();

  /** @type {Map<string, Array<(val: any) => void>>} */
  const listeners = new Map();

  let last = '';
  let loaded = false;

  window.addEventListener('hashchange', () => reload());

  function reload(hash = window.location.hash) {
    if (loaded && hash !== last) {
      load(hash);
    }
  }

  function load(hash = window.location.hash) {
    const resave = loadValues(hash);
    last = hash;
    if (resave) {
      save();
    }
  }

  function save() {
    let hash = codecs.encode(cache.entries());
    if (hash) {
      hash = '#' + hash;
    }
    if (hash !== last) {
      last = hash;
      window.location.hash = hash;
    }
  }

  /** @param {string} hash */
  function loadValues(hash) {
    let resave = false;
    /** @type Set<string> */
    const seen = new Set();
    /** @type {{key: string, value: any}[]} */
    const toNotify = [];

    for (const [key, str] of codecs.decode(hash.slice(1))) {
      seen.add(key);
      if (cache.get(key) !== str) {
        cache.set(key, str);
        toNotify.push({ key, value: loadBinding(key) });
      }
    }

    for (const [key, value] of defaults.entries()) {
      if (!seen.has(key)) {
        seen.add(key);
        if (values.get(key) !== value) {
          if (value === undefined) {
            values.delete(key);
            cache.delete(key);
          } else {
            values.set(key, value);
            const stringer = stringers.get(key) || valueToString;
            const str = stringer(value);
            if (str !== undefined) {
              cache.set(key, str);
            } else {
              cache.delete(key);
            }
          }
          toNotify.push({ key, value });
          resave = true;
        }
      }
    }

    for (const key of cache.keys()) {
      if (!seen.has(key)) {
        seen.add(key);
        cache.delete(key);
        values.delete(key);
        toNotify.push({ key, value: defaults.get(key) });
        resave = true;
      }
    }

    for (const { key, value } of toNotify) {
      notifyBinding(key, value);
    }

    loaded = true;
    return resave;
  }

  /** @param {string} key */
  function loadBinding(key) {
    const str = cache.get(key);
    if (str === undefined) {
      return defaults.get(key);
    }

    const parser = parsers.get(key) || parseValue;

    let { err, value } = parser(str);
    if (err) {
      // intentionally ignore parse error; best-effort load
      return;
    }

    if (values.get(key) !== value) {
      if (value === undefined) {
        values.delete(key);
      } else {
        values.set(key, value);
      }
    }

    if (value === undefined) {
      return defaults.get(key);
    }

    return value;
  }

  /** @param {string} key */
  function saveBinding(key, value = values.get(key)) {
    const stringer = stringers.get(key) || valueToString;
    const str = stringer(value);
    if (cache.get(key) !== str) {
      if (str === undefined) {
        cache.delete(key);
      } else {
        cache.set(key, str);
      }
      save();
    }
  }

  /**
   * @param {string} key
   * @param {any} value
   */
  function notifyBinding(key, value) {
    for (const fn of listeners.get(key) || []) {
      fn(value);
    }
  }

  /**
   * @param {string} key
   * @param {any} val
   */
  function parseBindingValue(key, val) {
    if ((val === null || val === undefined) && defaults.has(key)) {
      val = defaults.get(key);
    }
    let res = just(val);
    /** @type {string|undefined} */
    let str = '';
    if (typeof val === 'string') {
      const parser = parsers.get(key) || parseValue;
      res = parser(val), str = val;
    } else {
      const stringer = stringers.get(key) || valueToString;
      str = stringer(val);
    }
    return { res, str };
  }

  /**
   * @param {any} val
   * @returns {string|undefined}
   */
  function valueToString(val) {
    if (val === false) {
      return undefined;
    }
    if (val === true) {
      return '';
    }
    return '' + val;
  }

  /**
   * @param {string} str
   * @returns {rezult.Result<any>}
   */
  function parseValue(str) {
    if (str === '' || str === 'true') {
      return just(true);
    }
    if (str === 'false') {
      return just(false);
    }
    if (str === 'null') {
      return just(null);
    }
    return just(str);
  }

  return {
    get encoding() {
      return codecs.defaultEncoding;
    },
    set encoding(enc) {
      codecs.defaultEncoding = enc;
      save();
    },

    /** @template T
     * @param {string} key
     * @param {object} params
     * @param {T} params.defaultValue
     * @param {(val: T) => void} params.listener
     * @param {(str: string) => rezult.Result<T>} [params.parse]
     * @param {(val: T) => string|undefined} [params.stringer]
     */
    bind(key, {
      parse = parseValue,
      stringer = valueToString,
      listener,
      defaultValue,
    }) {
      if (typeof defaultValue === 'string') {
        defaultValue = toValue(parse(defaultValue));
      }
      parsers.set(key, parse);
      stringers.set(key, stringer);
      defaults.set(key, defaultValue);
      if (listener) {
        listeners.set(key, [listener]);
      } else {
        listeners.delete(key);
      }

      if (loaded) {
        const value = loadBinding(key);
        saveBinding(key, value);
        notifyBinding(key, value);
      }
    },

    load,

    /** @param {string} key */
    getStr(key) {
      const prior = cache.get(key);
      if (prior !== undefined) {
        return prior;
      }

      const defaultValue = defaults.get(key);
      if (defaultValue !== undefined && typeof defaultValue !== 'string') {
        const stringer = stringers.get(key) || valueToString;
        const defaultString = stringer(defaultValue);
        if (defaultString !== undefined) {
          return defaultString;
        }
      }

      return '';
    },

    /** @param {string} key */
    get(key) {
      return values.get(key);
    },

    /**
     * @param {string} key
     * @param {any} val
     */
    set(key, val) {
      const r = parseBindingValue(key, val);
      const { res: { err, value } } = r;
      if (!err && values.get(key) !== value) {
        values.set(key, value);
        saveBinding(key, value);
        notifyBinding(key, value);
      }
      return r;
    },

    [Symbol.iterator]() {
      return values.entries();
    },

    stringEntries() {
      return cache.entries();
    },

  };
}

function makeCodecSuite() {

  /** @type {string[]} */
  let defaultEncoding = [];

  /** @type {Map<string, (s: string) => string>} */
  const encoders = new Map();

  /** @type {Map<string, (s: string) => string>} */
  const decoders = new Map();

  /** @type {Map<string, (keyvals: Iterable<[key: string, val: string]>) => string>} */
  const keyEncoders = new Map();

  /** @type {Map<string, (s: string) => IterableIterator<[key: string, val: string]>>} */
  const keyDecoders = new Map();

  /**
   * @param {Iterable<[key: string, val: string]>} keyvals
   * @returns {string}
   */
  function encode(keyvals) {
    let encoded = '';

    let i = 0;

    // if the first encoder can directly handle keys, let it; otherwise,
    // fallback to a base key encoder, and proceed to the wrapping phase
    const firstKey = defaultEncoding[i];
    let firstEnc = firstKey && keyEncoders.get(firstKey);
    if (firstEnc) {
      encoded = firstKey + firstEnc(keyvals);
      i++;
    } else {
      firstEnc = keyEncoders.get('');
      if (!firstEnc) {
        throw new Error('no default keyEncoder available!');
      }
      encoded = firstEnc(keyvals);
    }

    // apply any number of wrapped string encodings
    for (; i < defaultEncoding.length; i++) {
      const key = defaultEncoding[i];
      const enc = key && encoders.get(key);
      if (enc) {
        encoded = key + enc(encoded);
      } else {
        break;
      }
    }

    return encoded;
  }

  /**
   * @param {string} str
   * @returns {IterableIterator<[key: string, val: string]>}
   */
  function decode(str) {
    const orig = str;
    round: for (let sanity = 100; sanity-- > 0;) {
      // prefer to decode directly into final keyvals when possible
      for (const [key, decoder] of keyDecoders) {
        if (str.startsWith(key)) {
          return decoder(str.slice(key.length));
        }
      }
      // intermediate string encoding
      for (const [key, decoder] of decoders) {
        if (str.startsWith(key)) {
          str = decoder(str.slice(key.length));
          continue round;
        }
      }
      // exhausted all possible decoders, unable to progress
      break;
    }
    if (str === orig) {
      throw new Error(`unable to decode: ${JSON.stringify(str)}`);
    } else {
      throw new Error(`unable to decode: ${JSON.stringify(str)}, original form: ${JSON.stringify(orig)}`);
    }
  }

  /**
   * @param {string} key
   * @param {object} codec
   * @param {(s: string) => string} [codec.encode]
   * @param {(s: string) => string} [codec.decode]
   * @param {(keyvals: Iterable<[key: string, val: string]>) => string} [codec.encodeKeys]
   * @param {(s: string) => IterableIterator<[key: string, val: string]>} [codec.decodeKeys]
   */
  function addCodec(key, { encode, decode, encodeKeys, decodeKeys }) {
    if (encode) {
      encoders.set(key, encode);
    }
    if (decode) {
      decoders.set(key, decode);
    }
    if (encodeKeys) {
      keyEncoders.set(key, encodeKeys);
    }
    if (decodeKeys) {
      keyDecoders.set(key, decodeKeys);
    }
  }

  return {
    get defaultEncoding() {
      switch (defaultEncoding.length) {
        case 0:
          return '';
        case 1:
          return defaultEncoding[0] || '';
        default:
          return defaultEncoding.join('');
      }
    },
    set defaultEncoding(enc) {
      const encs = [];
      let rem = enc;
      parse: while (rem.length) {
        for (const key of encoders.keys()) {
          if (rem.startsWith(key)) {
            encs.push(key);
            rem = rem.slice(key.length);
            continue parse;
          }
        }
        throw new Error(`invalid encoding ${JSON.stringify(rem)} in ${JSON.stringify(enc)}`);
      }
      defaultEncoding = encs;
    },

    addCodec,

    encode,
    decode,
  };
}

// @ts-check

/** @template T
 * @typedef {Generator<Output[], T, Input[]>} Interactor
 */

/** @template T
 * @typedef {(inputs: Input[]) => Generator<Output, T|undefined>} Looper
 */

/** @typedef {(
 * | {value: string}
 * | {command: string}
 * )} Input */

/** @typedef {(
 * | {title: string}
 * | {value: string}
 * | {help: string|Iterable<string>}
 * | {error: string}
 * | {command: string, label?: string}
 * )} Output */

/** @typedef {(...args: string[]) => Iterable<Output>} Command */

/**
 * @template T
 * @param {() => HTMLElement} makeEl
 * @param {Interactor<T>} tor
 */
async function runPrompt(makeEl, tor) {
  const $el = makeEl();
  try {
    return await prompt($el, tor);
  } finally {
    $el.parentNode?.removeChild($el);
  }
}

/** @template T
 * @param {HTMLElement} $body
 * @param {Interactor<T>} tor
 * @returns {Promise<T|undefined>}
 */
async function prompt($body, tor) {
  /** @typedef {(
   * | {value: string}
   * | {command: string}
   * | {canceled: true}
   * )} Response */

  const handleEvents = ['click', 'keydown', 'keyup'];

  /** @type {((res: Response) => void)} */
  let callback = () => { };

  function makeHeader() {
    let $header = mayQuery($body, 'h1', HTMLHeadingElement);
    if (!$header) {
      $header = $body.insertBefore(
        $body.ownerDocument.createElement('h1'),
        $body.firstElementChild);
    }
    return $header;
  }

  function makeText() {
    let $text = mayQuery($body, '#text', HTMLTextAreaElement);
    if (!$text) {
      $text = $body.appendChild(
        $body.ownerDocument.createElement('textarea'));
      $text.id = 'text';
    }
    return $text;
  }

  function makeHelp() {
    let $help = mayQuery($body, '#help', HTMLElement);
    if (!$help) {
      $help = $body.appendChild(
        $body.ownerDocument.createElement('div'));
      $help.id = 'help';
      $help.classList.add('help');
    }
    return $help;
  }

  function makeError() {
    let $error = mayQuery($body, '#error', HTMLElement);
    if (!$error) {
      $error = $body.appendChild(
        $body.ownerDocument.createElement('div'));
      $error.id = 'error';
      $error.classList.add('error');
    }
    return $error;
  }

  /**
   * @param {object} options
   * @param {string} options.id
   * @param {string} options.label
   * @param {string} [options.title]
   */
  function makeButton({ id, label, title }) {
    let $btn = mayQuery($body, `button[id="${id}"]`, HTMLButtonElement);
    if (!$btn) {
      $btn = $body.appendChild(
        $body.ownerDocument.createElement('button'));
      $btn.id = id;
    }
    $btn.innerText = label;
    $btn.title = title || '';
    return $btn;
  }

  function resetOutputElements() {
    const $header = mayQuery($body, 'h1', HTMLHeadingElement);
    if ($header) {
      $header.style.display = 'none';
      $header.innerText = '';
    }

    const $text = mayQuery($body, '#text', HTMLTextAreaElement);
    if ($text) {
      $text.value = '';
      $text.rows = 1;
    }

    const $help = mayQuery($body, '#help', HTMLElement);
    if ($help) {
      $help.style.display = 'none';
      $help.innerText = '';
    }

    const $error = mayQuery($body, '#error', HTMLElement);
    if ($error) {
      $error.style.display = 'none';
      $error.innerText = '';
    }
  }

  function resizeTextRows() {
    let $text = mayQuery($body, '#text', HTMLTextAreaElement);
    if ($text) {
      const lines = $text.value.split(/\n/);
      $text.rows = lines.length + 1;
    }
  }

  let lastEnter = 0;

  /** @param {Event} e */
  function handleEvent(e) {
    switch (e.type) {

      case 'click':
        {
          const { target } = e;
          if (target && target instanceof HTMLButtonElement) {
            const { command } = target.dataset;
            if (command) {
              e.preventDefault();
              callback({ command });
            }
          }
        }
        break;

      case 'keydown':
        if (e instanceof KeyboardEvent) {
          switch (e.key) {

            case 'Enter':
              const $text = mayQuery($body, '#text', HTMLTextAreaElement);
              if ($text && e.target === $text) {
                if (e.ctrlKey) {
                  e.preventDefault();
                }
              }
              break;

            case 'Escape':
              e.preventDefault();
              callback({ canceled: true });
              return;

          }
          resizeTextRows();
        }
        break;

      case 'keyup':
        if (e instanceof KeyboardEvent) {
          switch (e.key) {

            case 'Enter':
              const $text = mayQuery($body, '#text', HTMLTextAreaElement);
              if ($text && e.target === $text) {
                if (Date.now() - lastEnter < 1000 || e.ctrlKey) {
                  e.preventDefault();
                  callback({ value: $text ? $text.value.replace(/(?:\r?\n)+$/, '') : '' });
                  return;
                }
                lastEnter = Date.now();
              }
              break;

            default:
              lastEnter = 0;

          }
          resizeTextRows();
        }
        break;

    }
  }

  const _canceled = new Object();
  try {
    $body.style.display = '';
    for (const event of handleEvents)
      $body.addEventListener(event, handleEvent);

    /** @type {Input[]} */
    let inputs = [];
    for (; ;) {

      { // tick tor
        const { done, value } = tor.next(inputs);
        if (done) { return value }
        const outputs = value;

        resetOutputElements();

        /** @type {WeakSet<HTMLButtonElement>} */
        const activeButtons = new WeakSet();

        for (const output of outputs) {
          if ('title' in output) {
            const { title } = output;
            const $header = makeHeader();
            $header.innerText = title;
            $header.style.display = '';
          }

          else if ('value' in output) {
            const { value } = output;
            const $text = makeText();
            $text.value = value;
            resizeTextRows();
            $text.select();
            $text.focus();
          }

          else if ('error' in output) {
            const { error } = output;
            if (error) {
              const $error = makeError();
              $error.innerText = error;
              $error.style.display = '';
            }
          }

          else if ('help' in output) {
            const { help } = output;
            if (help) {
              const $help = makeHelp();
              $help.innerText += typeof help == 'string' ? terminate(help) : coalesce(help);
              $help.style.display = '';
            }
          }

          else if ('command' in output) {
            const { command, label = command } = output;
            const id = `${$body.id}$${command}`;
            const $btn = makeButton({ id, label });
            $btn.dataset['command'] = command;
            activeButtons.add($btn);
          }

          else assertNever$3(output, 'unimplemented');
        }

        for (const $btn of $body.querySelectorAll('button')) {
          if (!activeButtons.has($btn)) {
            $body.removeChild($btn);
          }
        }
      }

      { // wait for user
        inputs = [];
        const res = await /** @type {Promise<Response>} */ (
          new Promise(resolve => callback = resolve));
        callback = () => { };
        if ('canceled' in res) { throw _canceled }
        else inputs.push(res);
      }
    }
  } catch (e) {
    if (e !== _canceled) throw e;
    return undefined;
  } finally {
    for (const event of handleEvents)
      $body.removeEventListener(event, handleEvent);
    $body.style.display = 'none';
    while ($body.lastChild) $body.removeChild($body.lastChild);
  }
}

/** @param {Iterable<string>} strs */
function coalesce(strs, sep = '\n') {
  let out = '';
  for (const str of strs) {
    out += terminate(str, sep);
  }
  return out;
}

/** @param {string} str */
function terminate(str, end = '\n') {
  return str.endsWith(end) ? str : `${str}${end}`;
}

/** @template T
 * @param {Looper<T>[]} loopers
 * @returns {Interactor<T>}
 */
function loop(...loopers) {
  const body = firstLooper(...loopers);
  return function*() {
    let { values: outputs, value } = collectIt(body([]));
    while (value === undefined) {
      const inputs = yield outputs;
      ({ values: outputs, value } = collectIt(body(inputs)));
    }
    return value;
  }();
}

/** @template T
 * @param {Looper<T>[]} loopers
 * @returns {Looper<T>}
 */
function firstLooper(...loopers) {
  switch (loopers.length) {
    case 0:
      return function*() { return undefined };
    case 1:
      return loopers[0];
  }
  return function*(inputs) {
    for (const looper of loopers) {
      const gen = looper(inputs);
      const { done, value: first } = gen.next();

      // looper produces output, so the rest don't get a shot this round
      if (!done) {
        yield first;
        return yield* gen;
      }

      // looper returned a final result, we'll take it!
      if (first !== undefined) {
        return first;
      }
    }

    // we'll have to do this all again with a different batch of inputs
    return undefined;
  };
}

/** @template V, R
 * @param {Iterator<V, R>} it
 */
function collectIt(it) {
  /** @type {V[]} */
  const values = [];
  for (; ;) {
    const { done, value } = it.next();
    if (done) { return { values, value } }
    values.push(value);
  }
}

/**
 * @param {never} impossible
 * @param {string} mess
 */
function assertNever$3(impossible, mess) {
  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);
}

// @ts-check

/* TODO:
 * - evaluate online sorting
 * - improve anomaly scoring
 * - better consider all the marking stuff in context of its use case
 * - maybe split out the marking stuff, and combine it with its use case
 *   around animation throttling into a separate subclass
 */

// TODO recall what the point / idea of TIGHT_TOL and subsequent mode switching
// under classifyAnomalies
const TIGHT_TOL = 0.1;

class Sample {

  /** @param {number} n */
  constructor(n) {
    this.n = n;
    /** @type {number[]} */
    this.data = [];
    this.lastMark = 0;
    this.markWeight = 1;
  }

  // TODO sort out and document the semantics of marking and weight

  mark() {
    this.markWeight = 1;
    this.lastMark = this.data.length;
  }

  /** @param {number} weight */
  weightedMark(weight) {
    if (this.lastMark > 0) {
      this.markWeight *= weight;
    }
    this.lastMark = this.data.length;
  }

  sinceWeightedMark() {
    return (this.data.length - this.lastMark) / this.markWeight;
  }

  sinceMark() {
    return this.data.length - this.lastMark;
  }

  reset() {
    this.data.length = 0;
    this.lastMark = 0;
    this.markWeight = 1;
  }

  complete() {
    return this.data.length >= this.n;
  }

  /** @param {number} datum */
  collect(datum) {
    while (this.data.length >= this.n) {
      this.data.shift();
    }
    this.data.push(datum);
    if (this.lastMark > 0) {
      if (--this.lastMark === 0) {
        this.markWeight = 1;
      }
    }
  }

  classifyAnomalies() {
    const q = this.quantileSelector();
    const q25 = q(0.25), q50 = q(0.50), q75 = q(0.75);
    const iqr = q75 - q25;
    const { data } = this;

    // TODO what is this?
    if (iqr / q50 < TIGHT_TOL) {
      return data.map(
        datum => datum / q50 - 1
      );
    }

    // const lh = q50 - q25;
    // const rh = q75 - q50;
    // const skew = (rh - lh) / iqr;

    const tol = iqr * 1.5;
    const lo = q25 - tol;
    const hi = q75 + tol;

    return data.map(datum => {
      if (datum < lo) {
        return (datum - lo) / iqr;
      } else if (datum > hi) {
        return (datum - hi) / iqr;
      } else {
        return 0;
      }
    });
  }

  /** @returns {(q: number) => number} */
  quantileSelector() {
    // TODO when is a cleverer data structure / algo worth?
    const S = [...this.data];
    S.sort((a, b) => a - b);
    return q => {
      const i = q * S.length;
      // @ts-ignore proven by S.length bound in prior line
      return S[Math.floor(i)] / 2 + S[Math.ceil(i)] / 2;
    }
  }
}

// @ts-check

class ScreenPoint {
  /**
   * @param {number} [x]
   * @param {number} [y]
   */
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }

  type = 'point.screen'

  copy() {
    return new ScreenPoint(this.x, this.y);
  }

  /** @param {ScreenPoint} other */
  copyFrom(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  }

  toString() {
    return `ScreenPoint(${this.x}, ${this.y});`
  }

  /** @param {ScreenPoint} screenPoint */
  toScreenInto(screenPoint) {
    screenPoint.x = this.x;
    screenPoint.y = this.y;
    return screenPoint;
  }

  toScreen() {
    return this;
  }

  /** @param {number} n */
  scale(n) {
    this.x *= n;
    this.y *= n;
    return this;
  }

  /**
   * @param {number} x
   * @param {number} y
   */
  mulBy(x, y) {
    this.x *= x;
    this.y *= y;
    return this;
  }

  /** @param {ScreenPoint} other */
  add(other) {
    if (other.type !== this.type) {
      other = other.toScreen();
    }
    this.x += other.x;
    this.y += other.y;
    return this;
  }

  /**
   * @param {number} x
   * @param {number} y
   */
  addTo(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }

  /** @param {ScreenPoint} other */
  sub(other) {
    if (other.type !== this.type) {
      other = other.toScreen();
    }
    this.x -= other.x;
    this.y -= other.y;
    return this;
  }
}

class CubePoint {
  /**
   * @param {number} [x]
   * @param {number} [y]
   * @param {number} [z]
   */
  constructor(x = 0, y = 0, z = 0) {
    if (x + y + z !== 0) {
      throw new Error(`CubePoint invariant violated: ${x} + ${y} + ${z} = ${x + y + z}`);
    }
    this.x = x;
    this.y = y;
    this.z = z;
  }

  type = 'point.cube'

  toString() {
    return `CubePoint(${this.x}, ${this.y}, ${this.z})`;
  }

  copy() {
    return new CubePoint(this.x, this.y, this.z);
  }

  /** @param {CubePoint} other */
  copyFrom(other) {
    if (other.type !== this.type) {
      return other.toCubeInto(this);
    }
    this.x = other.x;
    this.y = other.y;
    this.z = other.z;
    return this;
  }

  /** @param {CubePoint} other */
  add(other) {
    if (other.type !== this.type) {
      other = other.toCube();
    }
    this.x += other.x;
    this.y += other.y;
    this.z += other.z;
    return this;
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} z
   */
  addTo(x, y, z) {
    this.x += x;
    this.y += y;
    this.z += z;
    return this;
  }

  /** @param {CubePoint} other */
  sub(other) {
    if (other.type !== this.type) {
      other = other.toCube();
    }
    this.x -= other.x;
    this.y -= other.y;
    this.z -= other.z;
    return this;
  }

  /**
   * @param {number} n
   */
  scale(n) {
    this.x *= n;
    this.y *= n;
    this.z *= n;
    return this;
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} z
   */
  mulBy(x, y, z) {
    this.x *= x;
    this.y *= y;
    this.z *= z;
    return this;
  }

  /** @param {ScreenPoint} screenPoint */
  toScreenInto(screenPoint) {
    screenPoint.x = 3 / 2 * this.x;
    screenPoint.y = Math.sqrt(3) * (this.z + this.x / 2);
    return screenPoint;
  }

  toScreen() {
    return this.toScreenInto(new ScreenPoint());
  }

  /** @param {CubePoint} other */
  toCubeInto(other) {
    other.x = this.x;
    other.y = this.y;
    other.z = this.z;
    return other;
  }

  toCube() {
    return this;
  }

  toOddQOffset() {
    const q = this.x;
    const r = this.z + (this.x - (this.x & 1)) / 2;
    return new OddQOffset(q, r);
  }

  /** @param {OddQOffset} oqo */
  toOddQOffsetInto(oqo) {
    oqo.q = this.x;
    oqo.r = this.z + (this.x - (this.x & 1)) / 2;
  }

  static basis = [
    new CubePoint(1, -1, 0), // SE -- 0, 1
    new CubePoint(0, -1, 1), // S  -- 1, 2
    new CubePoint(-1, 0, 1), // SW -- 2, 3
    new CubePoint(-1, 1, 0), // NW -- 3, 4
    new CubePoint(0, 1, -1), // N  -- 4, 5
    new CubePoint(1, 0, -1)  // NE -- 5, 0
  ]
}

/**
 * @typedef {object} oddQPotent
 * @prop {(oqo: OddQOffset) => void} toOddQOffsetInto
 */

/**
 * @typedef {object} oddQToable
 * @prop {() => OddQOffset} toOddQOffset
 */

class OddQOffset {
  /**
   * @param {number} [q]
   * @param {number} [r]
   */
  constructor(q = 0, r = 0) {
    this.q = q;
    this.r = r;
  }

  type = 'offset.odd-q'

  toString() {
    return `OddQOffset(${this.q}, ${this.r})`;
  }

  copy() {
    return new OddQOffset(this.q, this.r);
  }

  /** @param {oddQPotent} other */
  copyFrom(other) {
    other.toOddQOffsetInto(this);
    return this;
  }

  /** @param {OddQOffset|oddQToable} other */
  add(other) {
    if (other instanceof OddQOffset) {
      const { q, r } = other;
      this.q += q, this.r += r;
    } else {
      const { q, r } = other.toOddQOffset();
      this.q += q, this.r += r;
    }
    return this;
  }

  /**
   * @param {number} q
   * @param {number} r
   */
  addTo(q, r) {
    this.q += q;
    this.r += r;
    return this;
  }

  /** @param {OddQOffset|oddQToable} other */
  sub(other) {
    if (other instanceof OddQOffset) {
      const { q, r } = other;
      this.q -= q, this.r -= r;
    } else {
      const { q, r } = other.toOddQOffset();
      this.q -= q, this.r -= r;
    }
    return this;
  }

  /**
   * @param {number} n
   */
  scale(n) {
    this.q *= n;
    this.r *= n;
    return this;
  }

  /**
   * @param {number} q
   * @param {number} r
   */
  mulBy(q, r) {
    this.q *= q;
    this.r *= r;
    return this;
  }

  /** @param {ScreenPoint} screenPoint */
  toScreenInto(screenPoint) {
    screenPoint.x = 3 / 2 * this.q;
    screenPoint.y = Math.sqrt(3) * (this.r + 0.5 * (this.q & 1));
    return screenPoint;
  }

  toScreen() {
    return this.toScreenInto(new ScreenPoint());
  }

  toOddQOffset() {
    return this;
  }

  /** @param {OddQOffset} oqo */
  toOddQOffsetInto(oqo) {
    oqo.q = this.q;
    oqo.r = this.r;
  }

  /** @param {CubePoint} cubePoint */
  toCubeInto(cubePoint) {
    cubePoint.x = this.q;
    cubePoint.z = this.r - (this.q - (this.q & 1)) / 2;
    cubePoint.y = -cubePoint.x - cubePoint.z;
    return cubePoint;
  }

  toCube() {
    return this.toCubeInto(new CubePoint());
  }
}

/**
 * @typedef {{toOddQOffset: () => OddQOffset}} OddQOffsetIsh
 */

class OddQBox {
  /**
   * @param {OddQOffsetIsh} [topLeft]
   * @param {OddQOffsetIsh} [bottomRight]
   */
  constructor(topLeft = new OddQOffset(), bottomRight = new OddQOffset()) {
    this.topLeft = topLeft.toOddQOffset();
    this.bottomRight = bottomRight.toOddQOffset();
  }

  copy() {
    return new OddQBox(this.topLeft.copy(), this.bottomRight.copy());
  }

  /** @param {OddQBox} other */
  copyFrom(other) {
    this.topLeft.copyFrom(other.topLeft);
    this.bottomRight.copyFrom(other.bottomRight);
    return this;
  }

  toString() {
    return 'OddQBox(' +
      this.topLeft.toString() + ', ' +
      this.bottomRight.toString() + ')';
  }

  screenCount() {
    return this.screenCountInto(new ScreenPoint());
  }

  /** @param {ScreenPoint} screenPoint */
  screenCountInto(screenPoint) {
    const W = this.bottomRight.q - this.topLeft.q;
    const H = this.bottomRight.r - this.topLeft.r;

    // return the count number of hexes needed in screen x space and screen y
    // space

    // first one is a unit, each successive column backs 1/4 with the last
    // const x = 1 + 3 / 4 * (W - 1);
    screenPoint.x = (3 * W + 1) / 4;

    // height backs directly, but we need an extra half cell except when we
    // have only one column
    screenPoint.y = H + (W > 1 ? 0.5 : 0);

    return screenPoint;
  }

  /** @param {OddQOffsetIsh} pointArg */
  contains(pointArg) {
    const point = pointArg.toOddQOffset();
    return point.q >= this.topLeft.q && point.q < this.bottomRight.q &&
      point.r >= this.topLeft.r && point.r < this.bottomRight.r;
  }

  /** @param {OddQOffsetIsh} pointArg */
  expandTo(pointArg) {
    let expanded = false;
    const point = pointArg.toOddQOffset();

    if (point.q < this.topLeft.q) {
      this.topLeft.q = point.q;
      expanded = true;
    } else if (point.q >= this.bottomRight.q) {
      this.bottomRight.q = point.q + 1;
      expanded = true;
    }

    if (point.r < this.topLeft.r) {
      this.topLeft.r = point.r;
      expanded = true;
    } else if (point.r >= this.bottomRight.r) {
      this.bottomRight.r = point.r + 1;
      expanded = true;
    }

    return expanded;
  }
}

// @ts-check

/** @enum {number} - resultant turn bits in a Rules table */
const Turn = {
  // relative turns
  //    F -- +0 -- no turn, forward
  //    B -- +3 -- u turn, backaward
  //    P -- -2 -- double left turn
  //    L -- -1 -- left turn
  //    R -- +1 -- right turn
  //    S -- +2 -- double right turn
  RelForward: 0x0001,
  RelBackward: 0x0002,
  RelLeft: 0x0004,
  RelRight: 0x0008,
  RelDoubleLeft: 0x0010,
  RelDoubleRight: 0x0020,

  // absolute turns (for "flat-top" odd or even q hexagons)
  //   NW -- ? -- North West
  //   NO -- ? -- North
  //   NE -- ? -- North East
  //   SE -- ? -- South East
  //   SO -- ? -- South
  //   SW -- ? -- South West
  AbsNorthWest: 0x0040,
  AbsNorth: 0x0080,
  AbsNorthEast: 0x0100,
  AbsSouthEast: 0x0200,
  AbsSouth: 0x0400,
  AbsSouthWest: 0x0800,
};

/**
 * @param {Turn} turn - a bit field containing any/all chosen turn(s)
 * @param {number} dir - current heading direction for relative turns
 * @returns {Generator<number>} - resultant absolute direction heading(s)
 */
function* turnDirs(turn, dir) {
  let t = 0x0001;
  for (; t <= 0x0020; t <<= 1) {
    if (turn & t) {
      yield (dir + (RelTurnDelta.get(t) || 0) + 6) % 6;
    }
  }
  for (; t <= 0x0800; t <<= 1) {
    if (turn & t) {
      yield (AbsTurnDir.get(t) || 0);
    }
  }
}

/** @type {Map<Turn, number>} */
const RelTurnDelta = new Map([
  [Turn.RelBackward, 3],
  [Turn.RelDoubleLeft, -2],
  [Turn.RelLeft, -1],
  [Turn.RelForward, 0],
  [Turn.RelRight, 1],
  [Turn.RelDoubleRight, 2],
]);

/** @type {Map<Turn, number>} */
const AbsTurnDir = new Map([
  [Turn.AbsSouthEast, 0],
  [Turn.AbsSouth, 1],
  [Turn.AbsSouthWest, 2],
  [Turn.AbsNorthWest, 3],
  [Turn.AbsNorth, 4],
  [Turn.AbsNorthEast, 5],
]);

var nearley$1 = {exports: {}};

(function (module) {
	(function(root, factory) {
	    if (module.exports) {
	        module.exports = factory();
	    } else {
	        root.nearley = factory();
	    }
	}(commonjsGlobal, function() {

	    function Rule(name, symbols, postprocess) {
	        this.id = ++Rule.highestId;
	        this.name = name;
	        this.symbols = symbols;        // a list of literal | regex class | nonterminal
	        this.postprocess = postprocess;
	        return this;
	    }
	    Rule.highestId = 0;

	    Rule.prototype.toString = function(withCursorAt) {
	        var symbolSequence = (typeof withCursorAt === "undefined")
	                             ? this.symbols.map(getSymbolShortDisplay).join(' ')
	                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')
	                                 + " ● "
	                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );
	        return this.name + " → " + symbolSequence;
	    };


	    // a State is a rule at a position from a given starting point in the input stream (reference)
	    function State(rule, dot, reference, wantedBy) {
	        this.rule = rule;
	        this.dot = dot;
	        this.reference = reference;
	        this.data = [];
	        this.wantedBy = wantedBy;
	        this.isComplete = this.dot === rule.symbols.length;
	    }

	    State.prototype.toString = function() {
	        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
	    };

	    State.prototype.nextState = function(child) {
	        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
	        state.left = this;
	        state.right = child;
	        if (state.isComplete) {
	            state.data = state.build();
	            // Having right set here will prevent the right state and its children
	            // form being garbage collected
	            state.right = undefined;
	        }
	        return state;
	    };

	    State.prototype.build = function() {
	        var children = [];
	        var node = this;
	        do {
	            children.push(node.right.data);
	            node = node.left;
	        } while (node.left);
	        children.reverse();
	        return children;
	    };

	    State.prototype.finish = function() {
	        if (this.rule.postprocess) {
	            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
	        }
	    };


	    function Column(grammar, index) {
	        this.grammar = grammar;
	        this.index = index;
	        this.states = [];
	        this.wants = {}; // states indexed by the non-terminal they expect
	        this.scannable = []; // list of states that expect a token
	        this.completed = {}; // states that are nullable
	    }


	    Column.prototype.process = function(nextColumn) {
	        var states = this.states;
	        var wants = this.wants;
	        var completed = this.completed;

	        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration
	            var state = states[w];

	            if (state.isComplete) {
	                state.finish();
	                if (state.data !== Parser.fail) {
	                    // complete
	                    var wantedBy = state.wantedBy;
	                    for (var i = wantedBy.length; i--; ) { // this line is hot
	                        var left = wantedBy[i];
	                        this.complete(left, state);
	                    }

	                    // special-case nullables
	                    if (state.reference === this.index) {
	                        // make sure future predictors of this rule get completed.
	                        var exp = state.rule.name;
	                        (this.completed[exp] = this.completed[exp] || []).push(state);
	                    }
	                }

	            } else {
	                // queue scannable states
	                var exp = state.rule.symbols[state.dot];
	                if (typeof exp !== 'string') {
	                    this.scannable.push(state);
	                    continue;
	                }

	                // predict
	                if (wants[exp]) {
	                    wants[exp].push(state);

	                    if (completed.hasOwnProperty(exp)) {
	                        var nulls = completed[exp];
	                        for (var i = 0; i < nulls.length; i++) {
	                            var right = nulls[i];
	                            this.complete(state, right);
	                        }
	                    }
	                } else {
	                    wants[exp] = [state];
	                    this.predict(exp);
	                }
	            }
	        }
	    };

	    Column.prototype.predict = function(exp) {
	        var rules = this.grammar.byName[exp] || [];

	        for (var i = 0; i < rules.length; i++) {
	            var r = rules[i];
	            var wantedBy = this.wants[exp];
	            var s = new State(r, 0, this.index, wantedBy);
	            this.states.push(s);
	        }
	    };

	    Column.prototype.complete = function(left, right) {
	        var copy = left.nextState(right);
	        this.states.push(copy);
	    };


	    function Grammar(rules, start) {
	        this.rules = rules;
	        this.start = start || this.rules[0].name;
	        var byName = this.byName = {};
	        this.rules.forEach(function(rule) {
	            if (!byName.hasOwnProperty(rule.name)) {
	                byName[rule.name] = [];
	            }
	            byName[rule.name].push(rule);
	        });
	    }

	    // So we can allow passing (rules, start) directly to Parser for backwards compatibility
	    Grammar.fromCompiled = function(rules, start) {
	        var lexer = rules.Lexer;
	        if (rules.ParserStart) {
	          start = rules.ParserStart;
	          rules = rules.ParserRules;
	        }
	        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });
	        var g = new Grammar(rules, start);
	        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable
	        return g;
	    };


	    function StreamLexer() {
	      this.reset("");
	    }

	    StreamLexer.prototype.reset = function(data, state) {
	        this.buffer = data;
	        this.index = 0;
	        this.line = state ? state.line : 1;
	        this.lastLineBreak = state ? -state.col : 0;
	    };

	    StreamLexer.prototype.next = function() {
	        if (this.index < this.buffer.length) {
	            var ch = this.buffer[this.index++];
	            if (ch === '\n') {
	              this.line += 1;
	              this.lastLineBreak = this.index;
	            }
	            return {value: ch};
	        }
	    };

	    StreamLexer.prototype.save = function() {
	      return {
	        line: this.line,
	        col: this.index - this.lastLineBreak,
	      }
	    };

	    StreamLexer.prototype.formatError = function(token, message) {
	        // nb. this gets called after consuming the offending token,
	        // so the culprit is index-1
	        var buffer = this.buffer;
	        if (typeof buffer === 'string') {
	            var lines = buffer
	                .split("\n")
	                .slice(
	                    Math.max(0, this.line - 5), 
	                    this.line
	                );

	            buffer.indexOf('\n', this.index);
	            var col = this.index - this.lastLineBreak;
	            var lastLineDigits = String(this.line).length;
	            message += " at line " + this.line + " col " + col + ":\n\n";
	            message += lines
	                .map(function(line, i) {
	                    return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
	                }, this)
	                .join("\n");
	            message += "\n" + pad("", lastLineDigits + col) + "^\n";
	            return message;
	        } else {
	            return message + " at index " + (this.index - 1);
	        }

	        function pad(n, length) {
	            var s = String(n);
	            return Array(length - s.length + 1).join(" ") + s;
	        }
	    };

	    function Parser(rules, start, options) {
	        if (rules instanceof Grammar) {
	            var grammar = rules;
	            var options = start;
	        } else {
	            var grammar = Grammar.fromCompiled(rules, start);
	        }
	        this.grammar = grammar;

	        // Read options
	        this.options = {
	            keepHistory: false,
	            lexer: grammar.lexer || new StreamLexer,
	        };
	        for (var key in (options || {})) {
	            this.options[key] = options[key];
	        }

	        // Setup lexer
	        this.lexer = this.options.lexer;
	        this.lexerState = undefined;

	        // Setup a table
	        var column = new Column(grammar, 0);
	        this.table = [column];

	        // I could be expecting anything.
	        column.wants[grammar.start] = [];
	        column.predict(grammar.start);
	        // TODO what if start rule is nullable?
	        column.process();
	        this.current = 0; // token index
	    }

	    // create a reserved token for indicating a parse fail
	    Parser.fail = {};

	    Parser.prototype.feed = function(chunk) {
	        var lexer = this.lexer;
	        lexer.reset(chunk, this.lexerState);

	        var token;
	        while (true) {
	            try {
	                token = lexer.next();
	                if (!token) {
	                    break;
	                }
	            } catch (e) {
	                // Create the next column so that the error reporter
	                // can display the correctly predicted states.
	                var nextColumn = new Column(this.grammar, this.current + 1);
	                this.table.push(nextColumn);
	                var err = new Error(this.reportLexerError(e));
	                err.offset = this.current;
	                err.token = e.token;
	                throw err;
	            }
	            // We add new states to table[current+1]
	            var column = this.table[this.current];

	            // GC unused states
	            if (!this.options.keepHistory) {
	                delete this.table[this.current - 1];
	            }

	            var n = this.current + 1;
	            var nextColumn = new Column(this.grammar, n);
	            this.table.push(nextColumn);

	            // Advance all tokens that expect the symbol
	            var literal = token.text !== undefined ? token.text : token.value;
	            var value = lexer.constructor === StreamLexer ? token.value : token;
	            var scannable = column.scannable;
	            for (var w = scannable.length; w--; ) {
	                var state = scannable[w];
	                var expect = state.rule.symbols[state.dot];
	                // Try to consume the token
	                // either regex or literal
	                if (expect.test ? expect.test(value) :
	                    expect.type ? expect.type === token.type
	                                : expect.literal === literal) {
	                    // Add it
	                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});
	                    nextColumn.states.push(next);
	                }
	            }

	            // Next, for each of the rules, we either
	            // (a) complete it, and try to see if the reference row expected that
	            //     rule
	            // (b) predict the next nonterminal it expects by adding that
	            //     nonterminal's start state
	            // To prevent duplication, we also keep track of rules we have already
	            // added

	            nextColumn.process();

	            // If needed, throw an error:
	            if (nextColumn.states.length === 0) {
	                // No states at all! This is not good.
	                var err = new Error(this.reportError(token));
	                err.offset = this.current;
	                err.token = token;
	                throw err;
	            }

	            // maybe save lexer state
	            if (this.options.keepHistory) {
	              column.lexerState = lexer.save();
	            }

	            this.current++;
	        }
	        if (column) {
	          this.lexerState = lexer.save();
	        }

	        // Incrementally keep track of results
	        this.results = this.finish();

	        // Allow chaining, for whatever it's worth
	        return this;
	    };

	    Parser.prototype.reportLexerError = function(lexerError) {
	        var tokenDisplay, lexerMessage;
	        // Planning to add a token property to moo's thrown error
	        // even on erroring tokens to be used in error display below
	        var token = lexerError.token;
	        if (token) {
	            tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
	            lexerMessage = this.lexer.formatError(token, "Syntax error");
	        } else {
	            tokenDisplay = "input (lexer error)";
	            lexerMessage = lexerError.message;
	        }
	        return this.reportErrorCommon(lexerMessage, tokenDisplay);
	    };

	    Parser.prototype.reportError = function(token) {
	        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== undefined ? token.value : token);
	        var lexerMessage = this.lexer.formatError(token, "Syntax error");
	        return this.reportErrorCommon(lexerMessage, tokenDisplay);
	    };

	    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
	        var lines = [];
	        lines.push(lexerMessage);
	        var lastColumnIndex = this.table.length - 2;
	        var lastColumn = this.table[lastColumnIndex];
	        var expectantStates = lastColumn.states
	            .filter(function(state) {
	                var nextSymbol = state.rule.symbols[state.dot];
	                return nextSymbol && typeof nextSymbol !== "string";
	            });

	        if (expectantStates.length === 0) {
	            lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\n');
	            this.displayStateStack(lastColumn.states, lines);
	        } else {
	            lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\n');
	            // Display a "state stack" for each expectant state
	            // - which shows you how this state came to be, step by step.
	            // If there is more than one derivation, we only display the first one.
	            var stateStacks = expectantStates
	                .map(function(state) {
	                    return this.buildFirstStateStack(state, []) || [state];
	                }, this);
	            // Display each state that is expecting a terminal symbol next.
	            stateStacks.forEach(function(stateStack) {
	                var state = stateStack[0];
	                var nextSymbol = state.rule.symbols[state.dot];
	                var symbolDisplay = this.getSymbolDisplay(nextSymbol);
	                lines.push('A ' + symbolDisplay + ' based on:');
	                this.displayStateStack(stateStack, lines);
	            }, this);
	        }
	        lines.push("");
	        return lines.join("\n");
	    };
	    
	    Parser.prototype.displayStateStack = function(stateStack, lines) {
	        var lastDisplay;
	        var sameDisplayCount = 0;
	        for (var j = 0; j < stateStack.length; j++) {
	            var state = stateStack[j];
	            var display = state.rule.toString(state.dot);
	            if (display === lastDisplay) {
	                sameDisplayCount++;
	            } else {
	                if (sameDisplayCount > 0) {
	                    lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');
	                }
	                sameDisplayCount = 0;
	                lines.push('    ' + display);
	            }
	            lastDisplay = display;
	        }
	    };

	    Parser.prototype.getSymbolDisplay = function(symbol) {
	        return getSymbolLongDisplay(symbol);
	    };

	    /*
	    Builds a the first state stack. You can think of a state stack as the call stack
	    of the recursive-descent parser which the Nearley parse algorithm simulates.
	    A state stack is represented as an array of state objects. Within a
	    state stack, the first item of the array will be the starting
	    state, with each successive item in the array going further back into history.

	    This function needs to be given a starting state and an empty array representing
	    the visited states, and it returns an single state stack.

	    */
	    Parser.prototype.buildFirstStateStack = function(state, visited) {
	        if (visited.indexOf(state) !== -1) {
	            // Found cycle, return null
	            // to eliminate this path from the results, because
	            // we don't know how to display it meaningfully
	            return null;
	        }
	        if (state.wantedBy.length === 0) {
	            return [state];
	        }
	        var prevState = state.wantedBy[0];
	        var childVisited = [state].concat(visited);
	        var childResult = this.buildFirstStateStack(prevState, childVisited);
	        if (childResult === null) {
	            return null;
	        }
	        return [state].concat(childResult);
	    };

	    Parser.prototype.save = function() {
	        var column = this.table[this.current];
	        column.lexerState = this.lexerState;
	        return column;
	    };

	    Parser.prototype.restore = function(column) {
	        var index = column.index;
	        this.current = index;
	        this.table[index] = column;
	        this.table.splice(index + 1);
	        this.lexerState = column.lexerState;

	        // Incrementally keep track of results
	        this.results = this.finish();
	    };

	    // nb. deprecated: use save/restore instead!
	    Parser.prototype.rewind = function(index) {
	        if (!this.options.keepHistory) {
	            throw new Error('set option `keepHistory` to enable rewinding')
	        }
	        // nb. recall column (table) indicies fall between token indicies.
	        //        col 0   --   token 0   --   col 1
	        this.restore(this.table[index]);
	    };

	    Parser.prototype.finish = function() {
	        // Return the possible parsings
	        var considerations = [];
	        var start = this.grammar.start;
	        var column = this.table[this.table.length - 1];
	        column.states.forEach(function (t) {
	            if (t.rule.name === start
	                    && t.dot === t.rule.symbols.length
	                    && t.reference === 0
	                    && t.data !== Parser.fail) {
	                considerations.push(t);
	            }
	        });
	        return considerations.map(function(c) {return c.data; });
	    };

	    function getSymbolLongDisplay(symbol) {
	        var type = typeof symbol;
	        if (type === "string") {
	            return symbol;
	        } else if (type === "object") {
	            if (symbol.literal) {
	                return JSON.stringify(symbol.literal);
	            } else if (symbol instanceof RegExp) {
	                return 'character matching ' + symbol;
	            } else if (symbol.type) {
	                return symbol.type + ' token';
	            } else if (symbol.test) {
	                return 'token matching ' + String(symbol.test);
	            } else {
	                throw new Error('Unknown symbol type: ' + symbol);
	            }
	        }
	    }

	    function getSymbolShortDisplay(symbol) {
	        var type = typeof symbol;
	        if (type === "string") {
	            return symbol;
	        } else if (type === "object") {
	            if (symbol.literal) {
	                return JSON.stringify(symbol.literal);
	            } else if (symbol instanceof RegExp) {
	                return symbol.toString();
	            } else if (symbol.type) {
	                return '%' + symbol.type;
	            } else if (symbol.test) {
	                return '<' + String(symbol.test) + '>';
	            } else {
	                throw new Error('Unknown symbol type: ' + symbol);
	            }
	        }
	    }

	    return {
	        Parser: Parser,
	        Grammar: Grammar,
	        Rule: Rule,
	    };

	}));
} (nearley$1));

var nearley = nearley$1.exports;

// @generated from id:2ca93388742b4da7a311d26c788bbaf95002b73588b88a4b0e70319aab4bd37c

// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
function id$1(x) { return x[0]; }
let Lexer = undefined;
let ParserRules = [
    {"name": "spec", "symbols": ["entries"], "postprocess": ([entries]) => ({type: 'spec', entries: entries || []})},
    {"name": "entries", "symbols": ["entry"]},
    {"name": "entries", "symbols": ["entry", "newline", "entries"], "postprocess": ([head, _, tail]) => [head].concat(tail)},
    {"name": "comment$string$1", "symbols": [{"literal":"-"}, {"literal":"-"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "comment$macrocall$2", "symbols": [/[^\n]/]},
    {"name": "comment$macrocall$1$ebnf$1", "symbols": ["comment$macrocall$2"]},
    {"name": "comment$macrocall$1$ebnf$1", "symbols": ["comment$macrocall$1$ebnf$1", "comment$macrocall$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "comment$macrocall$1", "symbols": ["comment$macrocall$1$ebnf$1"], "postprocess": ([parts]) => parts.join('')},
    {"name": "comment", "symbols": ["_", "comment$string$1", "comment$macrocall$1"], "postprocess": ([_0, _1, comment]) => ({type: 'comment', comment})},
    {"name": "entry", "symbols": ["assign"], "postprocess": d => d[0]},
    {"name": "entry", "symbols": ["rule"], "postprocess": d => d[0]},
    {"name": "entry", "symbols": ["directive"], "postprocess": d => d[0]},
    {"name": "entry", "symbols": ["comment"], "postprocess": d => d[0]},
    {"name": "directive$macrocall$2", "symbols": [/[\w]/]},
    {"name": "directive$macrocall$1$ebnf$1", "symbols": ["directive$macrocall$2"]},
    {"name": "directive$macrocall$1$ebnf$1", "symbols": ["directive$macrocall$1$ebnf$1", "directive$macrocall$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "directive$macrocall$1", "symbols": ["directive$macrocall$1$ebnf$1"], "postprocess": ([parts]) => parts.join('')},
    {"name": "directive$macrocall$4", "symbols": [/[^\n]/]},
    {"name": "directive$macrocall$3$ebnf$1", "symbols": ["directive$macrocall$4"]},
    {"name": "directive$macrocall$3$ebnf$1", "symbols": ["directive$macrocall$3$ebnf$1", "directive$macrocall$4"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "directive$macrocall$3", "symbols": ["directive$macrocall$3$ebnf$1"], "postprocess": ([parts]) => parts.join('')},
    {"name": "directive", "symbols": ["_", {"literal":"@"}, "directive$macrocall$1", "__", "directive$macrocall$3"], "postprocess": ([_0, _1, name, _2, value]) => ({type: 'directive', name, value})},
    {"name": "assign", "symbols": ["identifier", "_", {"literal":"="}, "_", "lit"], "postprocess": ([id, _1, _2, _3, value]) => ({type: 'assign', id, value})},
    {"name": "rule", "symbols": ["ant"], "postprocess": ([ant]) => ant},
    {"name": "rule$string$1", "symbols": [{"literal":"="}, {"literal":">"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "rule", "symbols": ["when", "rule$string$1", "then"], "postprocess": ([when, _1, then]) => ({type: 'rule', when, then})},
    {"name": "when", "symbols": ["expr", {"literal":","}, "expr"], "postprocess": ([state, _1, color]) => ({type: 'when', state, color})},
    {"name": "then", "symbols": ["thenState", {"literal":","}, "thenColor", {"literal":","}, "thenTurn"], "postprocess": ([state, _1, color, _3, turn]) => ({type: 'then', state, color, turn})},
    {"name": "thenMode", "symbols": [], "postprocess": () => '='},
    {"name": "thenMode", "symbols": [{"literal":"="}], "postprocess": () => '='},
    {"name": "thenMode", "symbols": [{"literal":"|"}], "postprocess": () => '|'},
    {"name": "thenNoop", "symbols": ["_", {"literal":"_"}, "_"], "postprocess": () => ({type: 'thenVal', mode: '_'})},
    {"name": "thenState", "symbols": ["thenNoop"], "postprocess": d => d[0]},
    {"name": "thenState", "symbols": ["_", "thenMode", "sum", "_"], "postprocess": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},
    {"name": "thenColor", "symbols": ["thenNoop"], "postprocess": d => d[0]},
    {"name": "thenColor", "symbols": ["_", "thenMode", "sum", "_"], "postprocess": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},
    {"name": "thenTurn", "symbols": ["thenNoop"], "postprocess": d => d[0]},
    {"name": "thenTurn", "symbols": ["_", "thenMode", "sum", "_"], "postprocess": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},
    {"name": "thenTurn", "symbols": ["_", "thenMode", "turnExpr", "_"], "postprocess": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},
    {"name": "turnExpr", "symbols": ["turn"], "postprocess": ([name]) => ({type: 'turn', names: [name]})},
    {"name": "turnExpr", "symbols": ["turnExpr", {"literal":"|"}, "turnExpr"], "postprocess": ([a, _1, b]) => ({type: 'turn', names: a.names.concat(b.names)})},
    {"name": "expr", "symbols": ["_", "sum", "_"], "postprocess": d => d[1]},
    {"name": "sumop", "symbols": ["_", {"literal":"+"}, "_"], "postprocess": d => d[1]},
    {"name": "sumop", "symbols": ["_", {"literal":"-"}, "_"], "postprocess": d => d[1]},
    {"name": "mulop", "symbols": ["_", {"literal":"*"}, "_"], "postprocess": d => d[1]},
    {"name": "mulop", "symbols": ["_", {"literal":"/"}, "_"], "postprocess": d => d[1]},
    {"name": "mulop", "symbols": ["_", {"literal":"%"}, "_"], "postprocess": d => d[1]},
    {"name": "sum", "symbols": ["sum", "sumop", "mul"], "postprocess": ([arg1, op, arg2]) => ({type: 'expr', op, arg1, arg2})},
    {"name": "sum", "symbols": ["mul"], "postprocess": d => d[0]},
    {"name": "mul", "symbols": ["mul", "mulop", "fac"], "postprocess": ([arg1, op, arg2]) => ({type: 'expr', op, arg1, arg2})},
    {"name": "mul", "symbols": ["fac"], "postprocess": d => d[0]},
    {"name": "fac", "symbols": [{"literal":"("}, "expr", {"literal":")"}], "postprocess": d => d[1]},
    {"name": "fac", "symbols": ["lit"], "postprocess": d => d[0]},
    {"name": "fac", "symbols": ["member"], "postprocess": d => d[0]},
    {"name": "fac", "symbols": ["symbol"], "postprocess": d => d[0]},
    {"name": "fac", "symbols": ["identifier"], "postprocess": d => d[0]},
    {"name": "ant$string$1", "symbols": [{"literal":"a"}, {"literal":"n"}, {"literal":"t"}, {"literal":"("}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "ant", "symbols": ["_", "ant$string$1", "countTurns", {"literal":")"}, "_"], "postprocess": ([_0, _1, turns]) => ({type: 'ant', turns})},
    {"name": "turns$string$1", "symbols": [{"literal":"t"}, {"literal":"u"}, {"literal":"r"}, {"literal":"n"}, {"literal":"s"}, {"literal":"("}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turns", "symbols": ["turns$string$1", "countTurns", {"literal":")"}], "postprocess": ([_, turns]) => ({type: 'turns', turns})},
    {"name": "turn", "symbols": [{"literal":"L"}], "postprocess": () => 'RelLeft'},
    {"name": "turn", "symbols": [{"literal":"R"}], "postprocess": () => 'RelRight'},
    {"name": "turn", "symbols": [{"literal":"F"}], "postprocess": () => 'RelForward'},
    {"name": "turn", "symbols": [{"literal":"B"}], "postprocess": () => 'RelBackward'},
    {"name": "turn", "symbols": [{"literal":"P"}], "postprocess": () => 'RelDoubleLeft'},
    {"name": "turn", "symbols": [{"literal":"S"}], "postprocess": () => 'RelDoubleRight'},
    {"name": "turn", "symbols": [{"literal":"l"}], "postprocess": () => 'RelLeft'},
    {"name": "turn", "symbols": [{"literal":"r"}], "postprocess": () => 'RelRight'},
    {"name": "turn", "symbols": [{"literal":"f"}], "postprocess": () => 'RelForward'},
    {"name": "turn", "symbols": [{"literal":"b"}], "postprocess": () => 'RelBackward'},
    {"name": "turn", "symbols": [{"literal":"p"}], "postprocess": () => 'RelDoubleLeft'},
    {"name": "turn", "symbols": [{"literal":"s"}], "postprocess": () => 'RelDoubleRight'},
    {"name": "turn$string$1", "symbols": [{"literal":"N"}, {"literal":"W"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$1"], "postprocess": () => 'AbsNorthWest'},
    {"name": "turn$string$2", "symbols": [{"literal":"N"}, {"literal":"O"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$2"], "postprocess": () => 'AbsNorth'},
    {"name": "turn$string$3", "symbols": [{"literal":"N"}, {"literal":"E"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$3"], "postprocess": () => 'AbsNorthEast'},
    {"name": "turn$string$4", "symbols": [{"literal":"S"}, {"literal":"E"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$4"], "postprocess": () => 'AbsSouthEast'},
    {"name": "turn$string$5", "symbols": [{"literal":"S"}, {"literal":"O"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$5"], "postprocess": () => 'AbsSouth'},
    {"name": "turn$string$6", "symbols": [{"literal":"S"}, {"literal":"W"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$6"], "postprocess": () => 'AbsSouthWest'},
    {"name": "turn$string$7", "symbols": [{"literal":"n"}, {"literal":"w"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$7"], "postprocess": () => 'AbsNorthWest'},
    {"name": "turn$string$8", "symbols": [{"literal":"n"}, {"literal":"o"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$8"], "postprocess": () => 'AbsNorth'},
    {"name": "turn$string$9", "symbols": [{"literal":"n"}, {"literal":"e"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$9"], "postprocess": () => 'AbsNorthEast'},
    {"name": "turn$string$10", "symbols": [{"literal":"s"}, {"literal":"e"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$10"], "postprocess": () => 'AbsSouthEast'},
    {"name": "turn$string$11", "symbols": [{"literal":"s"}, {"literal":"o"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$11"], "postprocess": () => 'AbsSouth'},
    {"name": "turn$string$12", "symbols": [{"literal":"s"}, {"literal":"w"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "turn", "symbols": ["turn$string$12"], "postprocess": () => 'AbsSouthWest'},
    {"name": "countTurn", "symbols": ["turn"], "postprocess": ([turn]) => ({count: {type: 'number', value: 1}, turn})},
    {"name": "countTurn", "symbols": ["decint", "turn"], "postprocess": ([count, turn]) => ({count, turn})},
    {"name": "countTurns$ebnf$1", "symbols": []},
    {"name": "countTurns$ebnf$1$subexpression$1", "symbols": ["__", "countTurn"]},
    {"name": "countTurns$ebnf$1", "symbols": ["countTurns$ebnf$1", "countTurns$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "countTurns", "symbols": ["_", "countTurn", "countTurns$ebnf$1", "_"], "postprocess": ([_, first, rest=[]]) => ([first, ...rest.map(([_, next]) => next)])},
    {"name": "member$subexpression$1", "symbols": ["member"]},
    {"name": "member$subexpression$1", "symbols": ["symbol"]},
    {"name": "member$subexpression$1", "symbols": ["identifier"]},
    {"name": "member$subexpression$1", "symbols": ["lit"]},
    {"name": "member", "symbols": ["member$subexpression$1", {"literal":"["}, "expr", {"literal":"]"}], "postprocess": ([[value], _1, item]) => ({type: 'member', value, item})},
    {"name": "symbol$ebnf$1", "symbols": []},
    {"name": "symbol$ebnf$1", "symbols": ["symbol$ebnf$1", /[\w]/], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "symbol", "symbols": [/[a-z]/, "symbol$ebnf$1"], "postprocess": ([head, tail]) => ({type: 'symbol', name: head + tail.join('')})},
    {"name": "identifier$ebnf$1", "symbols": [/[\w]/]},
    {"name": "identifier$ebnf$1", "symbols": ["identifier$ebnf$1", /[\w]/], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "identifier", "symbols": [/[A-Z]/, "identifier$ebnf$1"], "postprocess": ([head, tail]) => ({type: 'identifier', name: head + tail.join('')})},
    {"name": "lit", "symbols": ["int"], "postprocess": d => d[0]},
    {"name": "lit", "symbols": ["turns"], "postprocess": d => d[0]},
    {"name": "int$string$1", "symbols": [{"literal":"0"}, {"literal":"x"}], "postprocess": function joiner(d) {return d.join('');}},
    {"name": "int", "symbols": ["int$string$1", "hexint"], "postprocess": d => d[1]},
    {"name": "int", "symbols": ["decint"], "postprocess": d => d[0]},
    {"name": "hexint$macrocall$2", "symbols": [/[0-9a-fA-F]/]},
    {"name": "hexint$macrocall$1$ebnf$1", "symbols": ["hexint$macrocall$2"]},
    {"name": "hexint$macrocall$1$ebnf$1", "symbols": ["hexint$macrocall$1$ebnf$1", "hexint$macrocall$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "hexint$macrocall$1", "symbols": ["hexint$macrocall$1$ebnf$1"], "postprocess": ([parts]) => parts.join('')},
    {"name": "hexint", "symbols": ["hexint$macrocall$1"], "postprocess": ([num]) => ({type: 'number', value: parseInt(num, 16), base: 16})},
    {"name": "decint$macrocall$2", "symbols": [/[0-9]/]},
    {"name": "decint$macrocall$1$ebnf$1", "symbols": ["decint$macrocall$2"]},
    {"name": "decint$macrocall$1$ebnf$1", "symbols": ["decint$macrocall$1$ebnf$1", "decint$macrocall$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "decint$macrocall$1", "symbols": ["decint$macrocall$1$ebnf$1"], "postprocess": ([parts]) => parts.join('')},
    {"name": "decint", "symbols": ["decint$macrocall$1"], "postprocess": ([num]) => ({type: 'number', value: parseInt(num, 10)})},
    {"name": "_$ebnf$1", "symbols": []},
    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", /[\s]/], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1"], "postprocess": () => null},
    {"name": "__$ebnf$1", "symbols": [/[\s]/]},
    {"name": "__$ebnf$1", "symbols": ["__$ebnf$1", /[\s]/], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__", "symbols": ["__$ebnf$1"], "postprocess": () => null},
    {"name": "newline$ebnf$1", "symbols": [{"literal":"\r"}], "postprocess": id$1},
    {"name": "newline$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "newline", "symbols": ["newline$ebnf$1", {"literal":"\n"}], "postprocess": () => null}
];
let ParserStart = "spec";
var grammarRules = { Lexer, ParserRules, ParserStart };

// @ts-check

// TODO these types can become the basis of a directly coded recursive descent
// parser.js which can replace lang/grammar.{ne,js} entirely

/** @typedef {(
 * | CommentNode
 * | DirectiveNode
 * | SpecNode
 * | AssignNode
 * | AntNode
 * | RuleNode
 * | WhenNode
 * | ThenNode
 * | ThenValNode
 * | MemberNode
 * | ExprNode<NumberNode|TurnsNode>
 * | IdentifierNode
 * | NumberNode
 * | SymbolNode
 * | TurnNode
 * | TurnsNode
 * )} Node */

/** @typedef {object} CommentNode
 * @prop {"comment"} type
 * @prop {string} comment
 */

/** @typedef {object} DirectiveNode
 * @prop {"directive"} type
 * @prop {string} name
 * @prop {string} value
 */

/** @template Literal
 * @typedef {(
 * | Value<Literal>
 * | ExprNode<Literal>
 * )} Expr */

/** @template Literal
 * @typedef {(
 * | MemberNode
 * | SymbolNode
 * | IdentifierNode
 * | Literal
 * )} Value */

/** @typedef {object} SpecNode
 * @prop {"spec"} type
 * @prop {EntryNode[]} entries
 */

/** @typedef {(
 * | AssignNode
 * | CommentNode
 * | DirectiveNode
 * | AntNode
 * | RuleNode
 * )} EntryNode */

/** @typedef {Value<NumberNode|TurnsNode>} AnyValue */
/** @typedef {Expr<NumberNode|TurnsNode>} AnyExpr */

/** @typedef {object} AssignNode
 * @prop {"assign"} type
 * @prop {IdentifierNode} id
 * @prop {AnyExpr} value
 */

/** @typedef {object} RuleNode
 * @prop {"rule"} type
 * @prop {WhenNode} when
 * @prop {ThenNode} then
 */

/** @typedef {object} WhenNode
 * @prop {"when"} type
 * @prop {AnyExpr} state TODO should not be able to have turns
 * @prop {AnyExpr} color TODO should not be able to have turns
 */

/** @typedef {object} ThenNode
 * @prop {"then"} type
 * @prop {ThenValNode} state TODO .value should not be be able to have turns
 * @prop {ThenValNode} color TODO .value should not be be able to have turns
 * @prop {ThenValNode} turn
 */

/** @typedef {(
 * | {type: "thenVal", mode: ("|" | "="), value: AnyExpr}
 * | {type: "thenVal", mode: "_"}
 * )} ThenValNode
 */

/** @typedef {object} MemberNode
 * @prop {"member"} type
 * @prop {AnyValue} value TODO should not be able to have turns?
 * @prop {AnyExpr} item TODO should not be able to have turns?
 */

/** @template Literal
 * @typedef {object} ExprNode
 * @prop {"expr"} type
 * @prop {ExprOp} op
 * @prop {Expr<Literal>} arg1
 * @prop {Expr<Literal>} arg2
 */

/** @typedef {"+" | "-" | "*" | "/" | "%"} ExprOp */

/** @typedef {object} IdentifierNode
 * @prop {"identifier"} type
 * @prop {string} name
 */

/** @typedef {object} NumberNode
 * @prop {"number"} type
 * @prop {number} value
 * @prop {number} [base]
 */

/** @typedef {object} SymbolNode
 * @prop {"symbol"} type
 * @prop {string} name
 */

/** @typedef {(
 * | 'RelLeft'
 * | 'RelRight'
 * | 'RelForward'
 * | 'RelBackward'
 * | 'RelDoubleLeft'
 * | 'RelDoubleRight'
 * | 'AbsNorthWest'
 * | 'AbsNorth'
 * | 'AbsNorthEast'
 * | 'AbsSouthEast'
 * | 'AbsSouth'
 * | 'AbsSouthWest'
 * )} Turn */

/** @typedef {object} TurnNode
 * @prop {"turn"} type
 * @prop {Turn[]} names
 */

/** @typedef {object} AntNode
 * @prop {"ant"} type
 * @prop {CountTurn[]} turns
 */

/** @typedef {object} TurnsNode
 * @prop {"turns"} type
 * @prop {CountTurn[]} turns
 */

/** @typedef {object} CountTurn
 * @prop {NumberNode} count
 * @prop {Turn} turn
 */

/** @typedef {Node['type']} NodeType */

/**
 * @template {NodeType} T
 * @typedef {Extract<Node, {type: T}>} TypedNode
 */

/**
 * @template {NodeType} T
 * @param {T} type
 * @param {Node} node
 * @returns {node is TypedNode<T>}
 */
function isNodeType(type, node) {
  return node.type === type;
}

/**
 * @param {Node} node
 * @returns {node is EntryNode}
 */
function isEntryNode(node) {
  switch (node.type) {
    case 'ant':
    case 'assign':
    case 'comment':
    case 'directive':
    case 'rule':
      return true;
    default:
      return false;
  }
}

/**
 * @param {number} value
 * @param {number} [base] - defaults to base-10 if unspecified
 * @returns {NumberNode}
 */
function number(value, base) {
  return { type: 'number', value, base };
}

/**
 * @param {string} name
 * @returns {IdentifierNode}
 */
function id(name) {
  return { type: 'identifier', name };
}

/**
 * @param {string} name
 * @returns {SymbolNode}
 */
function sym(name) {
  return { type: 'symbol', name };
}

/**
 * @param {EntryNode[]} entries
 * @returns {SpecNode}
 */
function spec(...entries) {
  return { type: 'spec', entries };
}

/**
 * @param {string|IdentifierNode} id
 * @param {AnyExpr} value
 * @returns {AssignNode}
 */
function assign(id, value) {
  if (typeof id === 'string') id = { type: 'identifier', name: id };
  return { type: 'assign', id, value };
}

/**
 * @param {WhenNode} when
 * @param {ThenNode} then
 * @returns {RuleNode}
 */
function rule(when, then) {
  return { type: 'rule', when, then };
}

/**
 * @param {CountTurn[]} turns
 * @returns {TurnsNode}
 */
function turns(...turns) {
  return { type: 'turns', turns };
}

/**
 * @param {AnyValue} value
 * @param {AnyExpr} item
 * @returns {MemberNode}
 */
function member(value, item) {
  return { type: 'member', value, item };
}

/**
 * @template {Node} S
 * @template {Node} T
 * @param {ExprOp} op
 * @param {S} arg1
 * @param {T} arg2
 * @returns {ExprNode<S|T>}
 */
function expr(op, arg1, arg2) {
  return { type: 'expr', op, arg1, arg2 };
}

/**
 * @param {AnyExpr} state
 * @param {AnyExpr} color
 * @returns {WhenNode}
 */
function when(state, color) {
  return ({ type: 'when', state, color });
}

/**
 * @param {AnyExpr|ThenValNode} state
 * @param {AnyExpr|ThenValNode} color
 * @param {AnyExpr|ThenValNode} turn
 * @returns {ThenNode}
 */
function then(state, color, turn) {
  return {
    type: 'then',
    state: thenVal(state),
    color: thenVal(color),
    turn: thenVal(turn),
  };
}

/**
 * @param {AnyExpr|ThenValNode} value
 * @param {"="|"|"} [mode]
 * @returns {ThenValNode}
 */
function thenVal(value, mode = '=') {
  return value.type === 'thenVal' ? value : { type: 'thenVal', mode, value };
}

/**
 * @param {AnyExpr} value
 * @returns {ThenValNode}
 */
function thenSet(value) {
  return { type: 'thenVal', mode: '=', value };
}

/** @returns {ThenValNode} */
function thenPass() {
  return { type: 'thenVal', mode: '_' };
}

/**
 * @param {Node} node
 * @returns {node is AnyExpr}
 */
function isAnyExpr(node) {
  switch (node.type) {
    // Expr<Literal>
    case 'expr':
      return true;

    // is Value<Literal>
    default:
      return isAnyValue(node);
  }
}

/**
 * @param {Node} node
 * @returns {node is AnyValue}
 */
function isAnyValue(node) {
  switch (node.type) {
    // Value<Literal>
    case 'member':
    case 'symbol':
    case 'identifier':

    // Literal = NumberNode | TurnsNode
    case 'number':
    case 'turns':
      return true;

    default:
      return false;
  }
}

// @ts-check
const grammar = nearley.Grammar.fromCompiled(grammarRules);

/** @typedef {import('./grammar.js').Node} Node */
/** @typedef {import('./grammar.js').NodeType} NodeType */
/** @template T @typedef {import('./grammar.js').TypedNode<T>} TypedNode */

/**
 * @template {NodeType} T
 * @param {T} type
 * @param {Node} node
 * @returns {TypedNode<T>}
 */
function asTypedNode(type, node) {
  if (!isNodeType(type, node)) throw new Error(
    `expected a ${JSON.stringify(type)} grammar node, ` +
    `got a ${JSON.stringify(type)} node`);
  return node;
}

/** @param {string} str */
function parse$1(str) {
  if (typeof str !== 'string') {
    return error(new Error('invalid argument, not a string'));
  }
  return catchErr(() => {
    const parser = new nearley.Parser(grammar);
    parser.feed(str);

    /** @type {{ results: Node[] }} */
    const { results } = parser;
    switch (results.length) {
      case 0:
        return error(new Error('no parse result'));
      case 1:
        return just(asTypedNode('spec', results[0]));
      default:
        return error(new Error('ambiguous parse'));
    }
  });
}

// @ts-check

/** Builds a canonical RLE string from possibly redundant parts.
 *
 * Exemplars:
 * - "A A A" => "3A"
 * - "3A 2A" => "5A"
 *
 * Except that all tokenization concerns are up to the caller, so this builder
 * takes pre-parsed (count: number, sym: string) pairs, and returns a list
 * containing accumulated terms (not including the current one). The caller
 * shouldn't really care about the return value until after a terminal () call.
 *
 * Usage:
 *   const input = 'A B B 3C 3D D';
 *   const {consume, finish} = RLEBuilder();
 *   for (const token of input.split(/\s+/)) {
 *     consume(token);
 *     // NOTE: caller may parser their own count/sym apart if necessary and call consume(count, sym)
 *   }
 *   const output = finish().join(' ');
 *   // output = "A 2B 3C 4D"
 *
 * NOTE: any empty symbol strings and counts <= 0 are elided
 */
function RLEBuilder() {
  /** @type {[count: number, sym: string][]} */
  let parts = [];
  let cur = '', curCount = 0;

  return {
    /**
     * NOTE: altho it's the sym agument that is formally optional, one should
     * think of this signature more like consume([count, ]sym):
     * - if a single string argument is given, any numeric prefix is parsed out
     *   and becomes count (default 1)
     * - if a single numeric argument is given, that's a noop (empty symbol)
     * - if two strings are given, any non-numeric suffix in the count string
     *   is ignored
     * - those last two cases are just unfortunate outcomes of javascript's
     *   semimplicit type system, and not really intended use cases
     *
     * @param {string|number} count
     * @param {string} [sym]
     */
    consume(count, sym) {
      if (sym === undefined) {
        if (typeof count != 'string') { return }
        const match = /(\d*)(\w+)/.exec(count);
        if (!match) { return }
        count = match[1], sym = match[2];
      }
      if (typeof count == 'string') {
        count = parseInt(count);
        if (isNaN(count)) {
          count = 1;
        }
      }

      if (cur !== sym) {
        if (cur && curCount) {
          parts.push([curCount, cur]);
        }
        cur = sym, curCount = 0;
      }
      curCount += count;
    },

    finish() {
      if (cur && curCount) {
        parts.push([curCount, cur]);
      }
      const res = parts;
      parts = [], cur = '', curCount = 0;
      return res;
    }
  };
}

/** @param {Iterable<[count: string|number, sym?: string]>} countsyms */
function from(countsyms) {
  const { consume, finish } = RLEBuilder();
  for (const [count, sym] of countsyms) {
    consume(count, sym);
  }
  return finish();
}

// @ts-check

/** @typedef {import('./grammar.js').Node} Node */


// TODO reconcile with ./constants.js
const TurnSyms = {
  RelLeft: 'L',
  RelRight: 'R',
  RelForward: 'F',
  RelBackward: 'B',
  RelDoubleLeft: 'P',
  RelDoubleRight: 'S',
  AbsNorth: 'NO',
  AbsNorthWest: 'NW',
  AbsNorthEast: 'NE',
  AbsSouth: 'SO',
  AbsSouthEast: 'SE',
  AbsSouthWest: 'SW'
};

// TODO: de-dupe
const opPrec$1 = ['+', '-', '*', '/', '%'];

/**
 * @param {Node[]} nodes
 * @returns {Generator<string>}
 */
function* toSpecString(...nodes) {
  yield* toString(0, ...nodes);
}

/**
 * @param {number} outerPrec
 * @param {Node[]} nodes
 * @returns {Generator<string>}
 */
function* toString(outerPrec, ...nodes) {
  for (const node of nodes) {
    switch (node.type) {

      case 'spec': {
        const { entries } = node;
        for (const entry of entries) {
          yield* toString(outerPrec, entry);
        }
        break;
      }

      case 'comment': {
        const { comment } = node;
        yield `--${comment}`;
        break;
      }

      case 'directive': {
        const { name, value } = node;
        yield `@${name} ${value}`;
        break;
      }

      case 'assign': {
        const { id: { name }, value } = node;
        const it = toString(outerPrec, value);
        yield `${name} = ${next(it, '')}`;
        yield* it;
        break;
      }

      case 'rule': {
        const { when, then } = node;
        const it = toString(outerPrec, when, then);
        yield `${next(it, '')} => ${next(it, '')}`;
        yield* it;
        break;
      }

      case 'when': {
        const { state, color } = node;
        const it = toString(outerPrec, state, color);
        yield `${next(it, '')}, ${next(it, '')}`;
        yield* it;
        break;
      }

      case 'then':
        const { state, color, turn } = node;
        const it = toString(outerPrec, state, color, turn);
        yield `${next(it, '')}, ${next(it, '')}, ${next(it, '')}`;
        yield* it;
        break;

      case 'thenVal': {
        const { mode } = node;
        if (mode === '_') {
          yield '_';
          break;
        }

        const { value } = node;
        const it = toString(outerPrec, value);
        yield `${mode === '=' ? '' : mode}${next(it, '')}`;
        yield* it;
        break;
      }

      case 'member': {
        const { value, item } = node;
        const it = toString(outerPrec, value, item);
        yield `${next(it, '')}[${next(it, '')}]`;
        yield* it;
        break;
      }

      case 'expr': {
        const { op, arg1, arg2 } = node;
        const prec = opPrec$1.indexOf(op);
        const it = toString(outerPrec, arg1, arg2);
        const expr = `${next(it, '')} ${op} ${next(it, '')}`;
        yield prec < outerPrec ? `(${expr})` : expr;
        yield* it;
        break;
      }

      case 'identifier':
      case 'symbol': {
        const { name } = node;
        yield name;
        break;
      }

      case 'ant':
      case 'turns': {
        const { type, turns } = node;
        yield `${type}(${from(turns
          .map(({ count: { value: count }, turn }) => [count, TurnSyms[turn]])
        )
          .map(([count, sym]) => count > 1 ? `${count}${sym}` : sym)
          .join(' ')})`;
        break;
      }

      case 'turn': {
        const { names } = node;
        yield names.map(name => TurnSyms[name]).join('|');
        break;
      }

      case 'number': {
        const { value, base } = node;
        yield value.toString(base);
        break;
      }

      default:
        assertNever$2(node, 'invalid grammar node');
    }
  }
}

/** @template T
 * @param {Iterator<T>} it
 * @param {T} or
 */
function next(it, or) {
  const { done, value } = it.next();
  return done ? or : value;
}

/**
 * @param {never} impossible
 * @param {string} mess
 */
function assertNever$2(impossible, mess) {
  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);
}

// @ts-check

/** @typedef {import('./grammar.js').AnyExpr} AnyExpr */
/** @typedef {import('./grammar.js').ThenValNode} ThenValNode */
/** @typedef {import('./grammar.js').CountTurn} CountTurn */

/** @typedef {import('./grammar.js').Node} Node */
/** @typedef {import('./grammar.js').SpecNode} SpecNode */
/** @typedef {import('./grammar.js').NodeType} NodeType */

/** @template T @typedef {import('./grammar.js').TypedNode<T>} TypedNode */

/**
 * @param {SpecNode} spec
 * @returns {Generator<{name: string, label?: string, then: (spec: SpecNode) => SpecNode}>}
 */
function* actions(spec) {
  if (
    spec.entries.some(({ type }) => type == 'ant') &&
    spec.entries.every(({ type }) => type != 'rule')
  ) yield {
    name: 'liftToTurmite',
    label: 'Convert To Turmite',
    then: spec => transformed(spec,
      matchType('ant', ({ turns }) => antRule(turns))) || spec,
  };
}

/** @param {string} str */
function isJustAnt(str) {
  return /^\s*ant(\(.*|\s*$)/.test(str);
}

/**
 * @param {CountTurn[]} antTurns
 * @param {object} options
 * @param {number} [options.state]
 * @param {AnyExpr} [options.whenState]
 * @param {ThenValNode} [options.thenState]
 */
function antRule(antTurns, {
  state = 0,
  whenState = number(state),
  thenState = thenSet(number(state)),
} = {}) {
  const c = sym('c');
  return rule(when(whenState, c), then(
    thenState,
    expr('+', c, number(1)),
    member(turns(...antTurns), c),
  ));
}

/**
 * @template {NodeType} T
 * @param {T} type
 * @param {TypedNodeTransform<T>} fn
 * @returns {NodeTransform}
 */
function matchType(type, fn) {
  return node => isNodeType(type, node)
    ? fn(node)
    : undefined;
}

/** @template {NodeType} T
 * @callback TypedNodeTransform
 * @param {TypedNode<T>} node
 * @returns {Node|null|void}
 */

/** @callback NodeTransform
 * @param {Node} node
 * @returns {Node|null|void}
 */

/**
 * @template {Node} NT
 * @param {NT} node
 * @param {NodeTransform[]} xforms
 * @returns {NT|null}
 */
function transformed(node, ...xforms) {
  const oldType = node.type;

  /**
   * @param {Node} n
   * @returns {n is NT}
   */
  function isSameType(n) {
    return n.type === oldType;
  }

  const newNode = transform(node, ...xforms);
  if (newNode === null) return null;
  if (!newNode) return node;
  if (!isSameType(newNode)) throw new Error('invalid replacement node');

  return newNode;
}

/**
 * @param {Node} node
 * @param {NodeTransform[]} xforms
 * @returns {Node|null|void}
 */
function transform(node, ...xforms) {
  if (!xforms.length) return node;

  /** @type {NodeTransform} */
  const xform = xforms.length > 1
    ? node => {
      for (const xform of xforms) {
        node = xform(node) || node;
      }
      return node;
    }
    : xforms[0];
  return each(node);

  /** @param {Node} node @returns {Node|null|void} */
  function each(node) {
    let newNode = xform(node);
    if (newNode === null) return null; // explicit delete
    if (newNode && newNode !== node) {
      newNode = each(newNode) || newNode;
    }
    node = newNode || node;
    const res = descend(node);
    return res === undefined ? node : res;
  }

  /** @param {Node} node @returns {Node|null|void} */
  function descend(node) {
    switch (node.type) {

      case 'spec': {
        let any = false;
        const entries = node.entries.map(entry => {
          const rep = each(entry);
          if (rep && !isEntryNode(rep))
            throw new Error('invalid replacement spec entry');
          if (rep === undefined) return entry;
          any = any || rep !== entry;
          return rep;
        }).filter(notNull);
        return !any ? undefined // no change
          : !entries.length ? null // delete if empty
            : spec(...entries);
      }

      case 'assign': {
        let id = each(node.id);
        let value = each(node.value);
        if (id === null || value === null) return null; // delete spreads
        if (!id && !value) return undefined; // no change
        if (!id) id = node.id;
        else if (id.type !== 'identifier') throw new Error('invalid replacement identifier node');
        if (!value) value = node.value;
        else if (!isAnyExpr(value)) throw new Error('invalid replacement value node');
        return assign(id, value);
      }

      case 'rule': {
        let when = each(node.when);
        let then = each(node.then);
        if (when === null || then === null) return null; // delete spreads
        if (!when && !then) return undefined; // no change
        if (!when) when = node.when;
        else if (when.type !== 'when') throw new Error('invalid replacement when node');
        if (!then) then = node.then;
        else if (then.type !== 'then') throw new Error('invalid replacement then node');
        return rule(when, then);
      }

      case 'when': {
        let state = each(node.state);
        let color = each(node.color);
        if (state === null || color === null) return null; // delete spreads
        if (!state && !color) return undefined; // no change
        if (!state) state = node.state;
        else if (!isAnyExpr(state)) throw new Error('invalid replacement when.state node');
        if (!color) color = node.color;
        else if (!isAnyExpr(color)) throw new Error('invalid replacement when.color node');
        return when(state, color);
      }

      case 'then': {
        let state = each(node.state);
        let color = each(node.color);
        let turn = each(node.turn);
        if (state === null) state = thenPass(); // deleted clause now passes
        if (color === null) color = thenPass(); // deleted clause now passes
        if (turn === null) turn = thenPass(); // deleted clause now passes
        if (!state && !color && !turn) return undefined; // no change
        if (!state) state = node.state;
        else if (state.type !== 'thenVal') throw new Error('invalid replacement then.state node');
        if (!color) color = node.color;
        else if (color.type !== 'thenVal') throw new Error('invalid replacement then.color node');
        if (!turn) turn = node.turn;
        else if (turn.type !== 'thenVal') throw new Error('invalid replacement then.turn node');
        // delete spreads only if all clauses now pass (at least one was just deleted above)
        if (state.mode === '_' && color.mode === '_' && turn.mode === '_') return null;
        return then(state, color, turn);
      }

      case 'thenVal': {
        const { mode } = node;
        if (mode == '_') return undefined; // no change
        let value = each(node.value);
        if (value === null) return null; // delete spreads
        if (!value) return undefined; // no change
        if (!isAnyExpr(value)) throw new Error('invalid replacement then value node');
        return thenVal(value, mode);
      }

      case 'member': {
        let item = each(node.item);
        let value = each(node.value);
        if (item === null || value === null) return null; // delete spreads
        if (!item && !value) return undefined; // no change
        if (!item) item = node.item;
        else if (!isAnyExpr(item)) throw new Error('invalid replacement item node');
        if (!value) value = node.value;
        else if (!isAnyValue(value)) throw new Error('invalid replacement value node');
        return member(value, item);
      }

      case 'expr': {
        const { op } = node;
        let arg1 = each(node.arg1);
        let arg2 = each(node.arg2);
        if (arg1 === null || arg2 === null) return null; // delete spreads
        if (!arg1 && !arg2) return undefined; // no change
        if (!arg1) arg1 = node.arg1;
        else if (!isAnyExpr(arg1)) throw new Error('invalid replacement arg1 node');
        if (!arg2) arg2 = node.arg2;
        else if (!isAnyExpr(arg2)) throw new Error('invalid replacement arg2 node');
        return expr(op, arg1, arg2);
      }

      case 'ant':
      case 'comment':
      case 'directive':
      case 'identifier':
      case 'number':
      case 'symbol':
      case 'turn':
      case 'turns':
        return undefined;

      default:
        assertNever$1(node, 'invalid transform node');
        return undefined;
    }
  }
}

/** @template T
 * @param {T|null} val
 * @returns {val is Exclude<T, null>}
 */
function notNull(val) {
  return val !== null;
}

/**
 * @param {never} impossible
 * @param {string} mess
 */
function assertNever$1(impossible, mess) {
  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);
}

// @ts-check

/** @typedef {import('./grammar.js').Node} Node */
/** @typedef {import('./grammar.js').SpecNode} SpecNode */
/** @typedef {import('./grammar.js').AssignNode} AssignNode */
/** @typedef {import('./grammar.js').RuleNode} RuleNode */
/** @typedef {import('./grammar.js').WhenNode} WhenNode */
/** @typedef {import('./grammar.js').ThenNode} ThenNode */
/** @typedef {import('./grammar.js').ThenValNode} ThenValNode */
/** @typedef {import('./grammar.js').NumberNode} NumberNode */
/** @typedef {import('./grammar.js').TurnsNode} TurnsNode */
/** @typedef {import('./grammar.js').TurnNode} TurnNode */
/** @typedef {import('./grammar.js').AnyExpr} AnyExpr */
/** @template T @typedef {import('./grammar.js').Expr<T>} Expr */

// TODO: de-dupe
const opPrec = ['+', '-', '*', '/', '%'];

/** @typedef {{[key: number]: number}} Rules - A turmite rule lookup table
 *
 * Keys have 2 bit-packed fields encoding color and state:
 * - color: the value of the cell currently occupied by the turmite
 * - state: the turmite's current internal state value; has no intrinsic
 *          semantics other than as part of rules table keys, broadening
 *          the space of potential rules greatly as compared to an ant that
 *          merely dispatches on color
 *
 * Values have 3 bit-packed fields encoding result color, state, and turn:
 * - color: the cell currently occupied by the turmite will have its color
 *          changed to this value
 * - state: the turmite's state value will be set to this; its primary purpose
 *          is to expand the rule table keyspace, allowing for things like
 *          multiple "modes" of turmite rules to be packed into one table
 * - turn: bit field encoding what turn(s) the turmite should make after
 *         updating color and state as above; having multiple turn bits set
 *         implies a "fork" (creation of one or more new turmites)
 *
 * Therefore a rules table MUST have a specific/static length to fully
 * encompass all possible color|state keys; see RuleConstants below for how
 * particulars are specified.
 */

/** @typedef {object} RuleConstants - specifies rule lookup table particulars
 * @prop {number} MaxColor - maximum color value; should be some 2^N-1
 * @prop {number} MaxState - maximum state value; should be some 2^N-1
 * @prop {number} MaxTurn - maximum turn value; should be some 2^N-1
 * @prop {number} MaskResultColor - color field mask for result extraction
 * @prop {number} MaskResultState - state field mask for result extraction
 * @prop {number} MaskResultTurn - turn field mask for result extraction
 * @prop {number} ColorShift - bit width to shift color values by when packing keys and extracting results
 * @prop {number} TurnShift - bit width to shift turn values by when extracting results
 * NOTE: state values live in the lowest bits and are therefore unshifted
 */

/** @callback Builder
 * @param {Rules} rules
 * @param {RuleConstants} ruleSpec
 * @returns {rezult.Result<Built>}
 */

/** @typedef {object} Built
 * @prop {number} numColors
 * @prop {number} numStates
 * @prop {string} specString
 */

/**
 * @param {SpecNode} spec
 * @returns {rezult.Result<Builder>}
 */
function compileBuilder(spec) {
  const lines = compileCode(spec);
  const codeRes = catchErr(() => just([...endLines(lines)].join('')));

  const funcRes = bind(codeRes, code => {
    try {
      return just(Function(`"use strict"; return (${code})`));
    } catch (codeErr) {
      return error(new Error(`${codeErr}\nTrying to compile:\n${code}`));
    }
  });

  const valRes = bind(funcRes, func =>
    catchErr(() => just(func())));

  return bind(valRes, value => {
    // TODO replace this runtime type validation with a test-time typecheck of
    // some example code

    if (typeof value != 'function') {
      return error(new Error(
        `invalid builder function, got a ${typeof value} instead of a function`))
    }

    return just(/** @type {Builder} */(value));
  });
}

/** @typedef {"value"|"module"} CodeFormat */

/**
 * @param {SpecNode} spec
 * @param {object} [options]
 * @param {CodeFormat} [options.format]
 */
function compileCode(spec, { format = 'value' } = {}) {
  const scope = makeScope();

  return compileContent(spec);

  /** @param {SpecNode} spec */
  function* compileContent(spec) {
    switch (format) {
      case 'value':
        yield* compileArrowFn(scope, ['_rules', 'World'], function*() {
          yield* compileDefinitions(spec);
          yield* compileRuleBuilder(spec);
        });
        break;

      case 'module':
        yield* compileDefinitions(spec);
        yield* compileFunction(scope, 'export default build', ['_rules', 'World'], function*() {
          yield* compileRuleBuilder(spec);
        });
        break;

      default:
        assertNever(format, 'invalid format');
    }
  }

  /** @param {SpecNode} spec */
  function* compileDefinitions(spec) {
    scope.define('specString');
    yield* amend({
      head: 'const specString = ',
      cont: '  ',
      zero: `''`,
      foot: ';',
    }, multiLineQuoted(toSpecString(spec)));
    yield '';

    scope.define('numColors');
    yield `const numColors = ${countNumColors(spec)};`;
    yield '';
  }

  /**
   * @param {Node} node
   * @param {amendments} [params]
   */
  function* compileSpecComment(node, params) {
    let spec = toSpecString(node);
    if (params) spec = amend(params, spec);
    yield* comment(spec);
  }

  /** @param {SpecNode} spec */
  function* compileRuleBuilder(spec) {
    yield 'if (numColors > World.MaxColor+1) return {err: `required numColors:${numColors} exceeds world max:(${World.MaxColor})`};';
    yield '';

    scope.define('_states');
    yield 'const _states = new Set();';
    yield '';

    for (const entry of spec.entries) {
      switch (entry.type) {
        case 'comment':
          yield* comment([entry.comment.trimStart()]);
          break;

        case 'directive':
          yield* comment([`@${entry.name} ${entry.value.trimStart()}`]);
          break;

        case 'assign':
          yield '';
          yield* compileSpecComment(entry, { head: 'assign: ' });
          yield* compileAssign(entry);
          break;

        case 'ant':
          yield '';
          yield* compileSpecComment(entry, { head: 'rule: ' });
          yield* compileRule(antRule(entry.turns));
          break;

        case 'rule':
          yield '';
          yield* compileSpecComment(entry, { head: 'rule: ' });
          yield* compileRule(entry);
          break;

        default:
          assertNever(entry, 'invalid rule node');
      }
    }

    yield 'return {value: {specString, numColors, numStates: _states.size}};';
  }

  /** @param {AssignNode} assign */
  function* compileAssign({ id: { name }, value }) {
    scope.define(name);
    yield `let ${name} = ${compileValue(scope, value)};`; // TODO can this be constified?
  }

  /** @param {RuleNode} rule */
  function* compileRule(rule) {
    yield* scope.block(function*() {
      /** @type {AssignNode[]} */
      const assigns = [];

      const xrule = transformed(rule,

        // TODO possible, but uncertain if should bring back implicit indexing
        // analyze.matchType('then', ({ state, color, turn }) => {
        //   const { mode } = turn;
        //   if (mode === '_') return;
        //
        //   const { value } = turn;
        //   if (value.type !== 'turns') return;
        //
        //   /** @type {AnyExpr|null} */
        //   let colorExpr = null;
        //   analyze.transform(rule, analyze.matchType('when', ({ color }) => { colorExpr = color }));
        //   if (!colorExpr) throw new Error('unablet to find when-color expression to auto-index then-turns');
        //
        //   turn = analyze.thenVal(analyze.member(value, colorExpr), mode);
        //   return analyze.then(state, color, turn);
        // }),

        matchType('member', ({ value, item }) => {
          switch (value.type) {
            case 'symbol':
            case 'identifier':
              return;
            default:
              const { type } = value;
              const name = scope.gen(`${type[0].toUpperCase()}${type.slice(1)}`);
              assigns.push(assign(name, value));
              return member(id(name), item);
          }
        }),

      );
      if (!xrule) {
        yield* comment([
          'eliminated by transform',
          ...JSON.stringify(rule, null, 2).split(/\n/)
        ]);
        return;
      }

      const { when, then } = xrule;
      for (const assign of assigns)
        yield* compileAssign(assign);
      yield* compileRuleBody(when, then);
    });
  }

  /**
   * @param {WhenNode} when
   * @param {ThenNode} then
   */
  function* compileRuleBody(
    { state: whenState, color: whenColor },
    { state: thenState, color: thenColor, turn: thenTurn },
  ) {

    /** @typedef {object} ThenDecl
     * @prop {string} name
     * @prop {string} mask
     * @prop {string} max
     * @prop {string} [shift]
     */

    const thens = /** @type {({then: ThenValNode} & ThenDecl)[]} */ ([
      {
        name: 'state',
        then: thenState,
        mask: 'World.MaskResultState',
        max: 'World.MaxState',
        shift: 'World.ColorShift',
      },
      {
        name: 'color',
        then: thenColor,
        mask: 'World.MaskResultColor',
        max: 'World.MaxColor',
        shift: 'World.TurnShift',
      },
      {
        name: 'turn',
        then: thenTurn,
        mask: 'World.MaskResultTurn',
        max: 'World.MaxTurn',
      },
    ]).map(({ then, ...decl }) => {
      let isEmpty = true;

      const { mode } = then;
      if (mode !== '_') {
        const { value } = then;
        isEmpty = mode === '|' && compileValue(
          // ignore symbol defined check, all we care about here: "is the expression statically 0?"
          { has() { return true } }, value, opPrec.length) === '0';
      }

      return { then, isEmpty, ...decl };
    });
    if (thens.every(({ isEmpty }) => isEmpty)) return;

    /** @typedef {object} WhenDecl
     * @prop {string} name
     * @prop {string} cap
     * @prop {string} sym
     * @prop {string} max
     * @prop {string} [shift]
     * @prop {(cap: string) => string} [init]
     */

    const whens = /** @type {({when: AnyExpr} & WhenDecl)[]} */ ([
      {
        when: whenState,
        name: 'state',
        cap: '_state',
        sym: '_stateKey',
        shift: 'World.ColorShift',
        max: 'World.MaxState',
        init: cap => `_states.add(${cap});`,
      },
      {
        when: whenColor,
        name: 'color',
        cap: '_color',
        sym: '_colorKey',
        max: 'World.MaxColor',
      },
    ]);

    {
      const maskParts = thens
        .map(({ then: { mode }, mask }) => mode === '=' ? mask : '')
        .filter(part => part);
      switch (maskParts.length) {
        case 0:
          break;

        case 1:
          scope.define('_priorMask');
          yield `const _priorMask = ~${maskParts[0]};`;
          yield '';
          break;

        default:
          scope.define('_priorMask');
          yield `const _priorMask = ~(${maskParts
            .reduce((mask, part) => `${mask}${mask ? ' | ' : ''}${part}`)});`;
          yield '';
      }
    }

    yield* compileWhenMatch(0);

    /**
     * @param {number} i -- whens[i]
     * @returns {Generator<string>}
     */
    function* compileWhenMatch(i, priorKey = '') {
      if (i < whens.length) {
        const
          { name, when, cap, sym, shift, max, init } = whens[i],
          body = function*() {
            let keyExpr = cap;
            if (shift) {
              if (priorKey) keyExpr = `(${priorKey} | ${keyExpr})`;
              keyExpr = `${keyExpr} << ${shift}`;
            } else if (priorKey) keyExpr = `${priorKey} | ${keyExpr}`;
            scope.define(sym);
            yield `const ${sym} = ${keyExpr};`;
            if (init) yield init(cap);
            yield '';
            yield* compileWhenMatch(i + 1, sym);
          };

        yield* compileSpecComment(when, { head: `when ${name} matches: ` });

        switch (when.type) {
          case 'symbol':
          case 'expr':
            yield* amend(`for (let ${cap} = 0; ${cap} <= ${max}; ${cap}++) `, scope.block(function*() {
              scope.define(cap);

              const syms = [...freeSymbols(when, scope)];
              if (syms.length > 1) {
                throw new Error('matching more than one variable is unsupported');
              }
              const free = syms[0];
              if (!free) {
                throw new Error('no match variable');
              }
              scope.define(free);

              const matchExpr = solve(scope, free, cap, when);
              if (matchExpr === cap) {
                yield `const ${free} = ${matchExpr};`;
              } else {
                yield `const ${free} = (${max} + ${matchExpr}) % ${max};`;
                // TODO: gratuitous guard, only needed if division is involved
                yield `if (Math.floor(${free}) !== ${free}) continue;`;
              }

              yield* body();
            }));
            break;

          case 'number':
            scope.define(cap);
            yield `const ${cap} = ${when.value};`;
            yield* body();
            break;

          default:
            throw new Error(`unsupported match type ${when.type}`);
        }
      }

      else {
        /** @type {string[]} */
        const parts = [];

        const reduceParts = () => {
          while (parts.length > 1) {
            const b = parts.pop();
            const a = parts.pop();
            parts.push(`${a}\n| ${b}`);
          }
          return parts.pop() || '';
        };

        for (const { name, then, max, shift } of thens) {
          const { mode } = then;

          if (mode !== '_') {
            const { value } = then;
            const comment = compileSpecComment(
              value,
              { head: `then ${name} ${mode}${mode == '=' ? '' : '='} ` });
            const expr = compileValue(scope, value, opPrec.length);
            if (expr !== '0') {
              // TODO &max is only valid if max is some 2^N-1, otherwise should use Math.min(max, ...)
              parts.push(`${expr} & ${max} ${[...comment].join('\n')}`);
            } else yield* comment;
          }

          if (parts.length && shift) {
            parts.push(`( ${reduceParts()}\n) << ${shift}`);
          }
        }

        if (scope.has('_priorMask')) {
          parts.unshift(`_rules[${priorKey}] & _priorMask`);
        }

        if (parts.length) {
          yield* amend({
            head: `_rules[${priorKey}] = `,
            cont: '  ',
          }, reduceParts().split(/\n/));
          yield '  ;';
        }
      }
    }
  }
}

/**
 * @param {Scope} scope
 * @param {string} name
 * @param {string[]} args
 * @param {() => Iterable<string>} body
 */
function compileFunction(scope, name, args, body) {
  const argNames = args.map(arg => {
    const match = /^(\w+)\s*=.*$/.exec(arg);
    return match ? match[1] : arg;
  });

  let func = 'function';

  const lastSpace = name.lastIndexOf(' ');
  if (lastSpace >= 0) {
    // keywords like export default async (static final frozen :S)
    func = `${name.slice(lastSpace)} ${func}`;
    name = name.slice(lastSpace + 1);
  }

  if (name.startsWith('*')) func = `${func}*`, name = name.slice(1);
  if (name) scope.define(name), func = `${func} ${name}`;

  return amend(`${func}(${args.join(', ')}) `, scope.block(function*() {
    scope.define(...argNames);
    yield* body();
  }));
}

/**
 * @param {Scope} scope
 * @param {string[]} args
 * @param {() => Iterable<string>} body
 */
function compileArrowFn(scope, args, body) {
  const argNames = args.map(arg => {
    const match = /^(\w+)\s*=.*$/.exec(arg);
    return match ? match[1] : arg;
  });
  return amend(`(${args.join(', ')}) => `, scope.block(function*() {
    scope.define(...argNames);
    yield* body();
  }));
}

/** @param {SpecNode} spec */
function countNumColors(spec) {
  let numColors = 0;
  transform(spec, node => {
    switch (node.type) {
      case 'directive': {
        const { name, value } = node;
        if (name !== 'numColors') return;
        const n = parseInt(value);
        if (!isNaN(n)) numColors = Math.max(numColors, n);
        break;
      }

      case 'ant':
      case 'turns': {
        const { turns } = node;
        numColors = Math.max(numColors, turns.length);
        break;
      }
    }
  });
  return numColors;
}

/** @typedef {ReturnType<makeScope>} Scope */

function makeScope() {
  /** @type {Set<string>[]} */
  const stack = [];

  /** @type {Set<string>} */
  let scope = new Set();

  function push() {
    stack.push(scope);
    scope = new Set([...scope]);
  }

  function pop() {
    scope = stack.pop() || new Set();
  }

  return {
    /// stack
    push, pop,

    /// current scope
    [Symbol.iterator]() {
      return scope[Symbol.iterator]();
    },

    /** @param {string} name */
    has(name) {
      return scope.has(name);
    },

    /** @param {string[]} names */
    define(...names) {
      for (const name of names) {
        if (scope.has(name))
          throw new Error(`redefinition of symbol ${name}`);
        scope.add(name);
      }
    },

    /// convenience utilities

    /** @param {string} name */
    gen(name) {
      for (let i = 1; /* TODO non-infinite? */; i++) {
        const uname = name + i;
        if (!scope.has(uname)) {
          return uname;
        }
      }
    },

    /** @param {(() => Iterable<string>)} body */
    *block(body) {
      push();
      yield* block(body());
      pop();
    },

  };
}

/**
 * @param {Scope} scope
 * @param {string} cap
 * @param {string} sym
 * @param {AnyExpr} expr - TODO what even does it mean to solve a turns expression; tighten?
 * @param {number} [outerPrec]
 * @returns {string}
 */
function solve(scope, cap, sym, expr, outerPrec = 0) {
  const invOp = {
    '+': '-',
    '*': '/',
    '-': '+',
    '/': '*'
  };

  /** @type {string[]} */
  const stack = [sym, ...genStack(expr)];

  /** @returns {string} */
  const consume = (outerPrec = 0) => {
    const arg = stack.pop();
    if (!arg) return 'undefined';

    const prec = opPrec.indexOf(arg);
    if (prec >= 0) {
      const b = consume(prec);
      const a = consume(prec);
      return prec < outerPrec
        ? `(${a} ${arg} ${b})`
        : `${a} ${arg} ${b}`;
    }

    return arg;
  };

  const res = consume(outerPrec);
  if (stack.length) throw new Error('leftover solution stack');
  return res;

  /**
   * @param {AnyExpr} expr
   * @returns {Generator<string>}
   */
  function* genStack(expr) {
    switch (expr.type) {

      case 'expr':
        const { op, arg1, arg2 } = expr;

        const leftHasSym = usedSymbols(arg1).has(cap);
        const rightHasSym = usedSymbols(arg2).has(cap);
        if (leftHasSym && rightHasSym) {
          // TODO: solve each side to intermediate values
          throw new Error('matching complex expressions not supported');
        }

        switch (op) {

          case '+':
          case '*':
            // color = c [*+] 6 = 6 [*+] c
            // c = color [/-] 6
            if (leftHasSym) {
              yield* genStack(arg2);
              yield invOp[op];
              yield* genStack(arg1);
              return;
            }
            if (rightHasSym) {
              yield* genStack(arg1);
              yield invOp[op];
              yield* genStack(arg2);
              return;
            }
            break;

          case '-':
          case '/':
            if (leftHasSym) {
              // color = c [-/] 6
              // c = color [+*] 6
              yield* genStack(arg2);
              yield invOp[op];
              yield* genStack(arg1);
              return;
            }
            if (rightHasSym) {
              // color = 6 [-/] c
              // c = 6 [-/] color
              yield* genStack(arg1);
              yield op;
              yield* genStack(arg2);
              return;
            }
            break;

          case '%':
            throw new Error(`unimplemented modulo operator solving`);

          default:
            assertNever(op, 'invalid expression operator');
        }
        break;

      case 'symbol':
        if (expr.name !== cap) yield expr.name;
        return;
    }

    yield compileValue(scope, expr);
  }
}

/**
 * @param {{has: (name: string) => boolean}} scope
 * @param {AnyExpr|TurnNode} node
 * @param {number} [outerPrec]
 * @returns {string}
 */
function compileValue(scope, node, outerPrec = 0) {
  switch (node.type) {

    case 'turn':
      return `0x${node.names
        .reduce((turn, name) => turn | Turn[name], 0)
        .toString(16).padStart(2, '0')}`;

    case 'turns':
      const parts = [];
      for (const { count, turn } of node.turns) {
        const turnStr = `0x${Turn[turn]
          .toString(16).padStart(2, '0')}`;
        for (let i = 0; i < count.value; i++) {
          parts.push(turnStr);
        }
      }
      return `[${parts.join(', ')}]`;

    case 'expr':
      const prec = opPrec.indexOf(node.op);
      const val1 = compileValue(scope, node.arg1, prec);
      const val2 = compileValue(scope, node.arg2, prec);
      const exprStr = `${val1} ${node.op} ${val2}`;
      return prec < outerPrec ? `(${exprStr})` : exprStr;

    case 'member':
      const baseVal = compileValue(scope, node.value, 0);
      const itemVal = compileValue(scope, node.item, opPrec.length);
      return `${baseVal}[${`${itemVal} % ${baseVal}.length`}]`;

    case 'symbol':
    case 'identifier':
      if (!scope.has(node.name)) {
        throw new Error(`undefined ${node.type} ${JSON.stringify(node.name)}`);
      }
      return node.name;

    case 'number':
      switch (node.base) {
        case 16:
          return `0x${node.value.toString(16)}`;
        default:
          return node.value.toString(10);
      }

    default:
      assertNever(node, 'invalid value node');
      return `/* invalid node type */`; // unreachable branch, but tsc can't prove that?
  }
}

/**
 * @param {AnyExpr} expr
 * @param {{has: (name: string) => boolean}} symbols
 */
function* freeSymbols(expr, symbols) {
  for (const name of usedSymbols(expr)) {
    if (!symbols.has(name)) yield name;
  }
}

/** @param {AnyExpr} expr */
function usedSymbols(expr) {
  /** @type {Set<string>} */
  const used = new Set();
  transform(expr, matchType('symbol', ({ name }) => {
    used.add(name);
  }));
  return used;
}

/** @param {Iterable<string>} lines */
function* multiLineQuoted(lines) {
  // NOTE: there's a similar routine in glsl-loader.js
  let next = '';
  for (const line of lines) {
    if (next) {
      yield `${next} +`;
    }
    next = JSON.stringify(line + '\n');
  }
  if (next) {
    yield next;
  }
}

/** @param {Iterable<string>} lines */
function* comment(lines, mark = '// ') {
  yield* prefix(mark, lines);
}

/**
* @param {string} prefix
* @param {Iterable<string>} lines
*/
function* prefix(prefix, lines) {
  const allSpace = prefix.trim().length == 0;
  for (const line of lines) {
    yield line || !allSpace ? prefix + line : line;
  }
}

/** @param {Iterable<string>} lines */
function* endLines(lines, nl = '\n') {
  for (const line of lines) {
    yield line + nl;
  }
}

/** @typedef {object} amendments
 * @prop {string} [head] - prefix for the first line
 * @prop {string} [foot] - suffix for the last line
 * @prop {string} [cont] - prefix for all lines after the first
 * @prop {string} [zero] - filler value when lines is empty
 */

/** @param {(Iterable<string>|string)[]} parts */
function* block(...parts) {
  yield* wrap({ head: '{', cont: '  ', foot: '}' }, ...parts);
}

/**
 * @param {amendments} params
 * @param {(Iterable<string>|string)[]} parts
 */
function* wrap({ head = '', foot = '', cont = '', zero = 'undefined' }, ...parts) {
  if (head) {
    yield head;
  }
  let any = false;
  for (const line of chain(...parts)) {
    yield cont ? `${cont}${line}` : line;
    any = true;
  }
  if (!any && zero) {
    yield zero;
  }
  if (foot) {
    yield foot;
  }
}

/**
 * @param {string|amendments} params
 * @param {(Iterable<string>|string)[]} parts
 */
function* amend(params, ...parts) {
  if (typeof params == 'string') {
    params = { head: params };
  }
  const { head = '', foot = '', cont = '', zero = 'undefined' } = params;
  let last = '', any = false;
  for (const line of chain(...parts)) {
    if (!any) {
      any = true;
      last = `${head}${line}`;
    } else {
      yield last;
      last = `${cont}${line}`;
    }
  }
  if (any) {
    yield `${last}${foot}`;
  } else {
    yield `${head}${zero}${foot}`;
  }
}

/** @param {(Iterable<string>|string)[]} parts */
function* chain(...parts) {
  for (const part of parts) {
    if (typeof part == 'string') {
      yield part;
    } else {
      yield* part;
    }
  }
}

/**
 * @param {never} impossible
 * @param {string} mess
 */
function assertNever(impossible, mess) {
  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);
}

// @ts-check

/**
 * @param {string} str
 * @returns {Generator<{name: string, label?: string, then: (spec: string) => string}>}
 */
function* ruleActions(str) {
  const { value: spec } = parse$1(str);
  if (!spec) return;
  for (const { then, ...action } of actions(spec)) yield {
    ...action, then(str) {
      const { value: spec } = parse$1(str);
      if (!spec) return str;
      const newSpec = then(spec);
      return [...toSpecString(newSpec)].join('\n');
    }
  };
}

/** @param {string} spec */
function* ruleHelp(spec) {
  if (isJustAnt(spec)) yield* help.ant();
  else yield* help.turmite();
}

/** @type {{[topic: string]: () => Iterable<string>}} */
const help = {

  *ant() {
    yield '# Basic Ant Rule Format';
    yield '';
    yield '    ant(<number>?<turn>...)';
    yield '';
    yield 'Each <turn> may be one of:';
    yield '  - L=left, R=right';
    yield '  - B=back, F=forward';
    yield '  - P=port, S=starboard (these are rear-facing left/right)';
    yield '';
    yield '## Examples';
    yield '';
    yield '    ant( R L )';
    yield '    ant( 2L 13R 2L )';
    yield '    ant( 2L 13R 2L 42F )';
  },

  *turmite() {
    yield '# Turmite Rule Format';
    yield '';
    yield 'The basic turmite rule form is:';
    yield '    <when> => <then>';
    yield '';
    yield 'Where <when> has the form:';
    yield '    <state>, <color>';
    yield 'The state> and <color> are simple numeric (uint8) expressions that match against the world tile color (uint8) and internal turmite state (uint8).';
    yield 'For example, a <color> term of 2*c only matches even colors';
    yield '';
    yield 'Similarly <then> has the form:';
    yield '    <state>, <color>, <turn>';
    yield '';
    yield '- <turn> may be one of L, R, F, B, P, or S as to an ant(...) rule';
    yield '  - additonal absolute directions are supported: NW, NO, NE, SE, SO, and SW';
    yield '- <turn> may also be an indexed turns(...)[INDEX] expression';
    yield '- right hand side expressions may reference symbols matched on the left';
    yield '  - e.g. the basic ant(...) construction translates to 0, c => 0, c + 1 turns(...)[c]';
    yield '- finally, variable assignments may precede rules, to define things like a turn sequence for use in multiple places';
    yield '';
    yield '## Examples';
    yield '';
    yield 'To make a bi-modal ant that switches between LR / RL rules on every 16-th color:';
    yield '    0, c => 0, c + 1, turns(L R)[c]';
    yield '    1, c => 1, c + 1, turns(R L)[c]';
    yield '    0, 16 * c - 1 => 1, _, _';
    yield '    1, 16 * c - 1 => 0, _, _';
  },

};

/** @param {string} str */
function parse(str) {
  return bind(parse$1(str), spec => compileBuilder(spec));
}

class Turmite {

  static TestSpec = {
    MaxColor: 0xff,
    MaxState: 0xff,
    MaxTurn: 0xffff,

    MaskResultState: 0xff000000,
    MaskResultColor: 0x00ff0000,
    MaskResultTurn: 0x0000ffff,

    ColorShift: 8,
    TurnShift: 16,

    // TODO: these are non-standard currently, but should be standardized
    //       starting here to not hardcode below in dump()

    ColorByteWidth: 1,
    StateByteWidth: 1,
    TurnByteWidth: 2,

    ResultByteWidth: 4,
    ResultStateShift: 24,
    ResultColorShift: 16,
    ResultTurnShift: 0,

    KeyByteWidth: 2,
    KeyStateMask: 0xff00,
    KeyColorMask: 0x00ff,
    KeyColorShift: 0,
    KeyStateShift: 8,
  };

  /**
   * @param {string|Builder} arg
   * @param {RuleConstants} [spec]
   * @param {Turmite} [ent]
   * @returns {rezult.Result<Turmite>}
   */
  static from(arg, spec = Turmite.TestSpec, ent = new Turmite()) {
    if (typeof arg === 'string') {
      const { value, err: parseErr } = parse(arg);
      if (parseErr) {
        return error(parseErr);
      }
      arg = value;
    }

    ent.reset();
    ent.rules.fill(0);

    const { value: built, err: buildErr } = arg(ent.rules, spec);
    if (buildErr) {
      return error(buildErr);
    }

    const { numColors, numStates, specString } = built;
    ent.numColors = numColors;
    ent.numStates = numStates;
    ent.specString = specString;

    return just(ent);
  }

  constructor() {
    this.numStates = 0;
    this.numColors = 0;
    this.specString = '<null turmite>';
    this.rules = new Uint32Array(256 * 256);
    this.dir = 0;
    this.pos = new OddQOffset(0, 0);
    this.state = 0;
    this.index = 0;
  }

  reset() {
    this.dir = 0;
    this.pos.scale(0);
    this.state = 0;
  }

  toString() {
    return this.specString || '<UNKNOWN turmite>';
  }

  /** @typedef {object} World
   * @prop {(index: number, fn: (dir: number, state: number, datum: number) => {dir: number, state: number, datum: number}) => void} updateEnt
   */

  /** @param {World} world */
  step(world) {
    const { rules, index } = this;
    world.updateEnt(index, (dir, state, datum) => {

      // TODO get XXX constants from a spec: RuleConstants arg
      const color = datum & 0x00ff; // XXX World.MaskColor
      const flags = datum & 0xff00; // XXX World.MaskFlags
      const ruleIndex = state << 8 | color; // XXX World.ColorShift
      const rule = rules[ruleIndex];
      const turn = rule & 0x0000ffff; // XXX World.MaskResultTurn
      const write = (rule & 0x00ff0000) >> 16; // XXX &World.MaskResultColor >>World.TurnShift
      state = (rule & 0xff000000) >> 24; // XXX World.MaskResultState >>(World.TurnShift+World.ColorShift)
      datum = flags | write | 0x0100; // XXX World.FlagVisited

      const newDirs = [...turnDirs(turn, dir)];
      switch (newDirs.length) {
        case 0:
          break;
        case 1:
          dir = newDirs[0];
          break;
        default:
          throw new Error('turmite forking unimplemented');
      }

      return { dir, state, datum };
    });
  }
}

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create$4() {
  var out = new ARRAY_TYPE(9);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create$3() {
  var out = new ARRAY_TYPE(3);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$3();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
})();

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create$2() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize$1(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$2();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
})();

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create$1() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = normalize$1;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

(function () {
  var tmpvec3 = create$3();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot$1 = dot(a, b);

    if (dot$1 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
      normalize$2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot$1 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot$1;
      return normalize(out, out);
    }
  };
})();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

(function () {
  var temp1 = create$1();
  var temp2 = create$1();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

(function () {
  var matr = create$4();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
})();

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new ARRAY_TYPE(2);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
})();

// @ts-check

// TODO:
// - detect uniform and attr names by static analysis
// - pursue tighter integration with GLSLShader

class GLProgram {

  /**
   * @param {WebGLRenderingContext} gl
   * @param {WebGLProgram} prog
   * @param {Iterable<string>} uniformNames
   * @param {Iterable<string>} attrNames
   */
  constructor(gl, prog, uniformNames, attrNames) {

    /** @type {{[name: string]: WebGLUniformLocation}} */
    const uniform = {};

    /** @type {{[name: string]: number}} */
    const attr = {};

    for (const name of uniformNames) {
      const loc = gl.getUniformLocation(prog, name);
      if (!loc) {
        throw new Error(`unable to find uniform ${name}`);
      }
      uniform[name] = loc;
    }

    for (const name of attrNames) {
      const loc = gl.getAttribLocation(prog, name);
      if (loc < 0) {
        throw new Error(`unable to find attrib ${name}`);
      }
      attr[name] = loc;
    }

    this.gl = gl;
    this.prog = prog;
    this.uniform = uniform;
    this.attr = attr;
  }

  use() {
    const { gl, prog } = this;
    gl.useProgram(prog);
  }

  enable() {
    const { gl, attr } = this;
    this.use();
    for (const attrLoc of Object.values(attr)) {
      gl.enableVertexAttribArray(attrLoc);
    }
  }

  disable() {
    const { gl, attr } = this;
    for (const attrLoc of Object.values(attr)) {
      gl.disableVertexAttribArray(attrLoc);
    }
  }

}

// @ts-check

/** @typedef {import("./colorgen.js").ColorTuple} ColorTuple */

class GLPalette {

  /**
   * @param {WebGLRenderingContext} gl
   * @param {object} options
   * @param {number} options.unit
   * @param {"rgb"|"srgb"} [options.format]
   * @param {Iterable<ColorTuple>} [options.colors]
   */
  constructor(gl, { unit, format: formatArg = 'rgb', colors }) {
    const format = function() {
      if (formatArg == 'srgb') {
        const extSRGB = gl.getExtension('EXT_sRGB');
        if (extSRGB) {
          return extSRGB.SRGB_EXT;
        } else {
          console.warn('sRGB Gl extension not available, falling back to RGB colorspace');
        }
      }
      return gl.RGB;
    }();
    const data = new Uint8Array(256 * 3);
    const tex = gl.createTexture();

    this.gl = gl;
    this.unit = unit;
    this.format = format;
    this.data = data;
    this.tex = tex;

    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    if (colors) {
      this.setColorsRGB(colors);
    }
  }

  /** @param {WebGLUniformLocation} uSampler */
  use(uSampler) {
    const { gl, unit } = this;
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.uniform1i(uSampler, unit);
  }

  /** @param {Iterable<ColorTuple>} [rgbColors] */
  setColorsRGB(rgbColors = []) {
    const { gl, unit, tex, format, data } = this;
    data.fill(0);
    setNumbers$1(data, function*() {
      for (const [r, g, b] of rgbColors) {
        yield Math.round(255 * r);
        yield Math.round(255 * g);
        yield Math.round(255 * b);
      }
    }());

    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(
      gl.TEXTURE_2D, 0, format,
      256, 1, 0,
      format, gl.UNSIGNED_BYTE, data);
  }

}

// TODO merge with view_gl.js

/**
 * @param {{readonly length: number, [index: number]: number}|null} ar
 * @param {Iterable<number>} ns
 */
function setNumbers$1(ar, ns) {
  const length = ar?.length;
  if (!length) {
    return;
  }
  let i = 0;
  for (const n of ns) {
    ar[i] = n;
    if (++i >= length) { return; }
  }
}

// @ts-check

/** RangeList is a stride-2 array of numbers.
 * Each pair of numbers is a [begin, end] inclusive range interval.
 * The ranges are mutually disjoint and kept in ascending order.
 *
 * @typedef {number[]} RangeList
 */

/**
 * @param {RangeList} rl
 * @param {number} begin
 * @param {number} end
 */
function add(rl, begin, end) {
  if (end < begin) {
    throw new Error("invalid range");
  }

  // won't add degenerate ranges
  if (end === begin) {
    return;
  }

  // find begin
  // TODO: use binary search
  let found = false;
  let i = 0;
  for (; i < rl.length; i += 2) {
    if (begin <= rl[i] - 1) {
      // ... @i:[begin <= a-1 < b] ...
      rl[i] = begin;
      found = true;
      break;
    }
    if (begin <= rl[i + 1] + 1) {
      // ... @i:[a < begin <= b+1] ...
      found = true;
      break;
    }
  }
  // ... < [end < begin]
  if (!found) {
    rl.push(begin, end);
    return;
  }

  // seek end
  let j = i;
  found = false;
  for (; j < rl.length; j += 2) {
    if (end < rl[j] - 1) {
      // ... @i:[a <= begin <= b] ... @j:[end < c-1 < d] ...
      if (j === i) {
        throw new Error("degenerate range detected"); // should not be possible
      }
      found = true;
      break;
    }
    if (end <= rl[j + 1] + 1) {
      // ... @i:[a <= begin <= b] ... @j:[c < end <= d+1] ...
      if (j === i) {
        // ... @i:[a <= begin < end <= b] ...
        return;
      }
      end = rl[j + 1] + (end === rl[j + 1] + 1 ? 1 : 0);
      j += 2;
      found = true;
      break;
    }
  }
  // ... @i:[a-1 <= begin < b] ...coalesced... < end
  if (!found) {
    rl[i + 1] = end;
    rl.length = i + 2;
    return;
  }

  // coalesce
  // ... @i:[a-1 <= begin < end] ...coalesced... @j ...tail...
  rl[i + 1] = end;
  i += 2;
  if (i == j) {
    return;
  }
  // TODO: rl.copyWithin
  while (j < rl.length) {
    rl[i++] = rl[j++];
    rl[i++] = rl[j++];
  }
  rl.length = i;
  return;
}

/** @param {RangeList} rl */
function* each(rl) {
  for (let i = 0; i < rl.length;) {
    const begin = /** @type {number} */ (rl[i++]);
    const end = /** @type {number} */ (rl[i++]);
    yield { begin, end };
  }
}

// @ts-check
/** @typedef {import('./rangelist.js').RangeList} RangeList */

/**
 * @typedef {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} someTypedArray
 */

// TODO would be nice to generalize this beyond the fixed verts/colors attributes

class TileGLBuffer {
  /**
   * @param {number} id
   * @param {GLBuffer} elements
   * @param {LazyGLBuffer} verts
   * @param {LazyGLBuffer} colors
   */
  constructor(id, elements, verts, colors) {
    this.id = id;
    /** @type {BufferIndex} */
    this.index = [];
    /** @type {Map<number, [begin: number, end: number]>} */
    this.tileRanges = new Map();
    this.usedElements = 0;
    this.elements = elements;
    this.verts = verts;
    this.colors = colors;
  }

  get capacity() {
    return Math.min(
      this.verts.capacity,
      this.colors.capacity,
    );
  }

  reset() {
    this.index.length = 0;
    this.tileRanges.clear();
    this.usedElements = 0;
  }

  /** @param {number} offset */
  addElement(offset) {
    this.elements.data[this.usedElements++] = offset;
  }

  flush() {
    this.verts.flush();
    this.colors.flush();
    this.shipElements();
  }

  shipElements() {
    this.elements.ship(0, this.usedElements);
  }

  /**
   * @param {number} id
   * @param {number} length
   */
  addTile(id, length) {
    const { index, tileRanges, capacity } = this;
    const [i, j/*,  w */] = placeTile(index, capacity, length);
    if (i < 0) {
      return -1;
    }

    if (i < index.length) {
      scavengeTombstone(index, i, length);
      index[i] = id;
    } else {
      index.push(id, length);
    }
    tileRanges.set(id, [j, j + length]);
    return j;
  }

  /** @param {number} id */
  removeTile(id) {
    const { index, tileRanges } = this;
    tileRanges.delete(id);
    for (let i = 0; i < index.length; i += 2) {
      if (index[i] === id) {
        // set tombstone...
        index[i] = 0;
        // ...prune trailing tombstones
        while (index[index.length - 2] === 0) {
          index.length -= 2;
        }
        break;
      }
    }
  }

  /** @param {number} id */
  tileOffset(id) {
    const range = this.tileRanges.get(id);
    return range ? range[0] : -1;
  }
}

class GLBuffer {
  /**
   * @param {WebGLRenderingContext} gl
   * @param {number} target
   * @param {number} width
   * @param {someTypedArray} data
   */
  constructor(gl, target, width, data) {
    this.gl = gl;
    this.target = target;
    this.width = width;
    this.data = data;
    this.buf = this.gl.createBuffer();
    this.gl.bindBuffer(this.target, this.buf);
    this.gl.bufferData(this.target, this.data, gl.STATIC_DRAW);
  }

  get capacity() {
    return this.data.length / this.width;
  }

  /**
   * @param {number} lo
   * @param {number} hi
   */
  ship(lo, hi) {
    const { gl, target, buf, data, width } = this;
    const begin = lo * width, end = hi * width;
    gl.bindBuffer(target, buf);
    gl.bufferSubData(target,
      begin * data.BYTES_PER_ELEMENT,
      data.subarray(begin, end));
  }
}

class LazyGLBuffer extends GLBuffer {
  /**
   * @param {WebGLRenderingContext} gl
   * @param {number} target
   * @param {number} width
   * @param {someTypedArray} data
   */
  constructor(gl, target, width, data) {
    super(gl, target, width, data);
    /** @type {RangeList} */
    this.inval = [];
  }

  /**
   * @param {number} lo
   * @param {number} hi
   */
  invalidate(lo, hi) {
    add(this.inval, lo, hi);
  }

  flush() {
    const { gl, inval, target, buf, data, width } = this;
    if (!inval.length) {
      return;
    }
    gl.bindBuffer(target, buf);
    for (const { begin, end } of each(inval)) {
      const i = begin * width;
      const j = end * width;
      gl.bufferSubData(target, data.BYTES_PER_ELEMENT * i, data.subarray(i, j));
    }
    inval.length = 0;
  }
}

// TODO: unexport placeTile and scavengeTombstone once we can expand the test horizon past them

/** BufferIndex is a stride-2 array of [tileId, length] pairs, used to allot gl
 * buffer space to tiles of varying sizes.
 *
 * @typedef {number[]} BufferIndex
 */

/** placeTile returns the best place for a tile of length elements within the
 * an indexed buffer. Attempts to re-use any tombstoned prior allotments before
 * alloting at the end of buffer, but only if doing so would waste less buffer
 * space.
 *
 * @param {BufferIndex} index
 * @param {number} capacity - of the underlying buffer
 * @param {number} length - of the tile to place
 * @returns {[i: number, offset: number, waste: number]} - i in index, offset
 * in the underlying buffer, waste is a minmized fragmentation metric
 */
function placeTile(index, capacity, length) {
  let bestIndex = -1, bestOffset = -1, best = -1;
  let offset = 0;

  let freeIndex = -1, freeOffset = -1, freeLength = 0;
  for (let i = 0; i < index.length; i += 2) {
    const tileId = index[i];
    const tileLength = index[i + 1];
    if (!tileId) {
      if (freeLength === 0) {
        freeIndex = i;
        freeOffset = offset;
      }
      freeLength += tileLength;
      if (length <= freeLength) {
        const waste = freeLength - length;
        if (best < 0 || waste < best) {
          bestIndex = freeIndex;
          bestOffset = freeOffset;
          best = waste;
        }
      }
    } else if (freeLength !== 0) {
      freeIndex = -1;
      freeOffset = -1;
      freeLength = 0;
    }
    offset += tileLength;
  }

  const free = capacity - offset;
  if (length <= free) {
    const waste = free - length;
    if (best < 0 || waste < best) {
      bestIndex = index.length;
      bestOffset = offset;
      best = waste;
    }
  }

  return [bestIndex, bestOffset, best];
}

/** scavenge space from a prior allotment that has been tombstoned.
 * Any remnant space is placed in a new sucessor tombstone for future allotment.
 *
 * @param {BufferIndex} index
 * @param {number} i
 * @param {number} length
 */
function scavengeTombstone(index, i, length) {
  if (index[i]) {
    throw new Error('not a tombstone');
  }

  let tileLength = index[i + 1];
  index[i + 1] = length;

  // coalesce range; we assume that we've been told an index of a usable set
  // of tombstones, and so don't range check here
  let j = i + 2, k;
  let spare = 0;
  for (; tileLength < length; j += 2) {
    tileLength += index[j + 1];
    spare += 2;
  }

  // truncate (finish any coalesce)
  if (spare > 0) {
    k = i + 2;
    while (j < index.length) {
      index[k++] = index[j++];
    }
    j = i + 2;
  }

  // distribute leftover
  if (length < tileLength) {
    const remain = tileLength - length;
    if (!index[j]) {
      // easy, give it to the next tombstone
      index[j + 1] += remain;
    } else {
      // split into new tombstone
      let n = index.length - j;
      if (spare >= 2) {
        spare -= 2;
      } else {
        index.push(0, 0);
      }
      k = index.length - 1;
      for (; n-- > 0; k--) index[k] = index[k - 2];
      index[j] = 0;
      index[j + 1] = remain;
    }
  }

  index.length -= spare;
}

// @ts-check

/**
 * @typedef {object} oddQPotent
 * @prop {(oqo: OddQOffset) => void} toOddQOffsetInto
 */

/** @type {OddQHexTile[]} */
const pool$1 = [];

class OddQHexTile {
  static NextId = 1;

  static alloc() {
    if (pool$1.length > 0) {
      const tile = pool$1.shift();
      if (tile !== undefined) {
        return tile;
      }
    }
    return new OddQHexTile();
  }

  /** @param {OddQHexTile} tile */
  static free(tile) {
    pool$1.push(tile);
  }

  free() {
    OddQHexTile.free(this);
  }


  constructor() {
    this.id = OddQHexTile.NextId++;
    this.origin = new OddQOffset();
    this.oqo = new OddQOffset();
    this.width = 0;
    this.height = 0;
    /** @type {null|Uint16Array} */
    this.data = null;
    this.dirty = false;
  }

  /**
   * @param {oddQPotent} origin
   * @param {number} width
   * @param {number} height
   */
  init(origin, width, height) {
    const need = width * height;
    const needBytes = need * Uint16Array.BYTES_PER_ELEMENT;
    origin.toOddQOffsetInto(this.origin);
    this.width = width;
    this.height = height;
    if (this.data === null || this.data.buffer.byteLength < needBytes) {
      this.data = new Uint16Array(need);
    } else {
      if (this.data.length !== need) {
        this.data = new Uint16Array(this.data.buffer, 0, need);
      }
      this.data.fill(0);
    }
    this.dirty = false;
    return this;
  }

  boundingBox() {
    const { origin, width, height } = this;
    return new OddQBox(origin, origin.copy().addTo(width, height));
  }

  centerPoint() {
    const { origin, width, height } = this;
    return new OddQOffset(
      origin.q + Math.floor(width / 2),
      origin.r + Math.floor(height / 2)
    );
  }

  /**
   * @param {oddQPotent} point
   */
  pointToIndex(point) {
    const { oqo, origin, width } = this;
    point.toOddQOffsetInto(oqo);
    return (oqo.r - origin.r) * width +
      (oqo.q - origin.q);
  }

  /**
   * @param {oddQPotent} point
   * @param {(datum: number, point: oddQPotent) => number} func
   * @returns {number}
   */
  update(point, func) {
    const { data } = this;
    if (!data) {
      return NaN;
    }
    const i = this.pointToIndex(point);
    const datum = func(orNaN(data[i]), point);
    data[i] = datum;
    return datum;
  }

  /**
   * @param {oddQPotent} point
   * @returns {number}
   */
  get(point) {
    const { data } = this;
    return data ? orNaN(data[this.pointToIndex(point)]) : NaN;
  }

  /**
   * @param {oddQPotent} point
   * @param {number} datum
   * @returns {number}
   */
  set(point, datum) {
    const { data } = this;
    if (data) {
      data[this.pointToIndex(point)] = datum;
    }
    return datum;
  }

  /** @param {(tile: OddQHexTile) => void} each */
  eachTile(each) {
    each(this);
  }

  /** @param {(point: OddQOffset, datum: number) => void} each */
  eachDataPoint(each) {
    const {
      oqo: point,
      origin: { q: loQ, r: loR },
      width, height, data,
    } = this;
    if (data) {
      const hiQ = loQ + width;
      const hiR = loR + height;
      let i = 0;
      for (point.r = loR; point.r < hiR; point.r++) {
        for (point.q = loQ; point.q < hiQ; point.q++, i++) {
          each(point, orNaN(data[i]));
        }
      }
    }
  }

  /**
   * @param {OddQOffset} tl
   * @param {OddQOffset} br
   */
  expandBoxTo(tl, br) {
    const {
      origin: { q: tlq, r: tlr },
      width, height,
    } = this;
    const brq = tlq + width;
    const brr = tlr + height;
    if (isNaN(tl.q) || isNaN(tl.r) || isNaN(br.q) || isNaN(br.r)) {
      tl.q = tlq;
      tl.r = tlr;
      br.q = brq;
      br.r = brr;
    } else {
      if (tlq < tl.q) tl.q = tlq;
      if (tlr < tl.r) tl.r = tlr;
      if (brq > br.q) br.q = brq;
      if (brr > br.r) br.r = brr;
    }
  }

  /**
   * @param {OddQOffset} tl
   * @param {OddQOffset} br
   * @param {number} mask
   */
  expandBoxToIf(tl, br, mask) {
    const { data, width, origin: { q: oq } } = this;
    let { origin: { q, r } } = this, i = 0;
    if (!data) {
      return;
    }

    // if any part of the box isn't defined, initialize from the first masked
    // point
    if (isNaN(tl.q) || isNaN(tl.r) || isNaN(br.q) || isNaN(br.r)) {
      while (i < data.length) {
        if (orNaN(data[i]) & mask) {
          tl.q = q;
          br.q = q;
          tl.r = r;
          br.r = r;
          break;
        }
        i++;
        q++;
        if (q >= oq + width) {
          q = oq;
          r++;
        }
      }
    }

    // now just expand to each masked point
    while (i < data.length) {
      if (orNaN(data[i]) & mask) {
        if (q < tl.q) {
          tl.q = q;
        } else if (q >= br.q) {
          br.q = q;
        }
        if (r < tl.r) {
          tl.r = r;
        } else if (r >= br.r) {
          br.r = r;
        }
      }
      i++;
      q++;
      if (q >= oq + width) {
        q = oq;
        r++;
      }
    }
  }

  *dump() {
    const {
      origin,
      data,
      width,
    } = this;
    yield 'Tile @' + origin.toString();
    if (data) {
      const row = [];
      for (let i = 0; i < data.length; i++) {
        if (i && i % width === 0) {
          yield row.join(' ');
          row.splice(0);
        }
        row.push(orNaN(data[i]).toString());
      }
      yield row.join(' ');
    }
  }

}

/** @param {number|undefined} un */
function orNaN(un) {
  return un === undefined ? NaN : un;
}

// @ts-check

/**
 * @typedef {object} oddQPotent
 * @prop {(oqo: OddQOffset) => void} toOddQOffsetInto
 */

/** @typedef {(tile: OddQHexTile) => void} tileCallback */
/** @typedef {OddQHexTile|HexTileTreeNode} tileOrNode */
/** @typedef {tileOrNode|null} tileOrNodeOrNull */

class HexTileTree {
  constructor() {
    this.minTileArea = 4;
    this.maxTileArea = 64;
    this.oqo = new OddQOffset(0, 0);

    /** @type {null|HexTileTreeNode} */
    this.root = null;

    // TODO Map
    /** @type {Map<number, OddQHexTile>} */
    this.tiles = new Map();

    /** @type {OddQHexTile[]} */
    this.dirtyTiles = [];

    /** @type {tileCallback} */
    this.tileRemoved = noop;

    /** @type {tileCallback} */
    this.tileAdded = noop;
  }

  /**
   * @param {number} id
   * @returns {null|OddQHexTile}
   */
  getTile(id) {
    return this.tiles.get(id) || null;
  }

  /** @param {OddQHexTile} tile */
  addTile(tile) {
    this.tiles.set(tile.id, tile);
    tile.dirty = true;
    this.dirtyTiles.push(tile);
    this.tileAdded(tile);
  }

  /** @param {OddQHexTile[]} tiles */
  removeTiles(...tiles) {
    const { dirtyTiles } = this;
    if (tiles.some(tile => tile.dirty)) {
      const goneIDs = new Set(tiles.map(({ id }) => id));
      let j = 0;
      for (let k = 0; k < dirtyTiles.length; ++k) {
        const dirtyTile = dirtyTiles[k];
        if (dirtyTile) {
          const { id } = dirtyTile;
          if (!goneIDs.has(id)) {
            if (j != k) {
              dirtyTiles[j] = dirtyTile;
            }
            ++j;
          }
        }
      }
      dirtyTiles.length = j;
    }

    for (const tile of tiles) {
      this.tileRemoved(tile);
    }

    for (const { id } of tiles) {
      this.tiles.delete(id);
    }

    for (const tile of tiles) {
      tile.free();
    }
  }

  reset() {
    this.dirtyTiles.length = 0;
    this.tiles.clear();
    this.root = null;
  }

  dump() {
    const { root } = this;
    return root ? [...root.dump()].join('\n') : '';
  }

  boundingBox() {
    const { root } = this;
    return root ? root.boundingBox() : null;
  }

  /** @param {(tile: OddQHexTile) => void} each */
  eachTile(each) {
    const { root } = this;
    if (root !== null) {
      root.eachTile(each);
    }
  }

  /** @param {(point: OddQOffset, datum: number) => void} each */
  eachDataPoint(each) {
    const { root } = this;
    if (root !== null) {
      root.eachDataPoint(each, null);
    }
  }

  centerPoint() {
    const { root } = this;
    return root ? root.centerPoint() : null;
  }

  /** @returns {HexTileTreeNode} */
  _ensureRoot() {
    let { root } = this;
    if (!root) {
      const s = Math.ceil(Math.sqrt(this.minTileArea)) * 2;
      root = HexTileTreeNode.alloc ? HexTileTreeNode.alloc() : new HexTileTreeNode();
      root.init(this, null, s);
    }
    return root;
  }

  /** @param {oddQPotent} point */
  _ensureTile(point) {
    const { oqo } = this;
    let root = this._ensureRoot();
    point.toOddQOffsetInto(oqo);
    while (!root.box.contains(oqo)) {
      const expanded = root.expand();
      if (!expanded) {
        return null;
      }
      root = expanded;
    }
    if (root !== this.root) {
      this.root = root;
    }
    root.oqo.copyFrom(oqo);
    return root._getOrCreateTile(); // FIXME implicit oqo pass from copy in last line
    // FIXME implicit side return in this.oqo
  }

  /**
   * @param {oddQPotent} point
   * @param {(datum: number, point: oddQPotent) => number} func
   * @returns {number}
   */
  update(point, func) {
    const { oqo, dirtyTiles } = this;
    const tile = this._ensureTile(point); // NOTE: implicit return into shared oqo
    if (!tile) { return NaN }
    if (tile instanceof OddQHexTile && !tile.dirty) {
      tile.dirty = true;
      dirtyTiles.push(tile);
    }
    return tile.update(oqo, func);
  }

  /**
   * @param {oddQPotent} point
   * @returns {number}
   */
  get(point) {
    return this._ensureRoot().get(point);
  }

  /**
   * @param {oddQPotent} point
   * @param {number} datum
   * @returns {number}
   */
  set(point, datum) {
    const { oqo, dirtyTiles } = this;
    const tile = this._ensureTile(point); // NOTE: implicit return into shared oqo
    if (!tile) { return NaN }
    if (tile instanceof OddQHexTile && !tile.dirty) {
      tile.dirty = true;
      dirtyTiles.push(tile);
    }
    return tile.set(oqo, datum);
  }

}

const zoomPerm = [
  3, // 0 --> 3
  2, // 1 --> 2
  1, // 2 --> 1
  0  // 3 --> 0
];

const tileOriginOffset = [
  new OddQOffset(0, 0),
  new OddQOffset(1, 0),
  new OddQOffset(0, 1),
  new OddQOffset(1, 1)
];

const nodeOriginOffset = [
  new OddQOffset(-1, -1),
  new OddQOffset(1, -1),
  new OddQOffset(-1, 1),
  new OddQOffset(1, 1)
];

/** TODO this exists as a dubious testing surface, refactor it away someday
 *
 * @param {HexTileTree} tree
 * @param {OddQHexTile|HexTileTreeNode|null} tile
 * @param {number} i
 */
function growTile(tree, tile, i) {
  if (!tile) { return null }

  const originOffset = tile instanceof OddQHexTile ? tileOriginOffset[i] : nodeOriginOffset[i];
  const zoom = zoomPerm[i];
  if (originOffset == undefined || zoom == undefined) { return null }

  const tileSize = tile instanceof OddQHexTile ? tile.width : tile.tileSize;
  const growthOrigin = tile.oqo
    .copyFrom(originOffset)
    .scale(tileSize)
    .add(tile.origin);
  const growthSize = 2 * (tile instanceof OddQHexTile ? tile.width : tile.size);
  const tileNode = HexTileTreeNode.alloc ? HexTileTreeNode.alloc() : new HexTileTreeNode();
  tileNode.init(tree, growthOrigin, growthSize);
  tileNode._setTile(zoom, tile);
  return tileNode;
}

/** @type {HexTileTreeNode[]} */
const pool = [];

class HexTileTreeNode {
  static alloc() {
    if (pool.length > 0) {
      const node = pool.shift();
      if (node !== undefined) {
        return node;
      }
    }
    return new HexTileTreeNode();
  }

  /** @param {HexTileTreeNode} node */
  static free(node) {
    node.reset();
    pool.push(node);
  }

  free() {
    HexTileTreeNode.free(this);
  }

  constructor() {
    /** @type {HexTileTree|null} */
    this.tree = null;

    this.origin = new OddQOffset(0, 0);
    this.oqo = new OddQOffset(0, 0);
    this.box = new OddQBox();
    this.size = 0;
    this.tileSize = 0;
    this.concrete = 0;

    /** @type {[tileOrNodeOrNull, tileOrNodeOrNull, tileOrNodeOrNull, tileOrNodeOrNull]} */
    this.tiles = [null, null, null, null];

    /** @type {tileCallback|null} */
    this._replaceme = null;
  }

  /**
   * @param {HexTileTree} tree
   * @param {oddQPotent?} origin
   * @param {number} size
   * @param {tileCallback} [replaceme]
   */
  init(tree, origin, size, replaceme) {
    this.tree = tree;
    this.concrete = 0;
    this._replaceme = replaceme || null;
    if (origin !== null) {
      origin.toOddQOffsetInto(this.origin);
    } else {
      this.origin.q = this.origin.r = 0;
    }
    this._setSize(size);
    return this;
  }

  reset() {
    const { tiles } = this;
    const [a, b, c, d] = tiles;
    if (a) {
      a.free();
      tiles[0] = null;
    }
    if (b) {
      b.free();
      tiles[1] = null;
    }
    if (c) {
      c.free();
      tiles[2] = null;
    }
    if (d) {
      d.free();
      tiles[3] = null;
    }
  }

  /** @param {number} size */
  _setSize(size) {
    const { origin: { q, r }, box: { topLeft, bottomRight } } = this;
    const tileSize = Math.floor(size / 2);
    this.size = size;
    this.tileSize = tileSize;
    topLeft.q = q - tileSize;
    topLeft.r = r - tileSize;
    bottomRight.q = q + tileSize;
    bottomRight.r = r + tileSize;
  }

  /** @returns {Generator<string>} */
  *dump() {
    const { origin, box, tiles } = this;
    yield `TreeNode @${origin}`;
    yield `  box: ${box}`;
    for (let i = 0; i < tiles.length; i++) {
      const tile = tiles[i];
      const [first, ...tileparts] = tile ? [...tile.dump()] : ['null'];
      yield `[${i}]: ${first}`;
      for (const tilepart of tileparts) {
        yield `     ${tilepart}`;
      }
    }
  }

  /** @param {(tile: OddQHexTile) => void} each */
  eachTile(each) {
    const tile = this._mayCompact();
    if (tile) {
      tile.eachTile(each);
      return;
    }

    const { tiles: [a, b, c, d] } = this;
    if (a) a.eachTile(each);
    if (b) b.eachTile(each);
    if (c) c.eachTile(each);
    if (d) d.eachTile(each);
  }

  expand() {
    const { tree, tiles } = this;
    if (!tree) { return null }
    this._setSize(this.size * 2);
    for (let i = 0; i < tiles.length; i++) {
      const tile = tiles[i];
      const tileNode = growTile(tree, tile, i);
      if (tileNode) {
        this._setTile(i, tileNode);
      }
    }
    return this;
  }

  boundingBox() {
    return this.box;
  }

  /**
   * @param {(point: OddQOffset, datum: number) => void} each
   * @param {null|number} [fill]
   */
  eachDataPoint(each, fill = null) {
    const tile = this._mayCompact();
    if (tile) {
      tile.eachDataPoint(each);
      return;
    }

    const {
      tileSize,
      origin: { q: oq, r: or },
      oqo: point,
      tiles: [a, b, c, d],
    } = this;

    if (a) a.eachDataPoint(each, fill); else doFill(0);
    if (b) b.eachDataPoint(each, fill); else doFill(1);
    if (c) c.eachDataPoint(each, fill); else doFill(2);
    if (d) d.eachDataPoint(each, fill); else doFill(3);

    /** @param {number} i */
    function doFill(i) {
      if (typeof fill !== 'number') {
        return;
      }
      const tileCol = i & 1;
      const tileRow = i >> 1;
      const loQ = oq + (tileCol ? 0 : -tileSize);
      const loR = or + (tileRow ? 0 : -tileSize);
      const hiQ = loQ + tileSize;
      const hiR = loR + tileSize;
      point.q = loQ, point.r = loR;
      for (point.r = loR; point.r < hiR; point.r++) {
        for (point.q = loQ; point.q < hiQ; point.q++) {
          each(point, fill);
        }
      }
    }
  }

  _mayCompact() {
    if (!this.tree || !this._replaceme) {
      return null;
    }

    if (this.concrete != 4) {
      return null;
    }

    const tile = this.compact();
    if (tile === null) {
      // setting concrete to 5 caches the negative result of "won't compact" so
      // that we don't try again in the future
      this.concrete = 5;
      return null;
    }

    /** @type {OddQHexTile[]} */
    const subTiles = [];
    for (const tile of this.tiles) {
      if (tile && tile instanceof OddQHexTile) {
        subTiles.push(tile);
      }
    }

    this._replaceme(tile);

    this.tree.removeTiles(...subTiles);

    this.tree.addTile(tile);
    return tile;
  }

  compact() {
    if (!this.tree) { return null }
    const { size, tree: { maxTileArea } } = this;
    if (size * size > maxTileArea) {
      return null;
    }

    // TODO should be able to do region copies from each subTile into newTile,
    // rather than all the overhead of each => set

    const { box: { topLeft }, tiles } = this;
    const newTile = OddQHexTile.alloc ? OddQHexTile.alloc() : new OddQHexTile();
    newTile.init(topLeft, size, size);
    for (const subTile of tiles) {
      if (subTile) subTile.eachDataPoint(
        (point, datum) => newTile.set(point, datum),
        null);
    }
    return newTile;
  }

  centerPoint() {
    return this.origin;
  }

  /**
   * @param {oddQPotent} point
   * @param {(datum: number, point: oddQPotent) => number} func
   * @returns {number}
   */
  update(point, func) {
    const { oqo, box, tree } = this;
    if (!tree) { return NaN }
    const { dirtyTiles } = tree;
    point.toOddQOffsetInto(oqo);
    if (!box.contains(oqo)) {
      throw new Error('update out of bounds');
    }
    const tile = this._mayCompact() || this._getOrCreateTile(); // FIXME implicit oqo pass
    if (!tile) { return NaN }
    if (tile instanceof OddQHexTile && !tile.dirty) {
      tile.dirty = true;
      dirtyTiles.push(tile);
    }
    return tile.update(oqo, func);
  }

  /**
   * @param {oddQPotent} point
   * @returns {number}
   */
  get(point) {
    const { oqo, box } = this;
    point.toOddQOffsetInto(oqo);
    if (!box.contains(oqo)) {
      return NaN;
    }
    const tile = this._getTile(); // FIXME implicit oqo pass
    if (tile) {
      return tile.get(oqo);
    }
    return 0;
  }

  /**
   * @param {oddQPotent} point
   * @param {number} datum
   * @returns {number}
   */
  set(point, datum) {
    const { oqo, box, tree } = this;
    if (!tree) { return NaN }
    const { dirtyTiles } = tree;
    point.toOddQOffsetInto(oqo);
    if (!box.contains(oqo)) {
      throw new Error('set out of bounds');
    }

    const tile = this._mayCompact() || this._getOrCreateTile(); // FIXME implicit oqo pass
    if (!tile) { return NaN }
    if (tile instanceof OddQHexTile && !tile.dirty) {
      tile.dirty = true;
      dirtyTiles.push(tile);
    }
    return tile.set(this.oqo, datum);
  }

  _index() {
    // FIXME implicit oqo arg
    const { oqo: { q, r }, origin: { q: oq, r: or } } = this;

    // TODO: bit hack: negated sign-bit of subtraction would make this branchless
    const tileCol = q < oq ? 0 : 1;
    const tileRow = r < or ? 0 : 1;
    return tileRow * 2 + tileCol;
  }

  _getTile() {
    const i = this._index(); // FIXME implicit operation on oqo passed thru
    return this.tiles[i];
  }

  _getOrCreateTile() {
    const { tree, tiles, tileSize } = this;
    if (!tree) { return null }
    const i = this._index(); // FIXME implicit operation on oqo passed thru
    const tile = tiles[i];
    if (tile) {
      return tile;
    }
    if (tileSize * tileSize <= tree.minTileArea) {
      return this._allocTile(i);
    }
    return this._allocNode(i);
  }

  /** @param {number} i */
  _allocTile(i) {

    // FIXME implicit oqo arg
    const { tree, oqo: { q, r }, tileSize } = this;
    if (!tree) { return null }
    const origin = this.origin.copy();
    if (q < origin.q) origin.q -= tileSize;
    if (r < origin.r) origin.r -= tileSize;

    const tile = OddQHexTile.alloc ? OddQHexTile.alloc() : new OddQHexTile();
    tile.init(origin, tileSize, tileSize);
    this._setTile(i, tile);
    tree.addTile(tile);
    return tile;
  }

  /** @param {number} i */
  _allocNode(i) {

    // FIXME implicit oqo arg
    const { tree, oqo: { q, r }, tileSize } = this;
    if (!tree) { return null }
    const origin = this.origin.copy();
    origin.q += tileSize / (q < origin.q ? -2 : 2);
    origin.r += tileSize / (r < origin.r ? -2 : 2);

    const node = HexTileTreeNode.alloc ? HexTileTreeNode.alloc() : new HexTileTreeNode();
    node.init(tree, origin, tileSize);
    this._setTile(i, node);
    return node;
  }

  /**
   * @param {number} i
   * @param {tileOrNode} tile
   */
  _setTile(i, tile) {
    const prior = this.tiles[i];
    if (prior && prior instanceof HexTileTreeNode) {
      prior._replaceme = null;
    }
    this.tiles[i] = tile;
    if (tile instanceof OddQHexTile) {
      this.concrete++;
    } else if (tile instanceof HexTileTreeNode) {
      tile._replaceme = tile => this._setTile(i, tile);
    }
  }

}

function noop() {
}

// @ts-check

const REDRAW_TIMING_WINDOW = 5000;

// TODO refactor ent to be system oriented, pushing array ownership out of
// World into a passed in EntSystem interface

/** @typedef {object} Ent
 * @prop {number} index
 * @prop {number} numColors
 * @prop {number} numStates
 * @prop {OddQOffset} pos
 * @prop {number} dir
 * @prop {number} state
 * @prop {() => void} reset
 * @prop {(world: World) => void} step
 */

/** @typedef {object} View
 * @prop {() => void} step - TODO why are view stepped?
 * @prop {() => void} reset
 * @prop {boolean} needsRedraw -- TODO push this concern down into view?
 * @prop {() => void} redraw
 * @prop {(i: number) => void} addEnt
 * @prop {(i: number) => void} updateEnt
 * @prop {(i: number) => void} removeEnt
 * @prop {() => void} updateEnts
 */

// TODO view per-ent concerns may be better to push down into each view
// entirely; pass EntSystem to each view?

class World {

  static MaxColor = 0xff
  static MaxState = 0xff
  static MaxTurn = 0xffff

  static MaskResultState = 0xff000000
  static MaskResultColor = 0x00ff0000
  static MaskResultTurn = 0x0000ffff

  static ColorShift = 8
  static TurnShift = 16

  static FlagVisited = 0x0100
  static MaskColor = 0x00ff
  static MaskFlags = 0xff00

  constructor() {
    this.numColors = 0;
    this.numStates = 0;
    this.stepCount = 0;
    this.tile = new HexTileTree();

    /** @type {Ent[]} */
    this.ents = [];

    /** @type {View[]} */
    this.views = [];

    /** @type {number[]} */
    this.redrawTiming = [];
    this.now = () => performance.now();

    this.tmpCP = new CubePoint();
  }

  /** @param {number} i */
  getEntPos(i) {
    // TODO push this method out into EntSystem implementations
    const ent = this.ents[i];
    return ent ? ent.pos : new OddQOffset(NaN, NaN);
  }

  /** @param {number} i */
  getEntDir(i) {
    // TODO push this method out into EntSystem implementations
    const ent = this.ents[i];
    return ent ? ent.dir : NaN;
  }

  reset() {
    const { ents, tile, views } = this;

    // TODO push out into EntSystem.reset()
    for (const ent of ents) {
      ent.reset();
    }

    tile.reset();
    this.stepCount = 0;

    for (const view of views) {
      view.reset();
    }

    // TODO push out into EntSystem.occupiedPositions()
    const occupiedPositions = ents.map(({ pos }) => pos);
    for (const pos of occupiedPositions) {
      tile.update(pos, datum => World.FlagVisited | datum);
    }

  }

  /**
   * @param {number} i
   * @param {(dir: number, state: number, datum: number) => {dir: number, state: number, datum: number}} fn
   */
  updateEnt(i, fn) {
    // TODO refactor into unified EntSystem.step(tile);
    //      currently this is called by Turmite.prototype.step() ala Ent.step()

    const { ents, tile, tmpCP } = this;
    const ent = ents[i];
    if (!ent) { return }
    const { pos, dir, state } = ent;
    tile.update(pos, datum => {
      const { dir: newDir, state: newState, datum: newDatum } = fn(dir, state, datum);
      const basis = CubePoint.basis[newDir];
      if (basis) {
        pos.toCubeInto(tmpCP)
          .add(basis)
          .toOddQOffsetInto(pos);
      }
      ent.dir = newDir;
      ent.state = newState;
      return newDatum;
    });
    tile.update(ent.pos, datum => World.FlagVisited | datum);
  }

  step() {
    this._step();
    this.redraw();
  }

  /** @param {number} n */
  stepn(n) {
    for (let i = 0; i < n; i++) {
      this._step();
    }
    this.stepCount += n;
    return this.redraw();
  }

  _step() {
    // TODO becomes EntSystem.step()
    for (const ent of this.ents) {
      ent.step(this);
    }
    // TODO why are view stepped? that sounds like a (re)drawing concern?
    for (const view of this.views) {
      view.step();
    }
    this.stepCount++;
  }

  redraw() {
    let didredraw = false;

    const t0 = this.now();
    for (const view of this.views) {
      if (view.needsRedraw) {
        view.redraw();
        didredraw = true;
      }
    }
    const t1 = this.now();

    // TODO encapulate similarly to Sample... TimingSample?
    if (didredraw) {
      const { redrawTiming } = this;
      while (
        redrawTiming[0] !== undefined &&
        t0 - redrawTiming[0] > REDRAW_TIMING_WINDOW
      ) {
        redrawTiming.shift();
        redrawTiming.shift();
      }
      redrawTiming.push(t0, t1);
    }

    return didredraw;
  }

  redrawTimingStats() {
    const { redrawTiming } = this;
    if (redrawTiming.length < 4) {
      return null;
    }

    let n = 0, m1 = 0, m2 = 0;

    let i = 0;
    while (i < redrawTiming.length) {
      // NOTE: the ||NaN is mainly for undefined proof, but 0 is also not a
      // reasonable number in redrawTiming, so annihilating any maths circa a
      // spurious 0 is likely a Good Idea ™️ ... or is at least more likely to
      // get noticed sooner ;-)
      const t0 = redrawTiming[i++] || NaN;
      const t1 = redrawTiming[i++] || NaN;
      const dur = t1 - t0;
      const delta = dur - m1;
      n++;
      m1 += delta / n;
      m2 += delta * delta;
    }

    m2 /= n - 1;
    return { n, m1, m2 };
  }

  /** @param {Ent} ent */
  removeEnt(ent) {
    // TODO push out into EntSystem internal concerns;
    //      does not need to be on the World : EntSystem surface
    const { index } = ent;
    const { ents, views } = this;
    if (ents[index] !== ent) {
      throw new Error('removeEnt mismatch');
    }

    let i = index;
    for (let j = i++; j < ents.length; j++) {
      const ent = ents[j];
      if (ent) {
        ents[i] = ent;
        ent.index = i;
        i++;
      }
    }
    ents.length = i;

    for (let view of views) {
      view.removeEnt(i);
    }
  }

  /** @param {Ent[]} newEnts */
  setEnts(newEnts) {
    const { ents, tile, views } = this;
    const priorEntsLength = ents.length;

    ents.length = 0;
    for (const ent of newEnts) {
      ent.index = ents.length;
      ents.push(ent);
    }

    // TODO EntSystem.occupiedPositions()
    const occupiedPositions = newEnts.map(({ pos }) => pos);
    for (const pos of occupiedPositions) {
      tile.update(pos, datum => World.FlagVisited | datum);
    }

    // TODO EntSystem.numColors()
    this.numColors = Math.max.apply(null, ents.map(({ numColors }) => numColors));
    this.numStates = Math.max.apply(null, ents.map(({ numStates }) => numStates));

    // TODO why can't this just be for view of views view.udpateEnts()
    let i = 0;
    for (; i < priorEntsLength; ++i) {
      for (const view of views) {
        view.updateEnt(i);
      }
    }
    for (; i < newEnts.length; ++i) {
      for (const view of views) {
        view.addEnt(i);
      }
    }
    for (; i < priorEntsLength; ++i) {
      for (const view of views) {
        view.removeEnt(i);
      }
    }
  }

  /** @param {View} view */
  addView(view) {
    this.views.push(view);
    view.updateEnts(); // 🤦 and yet we had to do all that update/add/remove per-ent dance above?🍐wut
    return view;
  }

}

// @ts-check

class GLSLShader {

  /**
   * @param {string} name
   * @param {string} type
   * @param {string} source
   * @param {GLSLShader} [nextShader]
   */
  constructor(name, type, source, nextShader) {
    this.name = name;
    this.type = type;
    this.source = source;
    this.nextShader = nextShader;
  }

  /** @param {GLSLShader} nextShader */
  linkWith(nextShader) {
    const { name, type, source, nextShader: myNextShader } = this;
    if (myNextShader) {
      nextShader = myNextShader.linkWith(nextShader);
    }
    return new GLSLShader(name, type, source, nextShader);
  }

  /** @param {WebGLRenderingContext} gl */
  compile(gl) {
    const { name, type, source } = this;

    const typeRes = glShaderType(gl, type);
    if (typeRes.err) {
      return typeRes;
    }

    const shader = gl.createShader(typeRes.value);
    if (!shader) {
      return error(new Error(`unable to create ${type} shader`));
    }

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(shader) || '';
      const mess = annotateCompileError(source, log);
      return error(new Error(
        `${name} ${type} shader compile error: ${mess}`));
    }

    return just(shader);
  }

  /**
   * @param {WebGLRenderingContext} gl
   * @returns {rezult.Result<WebGLProgram>}
   */
  load(gl) {
    const prog = gl.createProgram();
    if (!prog) {
      return error(new Error('unable to create gl program'));
    }

    for (let shader = /** @type {GLSLShader|undefined} */ (this); shader; shader = shader.nextShader) {
      const res = shader.compile(gl);
      if (res.err) {
        return res;
      }
      gl.attachShader(prog, res.value);
    }

    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      const log = gl.getProgramInfoLog(prog);
      return error(new Error(`shader program link error: ${log}`));
    }

    return just(prog);
  }
}

/**
 * @param {WebGLRenderingContext} gl
 * @param {string} type
 */
function glShaderType(gl, type) {
  switch (type) {
    case 'frag':
      return just(gl.FRAGMENT_SHADER);
    case 'vert':
      return just(gl.VERTEX_SHADER);
    default:
      return error(new Error('invalid glsl shader type ' + JSON.stringify(type)));
  }
}

/**
 * @param {string} src
 * @param {string} mess
 */
function annotateCompileError(src, mess) {
  var match = /^ERROR: \d+:(\d+):/.exec(mess);
  if (!match) {
    return mess;
  }
  const lineNo = parseInt(match[1] || '');
  const contextCount = 3;

  const lines = src.split(/\n/);
  const numLines = lines.length;
  const w = numLines.toString().length;

  return [...annotateLine(
    numberLines(w, lines),
    lineNo, contextCount,
    `${' '.repeat(w)} ^-- ${mess}`
  )].join('\n');
}

/**
 * @param {number} w
 * @param {Iterable<string>} lines
 */
function* numberLines(w, lines) {
  let n = 0;
  for (const line of lines) {
    n++;
    yield `${n.toString().padStart(w)}: ${line}`;
  }
}

/**
 * @param {Iterable<string>} lines
 * @param {number} lineNo
 * @param {number} contextCount
 * @param {string} mess
 */
function* annotateLine(lines, lineNo, contextCount, mess) {
  let n = 0;
  for (const line of lines) {
    n++;
    if (Math.abs(lineNo - n) <= contextCount) {
      yield line;
    }
    if (n === lineNo) {
      yield mess;
    }
  }
}

// @generated from id:8fe5d2a30398cabcc7ed4fe8d8701663f454c3accc0674ba6aee737df82bcc30

var oddqPointShader = new GLSLShader("oddq_point", "vert",
  "/* A vertex shader for point vertices that are positioned using odd-q hexagonal\n" +
  " * coordinates.\n" +
  " *\n" +
  " * The vert attribute is just a Q,R vec2.\n" +
  " *\n" +
  " * The shader converts the Q,R vert into X,Y space, and sets gl_PointSize based\n" +
  " * on the viewport and radius uniforms.\n" +
  " *\n" +
  " * The color is simply passed along to the fragment shader\n" +
  " * for palette resolution.\n" +
  " *\n" +
  " * The optional ang attribute makes the hex partial, its two components are\n" +
  " * just a lo and hi value between 0 and 2*π.  If hi < lo, then the\n" +
  " * complementing range is drawn.\n" +
  " */\n" +
  "\n" +
  "uniform mat4 uPMatrix;\n" +
  "uniform vec2 uVP;\n" +
  "uniform float uRadius;\n" +
  "\n" +
  "attribute vec2 vert; // q, r\n" +
  "attribute vec2 ang; // aLo, aHi\n" +
  "attribute lowp float color; // i\n" +
  "\n" +
  "const vec2 scale = vec2(1.5, sqrt(3.0));\n" +
  "\n" +
  "varying lowp float vertColor;\n" +
  "varying mediump vec2 varAng;\n" +
  "\n" +
  "void main(void) {\n" +
  "    gl_PointSize = uVP.y * abs(uPMatrix[1][1]) * uRadius;\n" +
  "    gl_Position = uPMatrix * vec4(\n" +
  "        vec2(\n" +
  "            vert.x,\n" +
  "            vert.y + mod(vert.x, 2.0)/2.0\n" +
  "        ) * scale,\n" +
  "        0.0,\n" +
  "        1.0\n" +
  "    );\n" +
  "    vertColor = color + 1.0/512.0;\n" +
  "    varAng = ang;\n" +
  "}\n"
);

// @generated from id:e9953cec26100334f8c622af64aa4e105217621f14ded4a5172b08f00a1b60fc

var hexFragShader = new GLSLShader("hex", "frag",
  "/* A fragment shader which draws flat-topped hexagonal point sprites.\n" +
  " */\n" +
  "\n" +
  "varying lowp float vertColor;\n" +
  "varying mediump vec2 varAng;\n" +
  "\n" +
  "const mediump float pi = 3.141592653589793;\n" +
  "const mediump float tau = 2.0 * pi;\n" +
  "const mediump vec2 off = vec2(0.5, 0.5);\n" +
  "const mediump vec2 P0 = vec2(1.0, 0.0) / 2.0;\n" +
  "const mediump vec2 P1 = vec2(0.5, sqrt(3.0)/2.0) / 2.0;\n" +
  "const mediump float M10 = (P1.y - P0.y) / (P1.x - P0.x);\n" +
  "const mediump float B10 = P1.y - M10 * P1.x;\n" +
  "\n" +
  "uniform sampler2D uSampler;\n" +
  "\n" +
  "void main(void) {\n" +
  "    mediump vec2 p = gl_PointCoord - off;\n" +
  "    if (varAng.x != varAng.y) {\n" +
  "        mediump float a = mod(atan(p.y, p.x), tau);\n" +
  "        if (varAng.x < varAng.y) {\n" +
  "            if (a < varAng.x || a > varAng.y) {\n" +
  "                discard;\n" +
  "            }\n" +
  "        } else {\n" +
  "            if (a >= varAng.y && a <= varAng.x) {\n" +
  "                discard;\n" +
  "            }\n" +
  "        }\n" +
  "    }\n" +
  "    p = abs(p);\n" +
  "    if (p.y > P1.y || p.y > M10 * p.x + B10) {\n" +
  "        discard;\n" +
  "    }\n" +
  "    gl_FragColor = texture2D(uSampler, vec2(vertColor, 0));\n" +
  "}\n"
);

// @ts-check

/** @typedef {import('./coord.js').oddQToable} oddQToable */

/** @typedef {import('./colorgen.js').ColorGenMaker} ColorGenMaker */
/** @typedef {import('./colorgen.js').ColorGen} ColorGen */
/** @typedef {import('./hextile.js').OddQHexTile} OddQHexTile */

// TODO:
// - in redraw lazily only draw dirty tiles, expand permitting
// - switch to uint32 elements array if supported by extension
// - switch to uint32 for q,r, use a highp in the shader

const tau = 2 * Math.PI;
const hexAngStep = tau / 6;
const float2 = 2 * Float32Array.BYTES_PER_ELEMENT;

class ViewGL {

  /**
   * @param {World} world
   * @param {HTMLCanvasElement} $canvas
   */
  constructor(world, $canvas) {
    // TODO can we get away with not getting/retaining a world reference, and
    // just do with what get passed in through the world -> view surface?
    // i.e. move from `world -> view(world) + view -> world` to `world -(components)> view`

    this.world = world;
    this.$canvas = $canvas;

    this.topLeftQ = new OddQOffset();
    this.bottomRightQ = new OddQOffset();

    // max uint16 value for elements:
    // TODO: may be able to use uint32 extension
    // TODO: platform may define max in that case? (i.e. it would seem unlikely
    // that we can actually use a full 4Gi vert attribute, let alone that we
    // really don't want to allocate the 224GiB vert + color arrays that it
    // would imply
    this.maxElement = 0xffff;

    this.gl = this.$canvas.getContext('webgl') || null;
    if (!this.gl) {
      throw new Error('no webgl support');
    }

    this.perspectiveMatrix = identity(new Float32Array(16));

    // TODO refactor GLProgram to just take a variadic list of shaders, and own
    // the linking, rather than the shader linked-list deal it is currently

    // TODO refactor GLSLShader so that each shader carries data about its
    // uniforms and attributes; provide that data by analyzing source in the
    // loader

    // TODO @type only needed because import is not resolvable by typescript above
    const shader = oddqPointShader.linkWith(hexFragShader);
    const prog = toValue(shader.load(this.gl));

    this.hexShader = new GLProgram(this.gl,
      prog,
      ['uPMatrix', 'uVP', 'uRadius'],
      ['vert', 'ang', 'color']
    );
    this.uSampler = this.gl.getUniformLocation(this.hexShader.prog, 'uSampler'); // TODO: GLProgram borg
    if (!this.uSampler) {
      throw new Error('missing uSampler uniform');
    }

    this.tileWriter = new TileWriter(this.maxElement + 1);
    // TODO tileBufferer should only need access to the tile storage system, not the entire world
    this.tileBufferer = new TileBufferer(this.gl, this.world, this.tileWriter);
    this.entBuffer = new EntGLBuffer(this.gl);
    this.maxCellsPerTile = Math.floor((this.maxElement + 1) / this.tileWriter.cellSize);

    this.cellPallete = new GLPalette(this.gl, { unit: 0 });
    this.bodyPallete = new GLPalette(this.gl, { unit: 1 });
    this.headPallete = new GLPalette(this.gl, { unit: 2 });

    /** @type {ColorGen|null} */
    this.antCellColorGen = null;
    /** @type {ColorGen|null} */
    this.emptyCellColorGen = null;
    /** @type {ColorGen|null} */
    this.bodyColorGen = null;
    /** @type {ColorGen|null} */
    this.headColorGen = null;

    this.needsRedraw = false;

    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
    this.hexShader.use();

    this.gl.uniform1f(this.hexShader.uniform.uRadius, 1);

    this.updateSize(); // XXX: drop?
  }

  reset() {
    const {
      tileBufferer,
      topLeftQ, bottomRightQ,
      world: { tile },
    } = this;
    tileBufferer.reset();
    topLeftQ.q = 0, topLeftQ.r = 0;
    bottomRightQ.q = 0, bottomRightQ.r = 0;
    tile.eachTile(tileBufferer.drawUnvisited
      ? tile => tile.expandBoxTo(topLeftQ, bottomRightQ)
      : tile => tile.expandBoxToIf(topLeftQ, bottomRightQ, World.FlagVisited));
    this.updateSize();
  }

  /** @param {oddQToable} pointArg */
  expandTo(pointArg) {
    const { topLeftQ, bottomRightQ } = this;
    const { q, r } = pointArg.toOddQOffset();
    let expanded = false;

    if (q < topLeftQ.q) {
      topLeftQ.q = q;
      expanded = true;
    } else if (q >= bottomRightQ.q) {
      bottomRightQ.q = q;
      expanded = true;
    }

    if (r < topLeftQ.r) {
      topLeftQ.r = r;
      expanded = true;
    } else if (r >= bottomRightQ.r) {
      bottomRightQ.r = r;
      expanded = true;
    }

    return expanded;
  }

  updateSize() {
    const {
      gl,
      hexShader: {
        uniform: { uVP, uPMatrix },
      },
      perspectiveMatrix,
      $canvas: { width, height },
      tileWriter: {
        cellHalfWidth: rx,
        cellHalfHeight: ry,
      },
      topLeftQ, bottomRightQ,
    } = this;

    gl.viewport(0, 0, width, height);
    gl.uniform2f(uVP, width, height);

    let { x: topX, y: topY } = topLeftQ.toScreen();
    let { x: botX, y: botY } = bottomRightQ.toScreen();
    topX -= rx, topY -= ry;
    botX += rx, botY += ry;

    // TODO: sometimes over tweaks, but only noticable at small scale
    const oddEnough = (bottomRightQ.q - topLeftQ.q) > 0;
    if (topLeftQ.q & 1) {
      topY -= ry;
    }
    if (bottomRightQ.q & 1 || oddEnough) {
      botY += ry;
    }

    // fixAspectRatio
    const aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
    const gridWidth = botX - topX;
    const gridHeight = botY - topY;
    const ratio = gridWidth / gridHeight;
    if (ratio < aspectRatio) {
      const dx = gridHeight * aspectRatio / 2 - gridWidth / 2;
      topX -= dx, botX += dx;
    } else if (ratio > aspectRatio) {
      const dy = gridWidth / aspectRatio / 2 - gridHeight / 2;
      topY -= dy, botY += dy;
    }

    ortho(perspectiveMatrix, topX, botX, botY, topY, -1, 1);
    gl.uniformMatrix4fv(uPMatrix, false, perspectiveMatrix);
  }

  /** @param {boolean} should */
  setDrawTrace(should) {
    this.drawTrace = should;
    this.updateColors();
  }

  /**
   * @param {number} width
   * @param {number} height
   */
  resize(width, height) {
    const { $canvas } = this;
    $canvas.width = width;
    $canvas.height = height;
    this.updateSize();
    this.redraw();
  }

  redraw() {
    const { gl, hexShader } = this;
    gl.clear(gl.COLOR_BUFFER_BIT);

    hexShader.enable();
    this.drawTiles();
    this.drawEntities();
    hexShader.disable();

    gl.finish();
    this.needsRedraw = false;
  }

  drawTiles() {
    const {
      gl,
      hexShader: {
        attr: {
          ang: angAttr,
          vert: vertAttr,
          color: colorAttr,
        },
        uniform: { uRadius },
      },
      uSampler,
      cellPallete,
      tileBufferer,
    } = this;

    // flush changed tile data to buffers
    tileBufferer.flush();

    gl.uniform1f(uRadius, 1.0);

    // tiles are full hexes without an ang attribute
    gl.disableVertexAttribArray(angAttr);

    cellPallete.use(uSampler);

    // draw all tiles
    for (const { index, verts, colors, elements, usedElements } of tileBufferer.tileBuffers) {
      if (index.length) {
        gl.bindBuffer(gl.ARRAY_BUFFER, verts.buf);
        gl.vertexAttribPointer(vertAttr, verts.width, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, colors.buf);
        gl.vertexAttribPointer(colorAttr, colors.width, gl.UNSIGNED_BYTE, true, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elements.buf);
        gl.drawElements(gl.POINTS, usedElements, gl.UNSIGNED_SHORT, 0);
      }
    }
  }

  drawEntities() {
    const {
      gl,
      hexShader: {
        attr: {
          ang: angAttr,
          vert: vertAttr,
          color: colorAttr,
        },
        uniform: { uRadius },
      },
      uSampler,
      bodyPallete, headPallete,
      entBuffer,
      world: { ents },
    } = this;

    if (!ents.length) {
      return;
    }

    // extract world entity data
    const poss = ents.map(({ pos }) => pos);
    const dirs = ents.map(({ dir }) => dir);
    entBuffer.ensureLen(ents.length);

    // head and body are partial hexes with an ang attribute
    gl.enableVertexAttribArray(angAttr);

    // lay down entity color palette indices
    setNumbers(entBuffer.colors, function*() {
      // TODO ent color scheme beyond monotonic
      for (let i = 0; i < poss.length; i++) {
        yield i;
      }
    }());

    // lay down entity positions and body arcs
    setNumbers(entBuffer.verts, function*() {
      for (const [{ q, r }, dir] of zip(poss, dirs)) {
        yield q; yield r;
        const ang = dir * hexAngStep;
        yield ang + hexAngStep; yield ang;
      }
    }());

    // draw entity bodies
    bodyPallete.use(uSampler);
    gl.uniform1f(uRadius, 0.5);
    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.bodyVertsBuf);
    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.verts, gl.STATIC_DRAW);
    gl.vertexAttribPointer(vertAttr, 2, gl.FLOAT, false, float2, 0);
    gl.vertexAttribPointer(angAttr, 2, gl.FLOAT, false, float2, float2);
    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.bodyColorsBuf);
    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.colors, gl.STATIC_DRAW);
    gl.vertexAttribPointer(colorAttr, 1, gl.UNSIGNED_BYTE, true, 0, 0);
    gl.drawArrays(gl.POINTS, 0, entBuffer.len);

    // lay down entity head co-arcs
    setStridedNumbers(entBuffer.verts, 2, 4, function*() {
      for (const dir of dirs) {
        const ang = dir * hexAngStep;
        yield ang; yield ang + hexAngStep;
      }
    }());

    // draw entity heads
    headPallete.use(uSampler);
    gl.uniform1f(uRadius, 0.75);
    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.headVertsBuf);
    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.verts, gl.STATIC_DRAW);
    gl.vertexAttribPointer(vertAttr, 2, gl.FLOAT, false, float2, 0);
    gl.vertexAttribPointer(angAttr, 2, gl.FLOAT, false, float2, float2);
    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.headColorsBuf);
    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.colors, gl.STATIC_DRAW);
    gl.vertexAttribPointer(colorAttr, 1, gl.UNSIGNED_BYTE, true, 0, 0);
    gl.drawArrays(gl.POINTS, 0, entBuffer.len);
  }

  // TODO these are terrible legacy api callbacks for World, burn it down...
  // these methods used to do something different in prior iteration of the
  // view, but are all now redundant 💀
  addEnt() { this.updateColors(); }
  updateEnt() { this.updateColors(); }
  removeEnt() { this.updateColors(); }
  updateEnts() { this.updateColors(); }

  /** @param {ColorGenMaker} colorGenMaker */
  setColorGen(colorGenMaker) {
    const { makeColorGen } = colorGenMaker;
    this.emptyCellColorGen = extendColorGen(makeColorGen(0), World.MaxColor);
    this.antCellColorGen = extendColorGen(makeColorGen(1), World.MaxColor);
    this.bodyColorGen = makeColorGen(2);
    this.headColorGen = makeColorGen(3);
    this.updateColors();
  }

  updateColors() {
    const {
      drawTrace,
      world: { ents, numColors },
      cellPallete, emptyCellColorGen, antCellColorGen,
      bodyPallete, bodyColorGen,
      headPallete, headColorGen,
    } = this;
    const cellGen = drawTrace ? emptyCellColorGen : antCellColorGen;
    if (cellGen) {
      cellPallete.setColorsRGB(cellGen(numColors));
    }
    if (bodyColorGen) {
      bodyPallete.setColorsRGB(bodyColorGen(ents.length));
    }
    if (headColorGen) {
      headPallete.setColorsRGB(headColorGen(ents.length));
    }
  }

  get drawUnvisited() {
    return this.tileBufferer.drawUnvisited;
  }
  set drawUnvisited(drawUnvisited) {
    this.tileBufferer.drawUnvisited = drawUnvisited;
  }

  step() {
    const { world } = this;
    let expanded = false;
    for (let i = 0; i < world.ents.length; i++) {
      expanded = this.expandTo(world.getEntPos(i)) || expanded;
    }
    if (expanded) {
      this.updateSize();
    }
    this.needsRedraw = true;
  }
}

class EntGLBuffer {
  /** @param {WebGLRenderingContext} gl */
  constructor(gl) {
    this.gl = gl;
    this.len = 0;
    this.cap = 0;

    /** @type {Float32Array|null} */
    this.verts = null;
    /** @type {Uint8Array|null} */
    this.colors = null;

    /** @type {WebGLBuffer|null} */
    this.bodyVertsBuf = null;
    /** @type {WebGLBuffer|null} */
    this.bodyColorsBuf = null;

    /** @type {WebGLBuffer|null} */
    this.headVertsBuf = null;
    /** @type {WebGLBuffer|null} */
    this.headColorsBuf = null;
  }

  free() {
    const { gl } = this;
    this.verts = null;
    this.colors = null;
    gl.deleteBuffer(this.bodyVertsBuf);
    gl.deleteBuffer(this.bodyColorsBuf);
    gl.deleteBuffer(this.headVertsBuf);
    gl.deleteBuffer(this.headColorsBuf);
  }

  /** @param {number} cap */
  alloc(cap) {
    this.cap = cap;
    this.verts = new Float32Array(this.cap * 4);
    this.colors = new Uint8Array(this.cap * 1);
    this.bodyVertsBuf = this.gl.createBuffer();
    this.bodyColorsBuf = this.gl.createBuffer();
    this.headVertsBuf = this.gl.createBuffer();
    this.headColorsBuf = this.gl.createBuffer();
  }

  /** @param {number} len */
  ensureLen(len) {
    if (len > this.cap) {
      if (this.cap > 0) {
        this.free();
      }
      this.alloc(len < 1024
        ? 2 * len
        : len + Math.floor(len / 4));
    }
    this.len = len;
  }
}

class TileWriter {
  /** @param {number} bufferSize */
  constructor(bufferSize) {
    this.bufferSize = bufferSize;
    this.vertSize = 2;
    this.colorSize = 1;
    this.cellSize = 1;
    this.maxCells = Math.floor(this.bufferSize / this.cellSize);
    if (this.maxCells < 1) {
      throw new Error("can't fit any tiles in that bufferSize");
    }
    this.elementsSize = this.cellSize * this.maxCells + 2 * (this.maxCells - 1);
    this.colors = null;

    // Flat-topped vertices indexed by 2 * Math.PI * i / 6:
    //     2 1
    //   3     0
    //     4 5
    this.cellWidth = Math.cos(0) - Math.cos(Math.PI);
    this.cellHeight =
      Math.sin(2 * Math.PI / 6) -
      Math.sin(2 * Math.PI * 5 / 6);
    this.cellHalfWidth = this.cellWidth / 2;
    this.cellHalfHeight = this.cellHeight / 2;
  }

  /**
   * @param {number} id
   * @param {WebGLRenderingContext} gl
   */
  newTileBuffer(id, gl) {
    const { elementsSize, bufferSize, vertSize, colorSize } = this;
    return new TileGLBuffer(id,
      new GLBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, 1, new Uint16Array(elementsSize)),
      new LazyGLBuffer(gl, gl.ARRAY_BUFFER, vertSize, new Float32Array(bufferSize * vertSize)),
      new LazyGLBuffer(gl, gl.ARRAY_BUFFER, colorSize, new Uint8Array(bufferSize * colorSize)),
    );
  }

  /**
   * @param {OddQHexTile} tile
   * @param {TileGLBuffer} tileBuffer
   * @param {number} start
   */
  writeTileVerts({ data, origin, width, height }, { verts }, start) {
    if (!data) { return }
    setNumbers(verts.data.subarray(start * this.vertSize), function*() {
      const { q: loQ, r: loR } = origin;
      const hiQ = loQ + width;
      const hiR = loR + height;
      for (let r = loR; r < hiR; r++) {
        for (let q = loQ; q < hiQ; q++) {
          yield q;
          yield r;
        }
      }
    }());
    const end = start + width * height;
    verts.invalidate(start, end);
    return end;
  }

  /**
   * @param {OddQHexTile} tile
   * @param {TileGLBuffer} tileBuffer
   * @param {number} start
   */
  writeTileColors({ data }, { colors }, start) {
    if (!data) { return }
    setNumbers(colors.data.subarray(start * this.colorSize), function*() {
      for (const datum of data) {
        yield datum & World.MaskColor;
      }
    }());
    const end = start + data.length;
    colors.invalidate(start, end);
    return end;
  }
}

class TileBufferer {
  /**
   * @param {WebGLRenderingContext} gl
   * @param {World} world
   * @param {TileWriter} tileWriter
   */
  constructor(gl, world, tileWriter) {
    this.gl = gl;
    this.world = world;
    this.tileWriter = tileWriter;
    this.drawUnvisited = false;

    /** @type {TileGLBuffer[]} */
    this.tileBuffers = [];

    /** @type {Map<number, number>} */
    this.bufferForTileId = new Map();

    /** @type {Set<number>} */
    this.dirtyTileBuffers = new Set();

    // TODO this is a singular callback... that'll never work for more than one view...
    this.world.tile.tileRemoved = tile => this.onWorldTileRemoved(tile);
  }

  reset() {
    const {
      bufferForTileId,
      dirtyTileBuffers,
      tileBuffers,
    } = this;
    bufferForTileId.clear();
    dirtyTileBuffers.clear();
    for (const tileBuffer of tileBuffers) {
      tileBuffer.reset();
    }
  }

  /** @param {OddQHexTile} tile */
  onWorldTileRemoved(tile) {
    const {
      bufferForTileId,
      tileBuffers,
    } = this;
    const bufferId = bufferForTileId.get(tile.id);
    if (bufferId !== undefined) {
      const tileBuffer = tileBuffers[bufferId];
      if (!tileBuffer) {
        throw new Error('got tileRemoved for an unknown tile');
      }
      tileBuffer.removeTile(tile.id);
      bufferForTileId.delete(tile.id);
    }
  }

  flush() {
    const {
      world: { tile: { dirtyTiles } },
      dirtyTileBuffers,
      tileBuffers,
    } = this;
    for (const tile of dirtyTiles) {
      this.flushTile(tile);
    }
    dirtyTiles.length = 0;

    for (const id of dirtyTileBuffers) {
      const tileBuffer = tileBuffers[id];
      this.flushTileBuffer(tileBuffer);
    }
    dirtyTileBuffers.clear();
  }

  /** @param {OddQHexTile} tile */
  flushTile(tile) {
    const {
      dirtyTileBuffers,
      tileWriter,
    } = this;
    const { tileBuffer, offset } = this.bufferFor(tile);
    tileWriter.writeTileVerts(tile, tileBuffer, offset);
    tileWriter.writeTileColors(tile, tileBuffer, offset);
    dirtyTileBuffers.add(tileBuffer.id);
    tile.dirty = false;
  }

  /**
   * @param {OddQHexTile} tile
   * @returns {{tileBuffer: TileGLBuffer, offset: number}}
   */
  bufferFor(tile) {
    if (!tile.data) {
      throw new Error('unallocated tile will not be assigned a buffer');
    }

    const {
      gl,
      bufferForTileId,
      tileWriter,
      tileBuffers,
    } = this;

    const bufferId = bufferForTileId.get(tile.id);
    if (bufferId !== undefined) {
      const tileBuffer = tileBuffers[bufferId];
      const offset = tileBuffer.tileOffset(tile.id);
      if (offset < 0) {
        throw new Error('dissociated tileBuffer.tiles -> tile');
      }
      return { tileBuffer, offset };
    }

    for (const tileBuffer of tileBuffers) {
      const offset = tileBuffer.addTile(tile.id, tile.data.length * tileWriter.cellSize);
      if (offset >= 0) {
        bufferForTileId.set(tile.id, tileBuffer.id);
        return { tileBuffer, offset };
      }
    }

    const tileBuffer = tileWriter.newTileBuffer(tileBuffers.length, gl);
    tileBuffers.push(tileBuffer);
    const offset = tileBuffer.addTile(tile.id, tile.data.length * tileWriter.cellSize);
    if (offset < 0) {
      throw new Error('unable to add tile to new tileBuffer');
    }
    bufferForTileId.set(tile.id, tileBuffer.id);
    return { tileBuffer, offset };
  }

  /** @param {TileGLBuffer} tileBuffer */
  flushTileBuffer(tileBuffer) {
    const { world, drawUnvisited } = this;
    tileBuffer.usedElements = 0;
    for (const tileId of tileBuffer.tileRanges.keys()) {
      const tile = world.tile.getTile(tileId);
      if (!tile) {
        throw new Error(`tile #${tileId} missing in buffer #${tileBuffer.id}`);
      }
      if (!tile.data) {
        throw new Error(`tile #${tileId} has no data for buffer #${tileBuffer.id}`);
      }
      let offset = tileBuffer.tileOffset(tile.id);
      for (const datum of tile.data) {
        if (drawUnvisited || datum & World.FlagVisited) {
          tileBuffer.addElement(offset);
        }
        offset++;
      }
    }
    tileBuffer.flush();
  }
}

/**
 * @param {ColorGen} gen
 * @param {number} n
 * @returns {ColorGen}
 */
function extendColorGen(gen, n) {
  return function*(m) {
    const ar = [...gen(m)];
    m = ar.length;
    if (!m) return;
    yield* ar;
    for (let i = ar.length; i < n; i++) {
      yield ar[i % ar.length];
    }
  };
}

/** @template A, B
 * @param {ArrayLike<A>} a
 * @param {ArrayLike<B>} b
 */
function* zip(a, b) {
  for (let i = 0; i < a.length && i < b.length; i++) {
    yield /** @type {[A, B]} */([a[i], b[i]]);
  }
}

/**
 * @param {{readonly length: number, [index: number]: number}|null} ar
 * @param {Iterable<number>} ns
 */
function setNumbers(ar, ns) {
  const length = ar?.length;
  if (!length) {
    return;
  }
  let i = 0;
  for (const n of ns) {
    ar[i] = n;
    if (++i >= length) { return; }
  }
}

/**
 * @param {{readonly length: number, [index: number]: number}|null} ar
 * @param {number} offset
 * @param {number} stride
 * @param {Iterable<number>} ns
 */
function setStridedNumbers(ar, offset, stride, ns) {
  const length = ar?.length;
  if (!length) {
    return;
  }
  let i = offset;
  for (const n of ns) {
    ar[i] = n;
    if (++i >= length) { return; }
    if (i % stride == 0) {
      i += offset;
    }
  }
}

// @ts-check

/** @typedef {import('./world.js').Ent} Ent */

const FPSInterval = 3 * 1000;
const NumTimingSamples = FPSInterval / 1000 * 60;
const MinFPS = 20;

class Hexant {

  /**
   * @param {object} options
   * @param {HTMLElement} options.$body
   * @param {HTMLCanvasElement} [options.$view]
   * @param {HTMLElement} [options.$fpsOverlay]
   * @param {HTMLElement} [options.$step]
   * @param {HTMLElement} [options.$fps]
   * @param {HTMLElement} [options.$sps]
   * @param {HTMLElement} [options.$redrawTiming]
   */
  constructor({
    $body,
    $view = mustQuery($body, '#view', HTMLCanvasElement),
    $fpsOverlay = mustQuery($body, '#fpsOverlay', HTMLElement),
    $step = mustQuery($body, '#step', HTMLElement),
    $fps = mustQuery($body, '#fps', HTMLElement),
    $sps = mustQuery($body, '#sps', HTMLElement),
    $redrawTiming = mustQuery($body, '#redrawTiming', HTMLElement),
  }) {
    const window = $body.ownerDocument.defaultView;
    if (!window) {
      throw new Error('$body has no defaultView');
    }

    this.$body = $body;

    function makePrompt() {
      let $prompt = mayQuery($body, '#prompt', HTMLElement);
      if ($prompt) $body.removeChild($prompt);
      $prompt = $body.appendChild($body.ownerDocument.createElement('div'));
      $prompt.id = 'prompt';
      $prompt.classList.add('prompt');
      return $prompt;
    }

    this.$fpsOverlay = $fpsOverlay;
    this.$step = $step;
    this.$fps = $fps;
    this.$sps = $sps;
    this.$redrawTiming = $redrawTiming;

    this.window = window;
    this.lastStepTime = null;
    this.goalStepRate = 0;
    this.stepRate = 0;
    this.locked = false;
    this.paused = true;
    this.showFPS = false;

    /** @type {number[]} */
    this.animTimes = [];

    /** @type {number[]} */
    this.stepTimes = [];

    this.animTiming = new Sample(NumTimingSamples);

    this.titleBase = this.window.document.title;

    this.world = new World();

    this.view = new ViewGL(this.world, $view);
    this.world.addView(this.view);
    this.world.tile.maxTileArea = this.view.maxCellsPerTile;

    const {
      bind: bindHash,
      load: loadHash,
      ...hash
    } = makeHash(window);

    bindHash('colors', {
      parse: parse$2,
      defaultValue: toValue(parse$2('light')),
      listener: gen => {
        this.view.setColorGen(gen);
        this.view.redraw();
      },
    });

    bindHash('rule', {
      parse: str => Turmite.from(str, World),
      defaultValue: toValue(Turmite.from('ant(L R)', World)),
      listener: ent => this.setEnts(ent ? [ent] : []),
    });

    bindHash('showFPS', {
      defaultValue: false,
      listener: showFPS => {
        this.showFPS = showFPS;
        this.$fpsOverlay.style.display = this.showFPS ? '' : 'none';
      },
    });

    bindHash('stepRate', {
      parse: lift(parseInt),
      defaultValue: 4,
      listener: rate => this.setStepRate(rate),
    });

    bindHash('drawUnvisited', {
      defaultValue: false,
      listener: drawUnvisited => this.view.drawUnvisited = drawUnvisited,
    });

    bindHash('drawTrace', {
      defaultValue: false,
      listener: drawTrace => {
        this.view.setDrawTrace(drawTrace);
        this.view.redraw();
      },
    });

    loadHash();

    this.hash = hash;

    /**
     * @typedef {object} ActionProps
     * @prop {string[]} keys
     * @prop {string} name
     * @prop {string} desc
     */

    /** @template T @typedef {import('./prompt.js').Interactor<T>} Interactor */
    /** @template T @typedef {import('./prompt.js').Looper<T>} Looper */

    /**
     * @typedef {ActionProps & (
     * | {then: () => void}
     * | {prompt: Interactor<unknown>}
     * | {loop: Looper<void>}
     * )} Action
     */

    /** @type {Action[]} */
    const actions = [

      {
        name: 'help',
        desc: 'show this help screen',
        keys: ['?', 'h', 'button2'],
        loop: function*() {
          yield { title: 'Actions' };
          yield {
            help: function*() {
              // yield `| Name | Key | Description |`;
              // yield `|------|-----|-------------|`;
              for (const { name, keys: [key], desc } of actions) {
                // yield `| ${name} | \`${key}\` | ${desc} |`;
                yield `${name} ( key: \`${key}\` )`;
                // TODO display other keys
                yield `: ${desc}`;
                yield ``;
              }
            }()
          };
        },
      },

      {
        name: 'play',
        desc: 'play / pause the simulation',
        keys: ['Space', 'button0'],
        then: () => { this.playpause(); },
      },

      {
        name: 'step',
        desc: 'single step when paused, pause if playing',
        keys: ['.', 'button1'],
        then: () => this.stepit(),
      },

      {
        name: 'reset',
        keys: ['*'],
        desc: 'reset the simulation to initial state',
        then: () => this.reboot(),
      },

      {
        name: 'rule',
        keys: ['/'],
        desc: 'edit the simulated ant ruleset',
        prompt: this.rulePrompt(),
      },

      {
        name: 'colorscheme',
        keys: ['c'],
        desc: 'edit the color scheme used for tiles and ants',
        prompt: this.colorPrompt(),
      },

      {
        name: 'speed up',
        desc: 'double simulation speed',
        keys: ['+'],
        then: () => this.hash.set('stepRate', this.stepRate * 2),
      },

      {
        name: 'slow down',
        desc: 'halve simulation speed',
        keys: ['-'],
        then: () => this.hash.set('stepRate', Math.max(1, Math.floor(this.stepRate / 2))),
      },

      {
        name: 'FPS',
        desc: 'show/hide runtime statistic overlay',
        keys: ['f'],
        then: () => this.hash.set('showFPS', !this.showFPS),
      },

      {
        name: 'unvisited cells',
        desc: 'toggle whether all visible cells are drawn instead of just visted cells ones',
        keys: ['u'],
        then: () => this.hash.set('drawUnvisited', !this.view.drawUnvisited),
        // TODO trigger an immediate redraw
      },

      // TODO this used to work
      // {
      //   name: 'trace cells',
      //   desc: 'toggle whether to draw traces of recently visited cells',
      //   keys: ['t'],
      //   then: () => this.hash.set('drawTrace', !this.view.drawTrace),
      // },

      // TODO doesn't work correctly, just replace with an action that directly
      // generates and offer for copy such url, rather than change encoding
      // scheme
      //
      // {
      //   name: 'toggle base64 #fragment',
      //   desc: 'change url encoding scheme to output a more easily shareable base64 form',
      //   keys: ['b'],
      //   then: () => this.hash.encoding = this.hash.encoding == 'b64:' ? '' : 'b64:',
      // },

      {
        name: 'fullscreen',
        desc: 'enter/exit fullscreen mode',
        keys: ['Enter'],
        then() {
          const { ownerDocument: document } = $body;
          if (!document.fullscreenElement) {
            $body.requestFullscreen();
          } else if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        },
      },

    ];

    // TODO shifted keys are a bit awkward right now
    /** @type {Map<string, (key: string) => void>} */
    this.keymap = new Map(actions.flatMap(action => {
      const then = 'then' in action ? action.then : (prompt =>
        () => runPrompt(makePrompt, prompt)
      )('prompt' in action ? action.prompt : loop(action.loop));
      return action.keys.map(key => [key, () => then()])
    }));
    this.keymap.set('Escape', () => {
      let $prompt = mayQuery($body, '#prompt', HTMLElement);
      if ($prompt) $body.removeChild($prompt);
    });
    // this.keymap.set('', k => console.log('?', k)) // to log unhandled events

    this.window.addEventListener('keydown', this);
    this.window.addEventListener('keyup', this);
    this.window.addEventListener('mouseup', this);

    let autoplay = false;
    let autorefresh = 0;
    if (this.hash.get('fullauto')) {
      autoplay = true;
      autorefresh = 24 * 60 * 60;
    } else {
      autoplay = this.hash.get('autoplay');
      autorefresh = parseInt(this.hash.get('autorefresh'), 10);
    }

    if (!isNaN(autorefresh) && autorefresh) {
      this.window.setTimeout(
        () => this.window.location.reload(),
        autorefresh * 1000);
    }

    if (autoplay) this.play();
  }

  reboot() {
    this.pause();
    this.setEnts([this.hash.get('rule')]);
  }

  /** @param {Ent[]} ents */
  setEnts(ents) {
    const title = ents.map(ent => `${ent}`).join(', ');
    this.world.setEnts(ents);
    this.world.reset();
    this.view.$canvas.width = this.view.$canvas.width;
    this.view.redraw();
    this.window.document.title = this.titleBase + ': ' + title;
  }

  /** @param {Event} e */
  handleEvent(e) {

    /** @param {string} key */
    const dispatch = key => {
      let fn =
        this.keymap.get(`${key}`)
        || this.keymap.get(`${key.toLowerCase()}`)
        || this.keymap.get('');
      if (fn) {
        e.preventDefault();
        fn(key);
      }
    };

    const { type } = e;
    let $prompt = mayQuery(this.$body, '#prompt', HTMLElement);

    const { target } = e;
    if (!(
      target === $prompt ||
      target === this.view.$canvas ||
      target === this.window.document.documentElement ||
      target === this.window.document.body
    )) return;

    switch (type) {
      case 'mouseup':
        if (e instanceof MouseEvent) {
          dispatch(keycode(e, { button: e.button }));
        }
        break;

      case 'keydown':
        if (e instanceof KeyboardEvent) {
          switch (e.key) {
            case 'Escape':
              e.preventDefault();
              break;
          }
        }
        break;

      case 'keyup':
        if (e instanceof KeyboardEvent) {
          dispatch(keycode(e, { key: e.key }));
        }
    }
  }

  rulePrompt() {
    const { hash } = this;
    const hashName = 'rule';
    return loop(function*(inputs) {
      let value = hash.getStr(hashName);

      for (const input of inputs) {
        if ('value' in input) {
          ({ value } = input);
          const { res: { err }, str: revalue } = hash.set(hashName, value);
          if (!err) { return true }
          if (revalue) value = revalue;
          yield { error: err.message };
        }
      }

      for (const { name, then } of ruleActions(value)) {
        for (const input of inputs) {
          if ('command' in input) {
            const { command } = input;
            if (command === name) {
              let ok = false;
              try {
                value = then(value);
                ok = true;
              } catch (e) {
                yield { error: `${e}` };
              }
              if (ok) {
                const { res: { err }, str: revalue } = hash.set(hashName, value);
                if (revalue) value = revalue;
                if (err) yield { error: err.message };
              }
            }
          }
        }
      }

      for (const { name, label } of ruleActions(value)) {
        yield { command: name, label: label || name };
      }

      yield { title: 'Rule' };
      yield { value };
      yield { help: ruleHelp(value) };

      return undefined;
    });
  }

  colorPrompt() {
    const { hash } = this;
    const hashName = 'colors';
    return loop(
      function*(inputs) {
        for (const input of inputs) {
          if ('value' in input) {
            const { value } = input;
            const { res: { err }, str: revalue } = hash.set(hashName, value);
            if (!err) { return true }
            yield { error: err.message };
            yield { value: revalue || value };
            yield { title: 'Colors' };
          }
        }
        return undefined;
      },

      function*() {
        const value = hash.getStr(hashName);
        yield { value };
        yield { title: 'Colors' };
        return undefined;
      });
  }

  /** @param {number} time */
  calcSteps(time) {
    if (!this.lastStepTime) {
      this.lastStepTime = time;
      return 0;
    }

    const sinceLast = time - this.lastStepTime;
    if (sinceLast > 0) {
      this.animTiming.collect(sinceLast);
    }
    this.throttle();
    return Math.round(sinceLast / 1000 * this.stepRate);
  }

  /** @param {number} time */
  stepWorld(time) {
    if (this.locked) { return; }
    const steps = this.calcSteps(time);
    if (steps < 1) {
      return;
    }
    if (steps == 1) {
      this.world.step();
    } else {
      this.world.stepn(steps);
    }
    this.stepTimes.push(time, steps);
    this.lastStepTime = time;
  }

  /** @param {number} time */
  updateFPS(time) {
    this.animTimes.push(time);
    while (time - this.animTimes[0] > FPSInterval) {
      this.animTimes.shift();
    }
    while (time - this.stepTimes[0] > FPSInterval) {
      this.stepTimes.shift();
    }
    if (!this.showFPS) return;
    this.$step.innerText = '#' + this.world.stepCount;
    this.$fps.innerText = this.computeFPS().toFixed(0) + 'fps';
    this.$sps.innerText = toSI(this.computeSPS()) + 'sps';
    var stats = this.world.redrawTimingStats();
    if (stats) {
      this.$redrawTiming.innerText =
        'µ=' + toSI(stats.m1 / 1e3) + 's ' +
        '𝜎=' + toSI(Math.sqrt(stats.m2 / 1e3)) + 's';
    } else {
      this.$redrawTiming.innerText = '';
    }
  }

  throttle() {
    if (!this.animTiming.complete()) {
      return;
    }

    if (this.animTiming.sinceWeightedMark() <= 3) {
      return;
    }

    if (this.stepRate > 1) {
      const fps = this.computeFPS();
      if (fps < MinFPS) {
        this.animTiming.weightedMark(2);
        this.stepRate /= 2;
        return;
      }
    }

    var as = this.animTiming.classifyAnomalies();
    var i = as.length - 1;
    if (
      this.stepRate > 1 &&
      as[i] > 0.5 && as[i - 1] > 0.5 && as[i - 2] > 0.5
    ) {
      this.stepRate /= 2;
      this.animTiming.weightedMark(2);
    } else if (
      this.stepRate < this.goalStepRate &&
      as[i] <= 0 && as[i - 1] <= 0 && as[i - 2] <= 0
    ) {
      this.stepRate *= 2;
      this.animTiming.weightedMark(0.5);
    }

  }

  computeFPS() {
    return this.animTimes.length / FPSInterval * 1000;
  }

  computeSPS() {
    let totalSteps = 0;
    for (var i = 1; i < this.stepTimes.length; i += 2) {
      totalSteps += this.stepTimes[i];
    }
    return totalSteps / FPSInterval * 1000;
  }

  async play() {
    if (this.locked) { return; }
    this.paused = false;
    this.animTimes.length = 0;
    this.stepTimes.length = 0;
    this.animTiming.reset();
    this.$fps.innerText = '';
    this.$sps.innerText = '';
    this.$redrawTiming.innerText = '';
    this.lastStepTime = null;

    while (!this.paused) {
      const time = await nextFrame(this.window);
      /* eslint-disable no-try-catch */
      try {
        this.stepWorld(time);
        this.updateFPS(time);
      } catch (err) {
        this.pause();
        this.locked = true;
        logError(err, 'Hexant playtime',
          ['config', Object.fromEntries(this.hash.stringEntries())],
          ['step', this.world.stepCount],
          ['fps', this.computeFPS()],
          ['sps', this.computeSPS()],
          ['redrawTiming', this.world.redrawTimingStats()],
        );
      }
    }
  }

  pause() {
    this.paused = true;
    this.$fps.innerText = '<' + this.$fps.innerText + '>';
    this.$sps.innerText = '<' + this.$sps.innerText + '>';
    this.$redrawTiming.innerText = '<' + this.$redrawTiming.innerText + '>';
    this.lastStepTime = null;
  }

  playpause() {
    if (this.paused) {
      this.play();
    } else {
      this.pause();
    }
  }

  stepit() {
    if (!this.paused) {
      this.pause();
    } else if (!this.locked) {
      this.world.step();
    }
  }

  /** @param {number} rate */
  setStepRate(rate) {
    if (this.stepRate === this.goalStepRate) {
      this.stepRate = rate;
    }
    this.goalStepRate = rate;
  }

  /**
   * @param {number} width
   * @param {number} height
   */
  resize(width, height) {
    this.view.resize(width, height);
  }

}

const nsiSuffix = ['', 'm', 'µ', 'n'];
const siSuffix = ['K', 'M', 'G', 'T', 'E'];

/** @param {number} n */
function toSI(n) {
  if (n < 1) {
    let nsi = 0;
    while (nsi < nsiSuffix.length && n < 1) {
      nsi++;
      n *= 1e3;
    }
    return n.toPrecision(3) + nsiSuffix[nsi];
  }
  if (n < 1e3) {
    return n.toFixed(0);
  }
  n /= 1e3;
  let si = 0;
  while (si < siSuffix.length && n > 1e3) {
    si++;
    n /= 1e3;
  }
  return n.toPrecision(3) + siSuffix[si];
}

/**
 * @param {Window} [window]
 * @returns {Promise<number>}
 */
function nextFrame(window = global.window) {
  return new Promise(
    resolve => window.requestAnimationFrame(resolve)
  );
}

/** @typedef {object} ModifierKeyEvent
 * @prop {boolean} metaKey
 * @prop {boolean} altKey
 * @prop {boolean} ctrlKey
 * @prop {boolean} shiftKey
 */

/**
 * @param {ModifierKeyEvent} e
 * @param {{key:string}|{button:number}} kb
 */
function keycode({ metaKey, altKey, ctrlKey }, kb) {
  return [...function*() {
    let key = '';

    if (metaKey) yield `M`;
    if (altKey) yield `A`;
    if (ctrlKey) yield `C`;
    // if (shiftKey)  yield `S`; // NOTE ignoring shift for now
    if ('key' in kb) {
      ({ key } = kb);
      switch (key) {
        case ' ':
          yield 'Space';
          break;

        default:
          yield key;
      }
    } else yield `button${kb.button}`;
  }()].join('-');
}

/**
 * @param {any} err
 * @param {string} desc
 * @param {[key: string, data: any][]} details
 */
function logError(err, desc, ...details) {
  console.group(`${desc} error`);
  console.error(err);
  for (const [key, data] of details) {
    console.log(key, JSON.stringify(data));
  }
  console.groupEnd();
}

// @ts-check

const hexant = new Hexant({
  $body: document.querySelector('#main'),
});

function updateSize() {
  const {
    innerWidth, innerHeight,
    document: {
      documentElement: { clientWidth, clientHeight },
    },
  } = window;
  const width = Math.max(clientWidth, innerWidth || 0);
  const height = Math.max(clientHeight, innerHeight || 0);
  hexant.resize(width, height);
}

window.addEventListener('resize', () => updateSize());
updateSize();
//# sourceMappingURL=index.bundle.js.map
