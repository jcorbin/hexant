{"version":3,"file":"index.bundle.min.js","sources":["../node_modules/hsluv/hsluv.js","../src/rezult.js","../src/colorgen.js","../src/domkit.js","../src/hashbind.js","../src/prompt.js","../src/sample.js","../src/coord.js","../src/turmite/constants.js","../node_modules/nearley/lib/nearley.js","../src/turmite/grammar_rules.js","../src/turmite/grammar.js","../src/turmite/parse.js","../src/turmite/rle-builder.js","../src/turmite/tostring.js","../src/turmite/analyze.js","../src/turmite/compile.js","../src/turmite/index.js","../node_modules/gl-matrix/esm/common.js","../node_modules/gl-matrix/esm/mat4.js","../node_modules/gl-matrix/esm/vec3.js","../node_modules/gl-matrix/esm/quat.js","../node_modules/gl-matrix/esm/vec4.js","../node_modules/gl-matrix/esm/mat3.js","../node_modules/gl-matrix/esm/vec2.js","../src/glprogram.js","../src/glpalette.js","../src/tileglbuffer.js","../src/rangelist.js","../src/hextile.js","../src/hextiletree.js","../src/world.js","../src/glsl-shader.js","../src/oddq_point.min.js","../src/hex.min.js","../src/view_gl.js","../src/hexant.js","../index.js"],"sourcesContent":["// Generated by Haxe 3.4.4\nvar hsluv = hsluv || {};\nhsluv.Geometry = function() { };\nhsluv.Geometry.intersectLineLine = function(a,b) {\n\tvar x = (a.intercept - b.intercept) / (b.slope - a.slope);\n\tvar y = a.slope * x + a.intercept;\n\treturn { x : x, y : y};\n};\nhsluv.Geometry.distanceFromOrigin = function(point) {\n\treturn Math.sqrt(Math.pow(point.x,2) + Math.pow(point.y,2));\n};\nhsluv.Geometry.distanceLineFromOrigin = function(line) {\n\treturn Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope,2) + 1);\n};\nhsluv.Geometry.perpendicularThroughPoint = function(line,point) {\n\tvar slope = -1 / line.slope;\n\tvar intercept = point.y - slope * point.x;\n\treturn { slope : slope, intercept : intercept};\n};\nhsluv.Geometry.angleFromOrigin = function(point) {\n\treturn Math.atan2(point.y,point.x);\n};\nhsluv.Geometry.normalizeAngle = function(angle) {\n\tvar m = 2 * Math.PI;\n\treturn (angle % m + m) % m;\n};\nhsluv.Geometry.lengthOfRayUntilIntersect = function(theta,line) {\n\treturn line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));\n};\nhsluv.Hsluv = function() { };\nhsluv.Hsluv.getBounds = function(L) {\n\tvar result = [];\n\tvar sub1 = Math.pow(L + 16,3) / 1560896;\n\tvar sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;\n\tvar _g = 0;\n\twhile(_g < 3) {\n\t\tvar c = _g++;\n\t\tvar m1 = hsluv.Hsluv.m[c][0];\n\t\tvar m2 = hsluv.Hsluv.m[c][1];\n\t\tvar m3 = hsluv.Hsluv.m[c][2];\n\t\tvar _g1 = 0;\n\t\twhile(_g1 < 2) {\n\t\t\tvar t = _g1++;\n\t\t\tvar top1 = (284517 * m1 - 94839 * m3) * sub2;\n\t\t\tvar top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;\n\t\t\tvar bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;\n\t\t\tresult.push({ slope : top1 / bottom, intercept : top2 / bottom});\n\t\t}\n\t}\n\treturn result;\n};\nhsluv.Hsluv.maxSafeChromaForL = function(L) {\n\tvar bounds = hsluv.Hsluv.getBounds(L);\n\tvar min = Infinity;\n\tvar _g = 0;\n\twhile(_g < bounds.length) {\n\t\tvar bound = bounds[_g];\n\t\t++_g;\n\t\tvar length = hsluv.Geometry.distanceLineFromOrigin(bound);\n\t\tmin = Math.min(min,length);\n\t}\n\treturn min;\n};\nhsluv.Hsluv.maxChromaForLH = function(L,H) {\n\tvar hrad = H / 360 * Math.PI * 2;\n\tvar bounds = hsluv.Hsluv.getBounds(L);\n\tvar min = Infinity;\n\tvar _g = 0;\n\twhile(_g < bounds.length) {\n\t\tvar bound = bounds[_g];\n\t\t++_g;\n\t\tvar length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad,bound);\n\t\tif(length >= 0) {\n\t\t\tmin = Math.min(min,length);\n\t\t}\n\t}\n\treturn min;\n};\nhsluv.Hsluv.dotProduct = function(a,b) {\n\tvar sum = 0;\n\tvar _g1 = 0;\n\tvar _g = a.length;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tsum += a[i] * b[i];\n\t}\n\treturn sum;\n};\nhsluv.Hsluv.fromLinear = function(c) {\n\tif(c <= 0.0031308) {\n\t\treturn 12.92 * c;\n\t} else {\n\t\treturn 1.055 * Math.pow(c,0.416666666666666685) - 0.055;\n\t}\n};\nhsluv.Hsluv.toLinear = function(c) {\n\tif(c > 0.04045) {\n\t\treturn Math.pow((c + 0.055) / 1.055,2.4);\n\t} else {\n\t\treturn c / 12.92;\n\t}\n};\nhsluv.Hsluv.xyzToRgb = function(tuple) {\n\treturn [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2],tuple))];\n};\nhsluv.Hsluv.rgbToXyz = function(tuple) {\n\tvar rgbl = [hsluv.Hsluv.toLinear(tuple[0]),hsluv.Hsluv.toLinear(tuple[1]),hsluv.Hsluv.toLinear(tuple[2])];\n\treturn [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2],rgbl)];\n};\nhsluv.Hsluv.yToL = function(Y) {\n\tif(Y <= hsluv.Hsluv.epsilon) {\n\t\treturn Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;\n\t} else {\n\t\treturn 116 * Math.pow(Y / hsluv.Hsluv.refY,0.333333333333333315) - 16;\n\t}\n};\nhsluv.Hsluv.lToY = function(L) {\n\tif(L <= 8) {\n\t\treturn hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;\n\t} else {\n\t\treturn hsluv.Hsluv.refY * Math.pow((L + 16) / 116,3);\n\t}\n};\nhsluv.Hsluv.xyzToLuv = function(tuple) {\n\tvar X = tuple[0];\n\tvar Y = tuple[1];\n\tvar Z = tuple[2];\n\tvar divider = X + 15 * Y + 3 * Z;\n\tvar varU = 4 * X;\n\tvar varV = 9 * Y;\n\tif(divider != 0) {\n\t\tvarU /= divider;\n\t\tvarV /= divider;\n\t} else {\n\t\tvarU = NaN;\n\t\tvarV = NaN;\n\t}\n\tvar L = hsluv.Hsluv.yToL(Y);\n\tif(L == 0) {\n\t\treturn [0,0,0];\n\t}\n\tvar U = 13 * L * (varU - hsluv.Hsluv.refU);\n\tvar V = 13 * L * (varV - hsluv.Hsluv.refV);\n\treturn [L,U,V];\n};\nhsluv.Hsluv.luvToXyz = function(tuple) {\n\tvar L = tuple[0];\n\tvar U = tuple[1];\n\tvar V = tuple[2];\n\tif(L == 0) {\n\t\treturn [0,0,0];\n\t}\n\tvar varU = U / (13 * L) + hsluv.Hsluv.refU;\n\tvar varV = V / (13 * L) + hsluv.Hsluv.refV;\n\tvar Y = hsluv.Hsluv.lToY(L);\n\tvar X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);\n\tvar Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);\n\treturn [X,Y,Z];\n};\nhsluv.Hsluv.luvToLch = function(tuple) {\n\tvar L = tuple[0];\n\tvar U = tuple[1];\n\tvar V = tuple[2];\n\tvar C = Math.sqrt(U * U + V * V);\n\tvar H;\n\tif(C < 0.00000001) {\n\t\tH = 0;\n\t} else {\n\t\tvar Hrad = Math.atan2(V,U);\n\t\tH = Hrad * 180.0 / Math.PI;\n\t\tif(H < 0) {\n\t\t\tH = 360 + H;\n\t\t}\n\t}\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToLuv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tvar Hrad = H / 360.0 * 2 * Math.PI;\n\tvar U = Math.cos(Hrad) * C;\n\tvar V = Math.sin(Hrad) * C;\n\treturn [L,U,V];\n};\nhsluv.Hsluv.hsluvToLch = function(tuple) {\n\tvar H = tuple[0];\n\tvar S = tuple[1];\n\tvar L = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [100,0,H];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [0,0,H];\n\t}\n\tvar max = hsluv.Hsluv.maxChromaForLH(L,H);\n\tvar C = max / 100 * S;\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToHsluv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [H,0,100];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [H,0,0];\n\t}\n\tvar max = hsluv.Hsluv.maxChromaForLH(L,H);\n\tvar S = C / max * 100;\n\treturn [H,S,L];\n};\nhsluv.Hsluv.hpluvToLch = function(tuple) {\n\tvar H = tuple[0];\n\tvar S = tuple[1];\n\tvar L = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [100,0,H];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [0,0,H];\n\t}\n\tvar max = hsluv.Hsluv.maxSafeChromaForL(L);\n\tvar C = max / 100 * S;\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToHpluv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tif(L > 99.9999999) {\n\t\treturn [H,0,100];\n\t}\n\tif(L < 0.00000001) {\n\t\treturn [H,0,0];\n\t}\n\tvar max = hsluv.Hsluv.maxSafeChromaForL(L);\n\tvar S = C / max * 100;\n\treturn [H,S,L];\n};\nhsluv.Hsluv.rgbToHex = function(tuple) {\n\tvar h = \"#\";\n\tvar _g = 0;\n\twhile(_g < 3) {\n\t\tvar i = _g++;\n\t\tvar chan = tuple[i];\n\t\tvar c = Math.round(chan * 255);\n\t\tvar digit2 = c % 16;\n\t\tvar digit1 = (c - digit2) / 16 | 0;\n\t\th += hsluv.Hsluv.hexChars.charAt(digit1) + hsluv.Hsluv.hexChars.charAt(digit2);\n\t}\n\treturn h;\n};\nhsluv.Hsluv.hexToRgb = function(hex) {\n\thex = hex.toLowerCase();\n\tvar ret = [];\n\tvar _g = 0;\n\twhile(_g < 3) {\n\t\tvar i = _g++;\n\t\tvar digit1 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 1));\n\t\tvar digit2 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 2));\n\t\tvar n = digit1 * 16 + digit2;\n\t\tret.push(n / 255.0);\n\t}\n\treturn ret;\n};\nhsluv.Hsluv.lchToRgb = function(tuple) {\n\treturn hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));\n};\nhsluv.Hsluv.rgbToLch = function(tuple) {\n\treturn hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));\n};\nhsluv.Hsluv.hsluvToRgb = function(tuple) {\n\treturn hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));\n};\nhsluv.Hsluv.rgbToHsluv = function(tuple) {\n\treturn hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));\n};\nhsluv.Hsluv.hpluvToRgb = function(tuple) {\n\treturn hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));\n};\nhsluv.Hsluv.rgbToHpluv = function(tuple) {\n\treturn hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));\n};\nhsluv.Hsluv.hsluvToHex = function(tuple) {\n\treturn hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));\n};\nhsluv.Hsluv.hpluvToHex = function(tuple) {\n\treturn hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));\n};\nhsluv.Hsluv.hexToHsluv = function(s) {\n\treturn hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));\n};\nhsluv.Hsluv.hexToHpluv = function(s) {\n\treturn hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));\n};\nhsluv.Hsluv.m = [[3.240969941904521,-1.537383177570093,-0.498610760293],[-0.96924363628087,1.87596750150772,0.041555057407175],[0.055630079696993,-0.20397695888897,1.056971514242878]];\nhsluv.Hsluv.minv = [[0.41239079926595,0.35758433938387,0.18048078840183],[0.21263900587151,0.71516867876775,0.072192315360733],[0.019330818715591,0.11919477979462,0.95053215224966]];\nhsluv.Hsluv.refY = 1.0;\nhsluv.Hsluv.refU = 0.19783000664283;\nhsluv.Hsluv.refV = 0.46831999493879;\nhsluv.Hsluv.kappa = 903.2962962;\nhsluv.Hsluv.epsilon = 0.0088564516;\nhsluv.Hsluv.hexChars = \"0123456789abcdef\";\nvar root = {\n    \"hsluvToRgb\": hsluv.Hsluv.hsluvToRgb,\n    \"rgbToHsluv\": hsluv.Hsluv.rgbToHsluv,\n    \"hpluvToRgb\": hsluv.Hsluv.hpluvToRgb,\n    \"rgbToHpluv\": hsluv.Hsluv.rgbToHpluv,\n    \"hsluvToHex\": hsluv.Hsluv.hsluvToHex,\n    \"hexToHsluv\": hsluv.Hsluv.hexToHsluv,\n    \"hpluvToHex\": hsluv.Hsluv.hpluvToHex,\n    \"hexToHpluv\": hsluv.Hsluv.hexToHpluv,\n    \"lchToHpluv\": hsluv.Hsluv.lchToHpluv,\n    \"hpluvToLch\": hsluv.Hsluv.hpluvToLch,\n    \"lchToHsluv\": hsluv.Hsluv.lchToHsluv,\n    \"hsluvToLch\": hsluv.Hsluv.hsluvToLch,\n    \"lchToLuv\": hsluv.Hsluv.lchToLuv,\n    \"luvToLch\": hsluv.Hsluv.luvToLch,\n    \"xyzToLuv\": hsluv.Hsluv.xyzToLuv,\n    \"luvToXyz\": hsluv.Hsluv.luvToXyz,\n    \"xyzToRgb\": hsluv.Hsluv.xyzToRgb,\n    \"rgbToXyz\": hsluv.Hsluv.rgbToXyz,\n    \"lchToRgb\": hsluv.Hsluv.lchToRgb,\n    \"rgbToLch\": hsluv.Hsluv.rgbToLch\n};\n\nmodule.exports = root;\n","// @ts-check\n\n/** @template T\n * @typedef {(\n * | {value: T, err?: never}\n * | {err: Error, value?: never}\n * )} Result */\n\n/**\n * @template T\n * @param {Result<T>} res\n */\nexport function toValue({ err, value }) {\n  if (err) {\n    throw err;\n  } else {\n    return value;\n  }\n}\n\n/** @template T\n * @param {Result<T>} res\n * @returns {Promise<T>}\n */\nexport function toPromise({ err, value }) {\n  return err\n    ? Promise.reject(err)\n    : Promise.resolve(value);\n}\n\n/**\n * @template T\n * @param {T} value\n * @returns {Result<T>}\n */\nexport function just(value) {\n  return { value };\n}\n\n/**\n * @param {Error} err\n * @returns {Result<never>}\n */\nexport function error(err) {\n  return { err };\n}\n\n/**\n * @template T\n * @param {() => Result<T>} body\n * @returns {Result<T>}\n */\nexport function catchErr(body) {\n  try {\n    return body();\n  } catch (err) {\n    return error(err instanceof Error ? err : new Error(`${err}`));\n  }\n}\n\n/**\n * @template T\n * @param {(...args: any[]) => T} func\n * @returns {(...args: any[]) => Result<T>}\n */\nexport function lift(func) {\n  /** @this {any} */\n  return function rezultLifted(...args) {\n    return catchErr(() => just(func.apply(this, args)));\n  };\n}\n\n/**\n * @template T, S\n * @param {Result<T>} res\n * @param {(t: T) => Result<S>} next\n * @returns {Result<S>}\n */\nexport function bind(res, next) {\n  return res.err ? res : next(res.value);\n}\n","// @ts-check\n\nimport { hsluvToRgb } from 'hsluv';\n\nimport * as rezult from './rezult.js';\n\n/** A color tuple in some color space (e.g. rgb or hsl)\n *\n * @typedef {[a: number, b: number, c: number]} ColorTuple\n */\n\n/** A function which can generate N color tuples\n *\n * @typedef {(n: number) => IterableIterator<ColorTuple>} ColorGen\n */\n\n/** A factory for creating N-color generators for a given intensity level\n *\n * The view module currently uses these intensity levels for fixed roles:\n * 0: empty cells\n * 1: ant traced cells\n * 2: ant body\n * 3: ant head\n *\n * @typedef {object} ColorGenMaker\n * @prop {(intensity: number) => ColorGen} makeColorGen\n * @prop {() => string} toString\n */\n\n/** A family of N-color-generator factories, parameterized by 2 arguments\n *\n * Family implementations must provide argument defaults\n *\n * Family aguments are presumabley 2 fixed color space but not necessarily so...\n *\n * @typedef {(a?: number, b?: number) => ColorGenMaker} ColorGenFam2\n */\n\n/** @type {Map<string, ColorGenFam2>} */\nconst gens = new Map();\n\n/**\n * @param {string} str\n * @returns {rezult.Result<ColorGenMaker>}\n */\nexport default function parse(str) {\n  const match = /^(\\w+)(?:\\((.*)\\))?$/.exec(str);\n  if (!match) {\n    return rezult.error(new Error('invalid color spec'));\n  }\n\n  const name = match[1] || '';\n  const gen = gens.get(name);\n  if (!gen) {\n    const choices = Object.keys(gens).sort().join(', ');\n    return rezult.error(new Error(\n      `no such color scheme ${JSON.stringify(name)}, valid choices: ${choices}`\n    ));\n  }\n\n  const args = match[2] ? match[2].split(/, */) : [];\n  const a = args[0] ? parseInt(args[0], 10) : undefined;\n  const b = args[1] ? parseInt(args[1], 10) : undefined;\n\n  return rezult.just(gen(a, b));\n}\n\ngens.set('light', (hue = 0, sat = 100) => {\n  if (hue === 0) {\n    hue = 360;\n  }\n  return {\n    toString() {\n      return `light(${hue}, ${sat})`;\n    },\n    makeColorGen(intensity) {\n      const h = hue * (1 + (intensity - 1) / 3) % 360;\n      return function*(ncolors) {\n        const step = 100 / (ncolors + 1);\n        for (let i = 0, l = step; i < ncolors; l += step, i++) {\n          yield hsluvToRgb([h, sat, l]);\n        }\n      };\n    },\n  };\n});\n\ngens.set('hue', (sat = 70, light = 40) => {\n  const satDelta = sat > 70 ? -10 : 10;\n  const lightDelta = light > 70 ? -10 : 10;\n  return {\n    toString() {\n      return `hue(${sat}, ${light})`;\n    },\n    makeColorGen(intensity) {\n      const mySat = sat + satDelta * intensity;\n      const myLight = light + lightDelta * intensity;\n      return function*(ncolors) {\n        const step = 360 / ncolors;\n        for (let i = 0, h = 0; i < ncolors; h += step, i++) {\n          yield [h, mySat, myLight];\n        }\n      };\n    },\n  };\n});\n\n// TODO: implement a 'hsluv' family\n","// @ts-check\n\n/**\n * @template {abstract new(...args: any[]) => any} T\n * @param {HTMLElement} el\n * @param {string} selector\n * @param {T} type\n * @returns {InstanceType<T>}\n */\nexport function mustQuery(el, selector, type) {\n  const res = el.querySelector(selector);\n  if (!res) {\n    throw new Error(`unable to find a ${selector}`);\n  }\n  if (!(res instanceof type)) {\n    throw new Error(`invalid ${selector} element, must be a ${type.name} instance`);\n  }\n  return /** @type {InstanceType<T>} */ (res);\n}\n\n/**\n * @template {abstract new(...args: any[]) => any} T\n * @param {HTMLElement} el\n * @param {string} selector\n * @param {T} type\n * @returns {InstanceType<T>|null}\n */\nexport function mayQuery(el, selector, type) {\n  const res = el.querySelector(selector);\n  if (!res) {\n    return null;\n  }\n  if (!(res instanceof type)) {\n    throw new Error(`invalid ${selector} element, must be a ${type.name} instance`);\n  }\n  return /** @type {InstanceType<T>} */ (res);\n}\n","// @ts-check\n\nimport * as rezult from './rezult.js';\n\n/** @param {Window} window */\nexport default function makeHash(window) {\n  const codecs = makeCodecSuite();\n\n  codecs.addCodec('', {\n    encodeKeys(keyvals) {\n      const parts = [];\n      for (const [key, val] of keyvals) {\n        let part = encodeURIComponent(key);\n        if (val !== undefined && val !== '') {\n          part += '=' + encodeURIComponent(val);\n        }\n        parts.push(part);\n      }\n      return parts.join('&');\n    },\n    *decodeKeys(str) {\n      for (const part of str.split('&')) {\n        let [key, val] = part.split('=');\n        key = decodeURIComponent(key || '');\n        val = decodeURIComponent(val || '');\n        if (key) {\n          yield [key, val];\n        }\n      }\n    },\n  });\n\n  codecs.addCodec('b64:', {\n    encode: btoa,\n    decode: atob,\n    // TODO direct key codec is possible, no need to url-escape under base64\n  });\n\n  /** @type {Map<string, string>} */\n  const cache = new Map();\n\n  /** @type {Map<string, any>} */\n  const values = new Map();\n\n  /** @type {Map<string, any>} */\n  const defaults = new Map();\n\n  /** @type {Map<string, (s: string) => rezult.Result<any>>} */\n  const parsers = new Map();\n\n  /** @type {Map<string, (val: any) => (string|undefined)>} */\n  const stringers = new Map();\n\n  /** @type {Map<string, Array<(val: any) => void>>} */\n  const listeners = new Map();\n\n  let last = '';\n  let loaded = false;\n\n  window.addEventListener('hashchange', () => reload());\n\n  function reload(hash = window.location.hash) {\n    if (loaded && hash !== last) {\n      load(hash);\n    }\n  }\n\n  function load(hash = window.location.hash) {\n    const resave = loadValues(hash);\n    last = hash;\n    if (resave) {\n      save();\n    }\n  }\n\n  function save() {\n    let hash = codecs.encode(cache.entries());\n    if (hash) {\n      hash = '#' + hash;\n    }\n    if (hash !== last) {\n      last = hash;\n      window.location.hash = hash;\n    }\n  }\n\n  /** @param {string} hash */\n  function loadValues(hash) {\n    let resave = false;\n    /** @type Set<string> */\n    const seen = new Set();\n    /** @type {{key: string, value: any}[]} */\n    const toNotify = [];\n\n    for (const [key, str] of codecs.decode(hash.slice(1))) {\n      seen.add(key);\n      if (cache.get(key) !== str) {\n        cache.set(key, str);\n        toNotify.push({ key, value: loadBinding(key) });\n      }\n    }\n\n    for (const [key, value] of defaults.entries()) {\n      if (!seen.has(key)) {\n        seen.add(key);\n        if (values.get(key) !== value) {\n          if (value === undefined) {\n            values.delete(key);\n            cache.delete(key);\n          } else {\n            values.set(key, value);\n            const stringer = stringers.get(key) || valueToString;\n            const str = stringer(value);\n            if (str !== undefined) {\n              cache.set(key, str);\n            } else {\n              cache.delete(key);\n            }\n          }\n          toNotify.push({ key, value });\n          resave = true;\n        }\n      }\n    }\n\n    for (const key of cache.keys()) {\n      if (!seen.has(key)) {\n        seen.add(key);\n        cache.delete(key);\n        values.delete(key);\n        toNotify.push({ key, value: defaults.get(key) });\n        resave = true;\n      }\n    }\n\n    for (const { key, value } of toNotify) {\n      notifyBinding(key, value);\n    }\n\n    loaded = true;\n    return resave;\n  }\n\n  /** @param {string} key */\n  function loadBinding(key) {\n    const str = cache.get(key);\n    if (str === undefined) {\n      return defaults.get(key);\n    }\n\n    const parser = parsers.get(key) || parseValue;\n\n    let { err, value } = parser(str);\n    if (err) {\n      // intentionally ignore parse error; best-effort load\n      return;\n    }\n\n    if (values.get(key) !== value) {\n      if (value === undefined) {\n        values.delete(key);\n      } else {\n        values.set(key, value);\n      }\n    }\n\n    if (value === undefined) {\n      return defaults.get(key);\n    }\n\n    return value;\n  }\n\n  /** @param {string} key */\n  function saveBinding(key, value = values.get(key)) {\n    const stringer = stringers.get(key) || valueToString;\n    const str = stringer(value);\n    if (cache.get(key) !== str) {\n      if (str === undefined) {\n        cache.delete(key);\n      } else {\n        cache.set(key, str);\n      }\n      save();\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   */\n  function notifyBinding(key, value) {\n    for (const fn of listeners.get(key) || []) {\n      fn(value);\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} val\n   */\n  function parseBindingValue(key, val) {\n    if ((val === null || val === undefined) && defaults.has(key)) {\n      val = defaults.get(key);\n    }\n    let res = rezult.just(val);\n    /** @type {string|undefined} */\n    let str = '';\n    if (typeof val === 'string') {\n      const parser = parsers.get(key) || parseValue;\n      res = parser(val), str = val;\n    } else {\n      const stringer = stringers.get(key) || valueToString;\n      str = stringer(val);\n    }\n    return { res, str };\n  }\n\n  /**\n   * @param {any} val\n   * @returns {string|undefined}\n   */\n  function valueToString(val) {\n    if (val === false) {\n      return undefined;\n    }\n    if (val === true) {\n      return '';\n    }\n    return '' + val;\n  }\n\n  /**\n   * @param {string} str\n   * @returns {rezult.Result<any>}\n   */\n  function parseValue(str) {\n    if (str === '' || str === 'true') {\n      return rezult.just(true);\n    }\n    if (str === 'false') {\n      return rezult.just(false);\n    }\n    if (str === 'null') {\n      return rezult.just(null);\n    }\n    return rezult.just(str);\n  }\n\n  return {\n    get encoding() {\n      return codecs.defaultEncoding;\n    },\n    set encoding(enc) {\n      codecs.defaultEncoding = enc;\n      save();\n    },\n\n    /** @template T\n     * @param {string} key\n     * @param {object} params\n     * @param {T} params.defaultValue\n     * @param {(val: T) => void} params.listener\n     * @param {(str: string) => rezult.Result<T>} [params.parse]\n     * @param {(val: T) => string|undefined} [params.stringer]\n     */\n    bind(key, {\n      parse = parseValue,\n      stringer = valueToString,\n      listener,\n      defaultValue,\n    }) {\n      if (typeof defaultValue === 'string') {\n        defaultValue = rezult.toValue(parse(defaultValue));\n      }\n      parsers.set(key, parse);\n      stringers.set(key, stringer);\n      defaults.set(key, defaultValue);\n      if (listener) {\n        listeners.set(key, [listener]);\n      } else {\n        listeners.delete(key);\n      }\n\n      if (loaded) {\n        const value = loadBinding(key);\n        saveBinding(key, value);\n        notifyBinding(key, value);\n      }\n    },\n\n    load,\n\n    /** @param {string} key */\n    getStr(key) {\n      const prior = cache.get(key);\n      if (prior !== undefined) {\n        return prior;\n      }\n\n      const defaultValue = defaults.get(key);\n      if (defaultValue !== undefined && typeof defaultValue !== 'string') {\n        const stringer = stringers.get(key) || valueToString;\n        const defaultString = stringer(defaultValue);\n        if (defaultString !== undefined) {\n          return defaultString;\n        }\n      }\n\n      return '';\n    },\n\n    /** @param {string} key */\n    get(key) {\n      return values.get(key);\n    },\n\n    /**\n     * @param {string} key\n     * @param {any} val\n     */\n    set(key, val) {\n      const r = parseBindingValue(key, val);\n      const { res: { err, value } } = r;\n      if (!err && values.get(key) !== value) {\n        values.set(key, value);\n        saveBinding(key, value);\n        notifyBinding(key, value);\n      }\n      return r;\n    },\n\n    [Symbol.iterator]() {\n      return values.entries();\n    },\n\n    stringEntries() {\n      return cache.entries();\n    },\n\n  };\n}\n\nfunction makeCodecSuite() {\n\n  /** @type {string[]} */\n  let defaultEncoding = [];\n\n  /** @type {Map<string, (s: string) => string>} */\n  const encoders = new Map();\n\n  /** @type {Map<string, (s: string) => string>} */\n  const decoders = new Map();\n\n  /** @type {Map<string, (keyvals: Iterable<[key: string, val: string]>) => string>} */\n  const keyEncoders = new Map();\n\n  /** @type {Map<string, (s: string) => IterableIterator<[key: string, val: string]>>} */\n  const keyDecoders = new Map();\n\n  /**\n   * @param {Iterable<[key: string, val: string]>} keyvals\n   * @returns {string}\n   */\n  function encode(keyvals) {\n    let encoded = '';\n\n    let i = 0;\n\n    // if the first encoder can directly handle keys, let it; otherwise,\n    // fallback to a base key encoder, and proceed to the wrapping phase\n    const firstKey = defaultEncoding[i];\n    let firstEnc = firstKey && keyEncoders.get(firstKey);\n    if (firstEnc) {\n      encoded = firstKey + firstEnc(keyvals);\n      i++;\n    } else {\n      firstEnc = keyEncoders.get('');\n      if (!firstEnc) {\n        throw new Error('no default keyEncoder available!');\n      }\n      encoded = firstEnc(keyvals);\n    }\n\n    // apply any number of wrapped string encodings\n    for (; i < defaultEncoding.length; i++) {\n      const key = defaultEncoding[i];\n      const enc = key && encoders.get(key);\n      if (enc) {\n        encoded = key + enc(encoded);\n      } else {\n        break;\n      }\n    }\n\n    return encoded;\n  }\n\n  /**\n   * @param {string} str\n   * @returns {IterableIterator<[key: string, val: string]>}\n   */\n  function decode(str) {\n    const orig = str;\n    round: for (let sanity = 100; sanity-- > 0;) {\n      // prefer to decode directly into final keyvals when possible\n      for (const [key, decoder] of keyDecoders) {\n        if (str.startsWith(key)) {\n          return decoder(str.slice(key.length));\n        }\n      }\n      // intermediate string encoding\n      for (const [key, decoder] of decoders) {\n        if (str.startsWith(key)) {\n          str = decoder(str.slice(key.length));\n          continue round;\n        }\n      }\n      // exhausted all possible decoders, unable to progress\n      break;\n    }\n    if (str === orig) {\n      throw new Error(`unable to decode: ${JSON.stringify(str)}`);\n    } else {\n      throw new Error(`unable to decode: ${JSON.stringify(str)}, original form: ${JSON.stringify(orig)}`);\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {object} codec\n   * @param {(s: string) => string} [codec.encode]\n   * @param {(s: string) => string} [codec.decode]\n   * @param {(keyvals: Iterable<[key: string, val: string]>) => string} [codec.encodeKeys]\n   * @param {(s: string) => IterableIterator<[key: string, val: string]>} [codec.decodeKeys]\n   */\n  function addCodec(key, { encode, decode, encodeKeys, decodeKeys }) {\n    if (encode) {\n      encoders.set(key, encode);\n    }\n    if (decode) {\n      decoders.set(key, decode);\n    }\n    if (encodeKeys) {\n      keyEncoders.set(key, encodeKeys);\n    }\n    if (decodeKeys) {\n      keyDecoders.set(key, decodeKeys);\n    }\n  }\n\n  return {\n    get defaultEncoding() {\n      switch (defaultEncoding.length) {\n        case 0:\n          return '';\n        case 1:\n          return defaultEncoding[0] || '';\n        default:\n          return defaultEncoding.join('');\n      }\n    },\n    set defaultEncoding(enc) {\n      const encs = [];\n      let rem = enc;\n      parse: while (rem.length) {\n        for (const key of encoders.keys()) {\n          if (rem.startsWith(key)) {\n            encs.push(key);\n            rem = rem.slice(key.length);\n            continue parse;\n          }\n        }\n        throw new Error(`invalid encoding ${JSON.stringify(rem)} in ${JSON.stringify(enc)}`);\n      }\n      defaultEncoding = encs;\n    },\n\n    addCodec,\n\n    encode,\n    decode,\n  };\n}\n","// @ts-check\n\nimport { mayQuery } from './domkit.js';\n\n/** @template T\n * @typedef {Generator<Output[], T, Input[]>} Interactor\n */\n\n/** @template T\n * @typedef {(inputs: Input[]) => Generator<Output, T|undefined>} Looper\n */\n\n/** @typedef {(\n * | {value: string}\n * | {command: string}\n * )} Input */\n\n/** @typedef {(\n * | {title: string}\n * | {value: string}\n * | {help: string|Iterable<string>}\n * | {error: string}\n * | {command: string, label?: string}\n * )} Output */\n\n/** @typedef {(...args: string[]) => Iterable<Output>} Command */\n\n/**\n * @template T\n * @param {() => HTMLElement} makeEl\n * @param {Interactor<T>} tor\n */\nexport async function runPrompt(makeEl, tor) {\n  const $el = makeEl();\n  try {\n    return await prompt($el, tor);\n  } finally {\n    $el.parentNode?.removeChild($el);\n  }\n}\n\n/** @template T\n * @param {HTMLElement} $body\n * @param {Interactor<T>} tor\n * @returns {Promise<T|undefined>}\n */\nexport async function prompt($body, tor) {\n  /** @typedef {(\n   * | {value: string}\n   * | {command: string}\n   * | {canceled: true}\n   * )} Response */\n\n  const handleEvents = ['click', 'keydown', 'keyup'];\n\n  /** @type {((res: Response) => void)} */\n  let callback = () => { };\n\n  function makeHeader() {\n    let $header = mayQuery($body, 'h1', HTMLHeadingElement);\n    if (!$header) {\n      $header = $body.insertBefore(\n        $body.ownerDocument.createElement('h1'),\n        $body.firstElementChild);\n    }\n    return $header;\n  }\n\n  function makeText() {\n    let $text = mayQuery($body, '#text', HTMLTextAreaElement);\n    if (!$text) {\n      $text = $body.appendChild(\n        $body.ownerDocument.createElement('textarea'));\n      $text.id = 'text';\n    }\n    return $text;\n  }\n\n  function makeHelp() {\n    let $help = mayQuery($body, '#help', HTMLElement);\n    if (!$help) {\n      $help = $body.appendChild(\n        $body.ownerDocument.createElement('div'));\n      $help.id = 'help';\n      $help.classList.add('help');\n    }\n    return $help;\n  }\n\n  function makeError() {\n    let $error = mayQuery($body, '#error', HTMLElement);\n    if (!$error) {\n      $error = $body.appendChild(\n        $body.ownerDocument.createElement('div'));\n      $error.id = 'error';\n      $error.classList.add('error');\n    }\n    return $error;\n  }\n\n  /**\n   * @param {object} options\n   * @param {string} options.id\n   * @param {string} options.label\n   * @param {string} [options.title]\n   */\n  function makeButton({ id, label, title }) {\n    let $btn = mayQuery($body, `button[id=\"${id}\"]`, HTMLButtonElement);\n    if (!$btn) {\n      $btn = $body.appendChild(\n        $body.ownerDocument.createElement('button'));\n      $btn.id = id;\n    }\n    $btn.innerText = label;\n    $btn.title = title || '';\n    return $btn;\n  }\n\n  function resetOutputElements() {\n    const $header = mayQuery($body, 'h1', HTMLHeadingElement);\n    if ($header) {\n      $header.style.display = 'none';\n      $header.innerText = '';\n    }\n\n    const $text = mayQuery($body, '#text', HTMLTextAreaElement);\n    if ($text) {\n      $text.value = '';\n      $text.rows = 1;\n    }\n\n    const $help = mayQuery($body, '#help', HTMLElement);\n    if ($help) {\n      $help.style.display = 'none';\n      $help.innerText = '';\n    }\n\n    const $error = mayQuery($body, '#error', HTMLElement);\n    if ($error) {\n      $error.style.display = 'none';\n      $error.innerText = '';\n    }\n  }\n\n  function resizeTextRows() {\n    let $text = mayQuery($body, '#text', HTMLTextAreaElement);\n    if ($text) {\n      const lines = $text.value.split(/\\n/);\n      $text.rows = lines.length + 1;\n    }\n  }\n\n  let lastEnter = 0;\n\n  /** @param {Event} e */\n  function handleEvent(e) {\n    switch (e.type) {\n\n      case 'click':\n        {\n          const { target } = e;\n          if (target && target instanceof HTMLButtonElement) {\n            const { command } = target.dataset;\n            if (command) {\n              e.preventDefault();\n              callback({ command });\n            }\n          }\n        }\n        break;\n\n      case 'keydown':\n        if (e instanceof KeyboardEvent) {\n          switch (e.key) {\n\n            case 'Enter':\n              const $text = mayQuery($body, '#text', HTMLTextAreaElement);\n              if ($text && e.target === $text) {\n                if (e.ctrlKey) {\n                  e.preventDefault();\n                }\n              }\n              break;\n\n            case 'Escape':\n              e.preventDefault();\n              callback({ canceled: true });\n              return;\n\n          }\n          resizeTextRows();\n        }\n        break;\n\n      case 'keyup':\n        if (e instanceof KeyboardEvent) {\n          switch (e.key) {\n\n            case 'Enter':\n              const $text = mayQuery($body, '#text', HTMLTextAreaElement);\n              if ($text && e.target === $text) {\n                if (Date.now() - lastEnter < 1000 || e.ctrlKey) {\n                  e.preventDefault();\n                  callback({ value: $text ? $text.value.replace(/(?:\\r?\\n)+$/, '') : '' });\n                  return;\n                }\n                lastEnter = Date.now();\n              }\n              break;\n\n            default:\n              lastEnter = 0;\n\n          }\n          resizeTextRows();\n        }\n        break;\n\n    }\n  }\n\n  const _canceled = new Object();\n  try {\n    $body.style.display = '';\n    for (const event of handleEvents)\n      $body.addEventListener(event, handleEvent);\n\n    /** @type {Input[]} */\n    let inputs = [];\n    for (; ;) {\n\n      { // tick tor\n        const { done, value } = tor.next(inputs);\n        if (done) { return value }\n        const outputs = value;\n\n        resetOutputElements();\n\n        /** @type {WeakSet<HTMLButtonElement>} */\n        const activeButtons = new WeakSet();\n\n        for (const output of outputs) {\n          if ('title' in output) {\n            const { title } = output;\n            const $header = makeHeader();\n            $header.innerText = title;\n            $header.style.display = '';\n          }\n\n          else if ('value' in output) {\n            const { value } = output;\n            const $text = makeText();\n            $text.value = value;\n            resizeTextRows();\n            $text.select();\n            $text.focus();\n          }\n\n          else if ('error' in output) {\n            const { error } = output;\n            if (error) {\n              const $error = makeError();\n              $error.innerText = error;\n              $error.style.display = '';\n            }\n          }\n\n          else if ('help' in output) {\n            const { help } = output;\n            if (help) {\n              const $help = makeHelp();\n              $help.innerText += typeof help == 'string' ? terminate(help) : coalesce(help);\n              $help.style.display = '';\n            }\n          }\n\n          else if ('command' in output) {\n            const { command, label = command } = output;\n            const id = `${$body.id}$${command}`;\n            const $btn = makeButton({ id, label });\n            $btn.dataset['command'] = command;\n            activeButtons.add($btn);\n          }\n\n          else assertNever(output, 'unimplemented');\n        }\n\n        for (const $btn of $body.querySelectorAll('button')) {\n          if (!activeButtons.has($btn)) {\n            $body.removeChild($btn);\n          }\n        }\n      }\n\n      { // wait for user\n        inputs = [];\n        const res = await /** @type {Promise<Response>} */ (\n          new Promise(resolve => callback = resolve));\n        callback = () => { };\n        if ('canceled' in res) { throw _canceled }\n        else inputs.push(res);\n      }\n    }\n  } catch (e) {\n    if (e !== _canceled) throw e;\n    return undefined;\n  } finally {\n    for (const event of handleEvents)\n      $body.removeEventListener(event, handleEvent);\n    $body.style.display = 'none';\n    while ($body.lastChild) $body.removeChild($body.lastChild);\n  }\n}\n\n/** @param {Iterable<string>} strs */\nfunction coalesce(strs, sep = '\\n') {\n  let out = '';\n  for (const str of strs) {\n    out += terminate(str, sep);\n  }\n  return out;\n}\n\n/** @param {string} str */\nfunction terminate(str, end = '\\n') {\n  return str.endsWith(end) ? str : `${str}${end}`;\n}\n\n/** @template T\n * @param {Looper<T>[]} loopers\n * @returns {Interactor<T>}\n */\nexport function loop(...loopers) {\n  const body = firstLooper(...loopers);\n  return function*() {\n    let { values: outputs, value } = collectIt(body([]));\n    while (value === undefined) {\n      const inputs = yield outputs;\n      ({ values: outputs, value } = collectIt(body(inputs)));\n    }\n    return value;\n  }();\n}\n\n/** @template T\n * @param {Looper<T>[]} loopers\n * @returns {Looper<T>}\n */\nfunction firstLooper(...loopers) {\n  switch (loopers.length) {\n    case 0:\n      return function*() { return undefined };\n    case 1:\n      return loopers[0];\n  }\n  return function*(inputs) {\n    for (const looper of loopers) {\n      const gen = looper(inputs);\n      const { done, value: first } = gen.next();\n\n      // looper produces output, so the rest don't get a shot this round\n      if (!done) {\n        yield first;\n        return yield* gen;\n      }\n\n      // looper returned a final result, we'll take it!\n      if (first !== undefined) {\n        return first;\n      }\n    }\n\n    // we'll have to do this all again with a different batch of inputs\n    return undefined;\n  };\n}\n\n/** @template V, R\n * @param {Iterator<V, R>} it\n */\nfunction collectIt(it) {\n  /** @type {V[]} */\n  const values = [];\n  for (; ;) {\n    const { done, value } = it.next();\n    if (done) { return { values, value } }\n    values.push(value);\n  }\n}\n\n/**\n * @param {never} impossible\n * @param {string} mess\n */\nfunction assertNever(impossible, mess) {\n  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);\n}\n","// @ts-check\n\n/* TODO:\n * - evaluate online sorting\n * - improve anomaly scoring\n * - better consider all the marking stuff in context of its use case\n * - maybe split out the marking stuff, and combine it with its use case\n *   around animation throttling into a separate subclass\n */\n\n// TODO recall what the point / idea of TIGHT_TOL and subsequent mode switching\n// under classifyAnomalies\nconst TIGHT_TOL = 0.1;\n\nexport class Sample {\n\n  /** @param {number} n */\n  constructor(n) {\n    this.n = n;\n    /** @type {number[]} */\n    this.data = [];\n    this.lastMark = 0;\n    this.markWeight = 1;\n  }\n\n  // TODO sort out and document the semantics of marking and weight\n\n  mark() {\n    this.markWeight = 1;\n    this.lastMark = this.data.length;\n  }\n\n  /** @param {number} weight */\n  weightedMark(weight) {\n    if (this.lastMark > 0) {\n      this.markWeight *= weight;\n    }\n    this.lastMark = this.data.length;\n  }\n\n  sinceWeightedMark() {\n    return (this.data.length - this.lastMark) / this.markWeight;\n  }\n\n  sinceMark() {\n    return this.data.length - this.lastMark;\n  }\n\n  reset() {\n    this.data.length = 0;\n    this.lastMark = 0;\n    this.markWeight = 1;\n  }\n\n  complete() {\n    return this.data.length >= this.n;\n  }\n\n  /** @param {number} datum */\n  collect(datum) {\n    while (this.data.length >= this.n) {\n      this.data.shift();\n    }\n    this.data.push(datum);\n    if (this.lastMark > 0) {\n      if (--this.lastMark === 0) {\n        this.markWeight = 1;\n      }\n    }\n  }\n\n  classifyAnomalies() {\n    const q = this.quantileSelector();\n    const q25 = q(0.25), q50 = q(0.50), q75 = q(0.75);\n    const iqr = q75 - q25;\n    const { data } = this;\n\n    // TODO what is this?\n    if (iqr / q50 < TIGHT_TOL) {\n      return data.map(\n        datum => datum / q50 - 1\n      );\n    }\n\n    // const lh = q50 - q25;\n    // const rh = q75 - q50;\n    // const skew = (rh - lh) / iqr;\n\n    const tol = iqr * 1.5;\n    const lo = q25 - tol;\n    const hi = q75 + tol;\n\n    return data.map(datum => {\n      if (datum < lo) {\n        return (datum - lo) / iqr;\n      } else if (datum > hi) {\n        return (datum - hi) / iqr;\n      } else {\n        return 0;\n      }\n    });\n  }\n\n  /** @returns {(q: number) => number} */\n  quantileSelector() {\n    // TODO when is a cleverer data structure / algo worth?\n    const S = [...this.data];\n    S.sort((a, b) => a - b);\n    return q => {\n      const i = q * S.length;\n      // @ts-ignore proven by S.length bound in prior line\n      return S[Math.floor(i)] / 2 + S[Math.ceil(i)] / 2;\n    }\n  }\n}\n","// @ts-check\n\nexport class ScreenPoint {\n  /**\n   * @param {number} [x]\n   * @param {number} [y]\n   */\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  type = 'point.screen'\n\n  copy() {\n    return new ScreenPoint(this.x, this.y);\n  }\n\n  /** @param {ScreenPoint} other */\n  copyFrom(other) {\n    this.x = other.x;\n    this.y = other.y;\n    return this;\n  }\n\n  toString() {\n    return `ScreenPoint(${this.x}, ${this.y});`\n  }\n\n  /** @param {ScreenPoint} screenPoint */\n  toScreenInto(screenPoint) {\n    screenPoint.x = this.x;\n    screenPoint.y = this.y;\n    return screenPoint;\n  }\n\n  toScreen() {\n    return this;\n  }\n\n  /** @param {number} n */\n  scale(n) {\n    this.x *= n;\n    this.y *= n;\n    return this;\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  mulBy(x, y) {\n    this.x *= x;\n    this.y *= y;\n    return this;\n  }\n\n  /** @param {ScreenPoint} other */\n  add(other) {\n    if (other.type !== this.type) {\n      other = other.toScreen();\n    }\n    this.x += other.x;\n    this.y += other.y;\n    return this;\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  addTo(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  /** @param {ScreenPoint} other */\n  sub(other) {\n    if (other.type !== this.type) {\n      other = other.toScreen();\n    }\n    this.x -= other.x;\n    this.y -= other.y;\n    return this;\n  }\n}\n\nexport class CubePoint {\n  /**\n   * @param {number} [x]\n   * @param {number} [y]\n   * @param {number} [z]\n   */\n  constructor(x = 0, y = 0, z = 0) {\n    if (x + y + z !== 0) {\n      throw new Error(`CubePoint invariant violated: ${x} + ${y} + ${z} = ${x + y + z}`);\n    }\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  type = 'point.cube'\n\n  toString() {\n    return `CubePoint(${this.x}, ${this.y}, ${this.z})`;\n  }\n\n  copy() {\n    return new CubePoint(this.x, this.y, this.z);\n  }\n\n  /** @param {CubePoint} other */\n  copyFrom(other) {\n    if (other.type !== this.type) {\n      return other.toCubeInto(this);\n    }\n    this.x = other.x;\n    this.y = other.y;\n    this.z = other.z;\n    return this;\n  }\n\n  /** @param {CubePoint} other */\n  add(other) {\n    if (other.type !== this.type) {\n      other = other.toCube();\n    }\n    this.x += other.x;\n    this.y += other.y;\n    this.z += other.z;\n    return this;\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  addTo(x, y, z) {\n    this.x += x;\n    this.y += y;\n    this.z += z;\n    return this;\n  }\n\n  /** @param {CubePoint} other */\n  sub(other) {\n    if (other.type !== this.type) {\n      other = other.toCube();\n    }\n    this.x -= other.x;\n    this.y -= other.y;\n    this.z -= other.z;\n    return this;\n  }\n\n  /**\n   * @param {number} n\n   */\n  scale(n) {\n    this.x *= n;\n    this.y *= n;\n    this.z *= n;\n    return this;\n  }\n\n  /**\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  mulBy(x, y, z) {\n    this.x *= x;\n    this.y *= y;\n    this.z *= z;\n    return this;\n  }\n\n  /** @param {ScreenPoint} screenPoint */\n  toScreenInto(screenPoint) {\n    screenPoint.x = 3 / 2 * this.x;\n    screenPoint.y = Math.sqrt(3) * (this.z + this.x / 2);\n    return screenPoint;\n  }\n\n  toScreen() {\n    return this.toScreenInto(new ScreenPoint());\n  }\n\n  /** @param {CubePoint} other */\n  toCubeInto(other) {\n    other.x = this.x;\n    other.y = this.y;\n    other.z = this.z;\n    return other;\n  }\n\n  toCube() {\n    return this;\n  }\n\n  toOddQOffset() {\n    const q = this.x;\n    const r = this.z + (this.x - (this.x & 1)) / 2;\n    return new OddQOffset(q, r);\n  }\n\n  /** @param {OddQOffset} oqo */\n  toOddQOffsetInto(oqo) {\n    oqo.q = this.x;\n    oqo.r = this.z + (this.x - (this.x & 1)) / 2;\n  }\n\n  static basis = [\n    new CubePoint(1, -1, 0), // SE -- 0, 1\n    new CubePoint(0, -1, 1), // S  -- 1, 2\n    new CubePoint(-1, 0, 1), // SW -- 2, 3\n    new CubePoint(-1, 1, 0), // NW -- 3, 4\n    new CubePoint(0, 1, -1), // N  -- 4, 5\n    new CubePoint(1, 0, -1)  // NE -- 5, 0\n  ]\n}\n\n/**\n * @typedef {object} oddQPotent\n * @prop {(oqo: OddQOffset) => void} toOddQOffsetInto\n */\n\n/**\n * @typedef {object} oddQToable\n * @prop {() => OddQOffset} toOddQOffset\n */\n\nexport class OddQOffset {\n  /**\n   * @param {number} [q]\n   * @param {number} [r]\n   */\n  constructor(q = 0, r = 0) {\n    this.q = q;\n    this.r = r;\n  }\n\n  type = 'offset.odd-q'\n\n  toString() {\n    return `OddQOffset(${this.q}, ${this.r})`;\n  }\n\n  copy() {\n    return new OddQOffset(this.q, this.r);\n  }\n\n  /** @param {oddQPotent} other */\n  copyFrom(other) {\n    other.toOddQOffsetInto(this);\n    return this;\n  }\n\n  /** @param {OddQOffset|oddQToable} other */\n  add(other) {\n    if (other instanceof OddQOffset) {\n      const { q, r } = other;\n      this.q += q, this.r += r;\n    } else {\n      const { q, r } = other.toOddQOffset();\n      this.q += q, this.r += r;\n    }\n    return this;\n  }\n\n  /**\n   * @param {number} q\n   * @param {number} r\n   */\n  addTo(q, r) {\n    this.q += q;\n    this.r += r;\n    return this;\n  }\n\n  /** @param {OddQOffset|oddQToable} other */\n  sub(other) {\n    if (other instanceof OddQOffset) {\n      const { q, r } = other;\n      this.q -= q, this.r -= r;\n    } else {\n      const { q, r } = other.toOddQOffset();\n      this.q -= q, this.r -= r;\n    }\n    return this;\n  }\n\n  /**\n   * @param {number} n\n   */\n  scale(n) {\n    this.q *= n;\n    this.r *= n;\n    return this;\n  }\n\n  /**\n   * @param {number} q\n   * @param {number} r\n   */\n  mulBy(q, r) {\n    this.q *= q;\n    this.r *= r;\n    return this;\n  }\n\n  /** @param {ScreenPoint} screenPoint */\n  toScreenInto(screenPoint) {\n    screenPoint.x = 3 / 2 * this.q;\n    screenPoint.y = Math.sqrt(3) * (this.r + 0.5 * (this.q & 1));\n    return screenPoint;\n  }\n\n  toScreen() {\n    return this.toScreenInto(new ScreenPoint());\n  }\n\n  toOddQOffset() {\n    return this;\n  }\n\n  /** @param {OddQOffset} oqo */\n  toOddQOffsetInto(oqo) {\n    oqo.q = this.q;\n    oqo.r = this.r;\n  }\n\n  /** @param {CubePoint} cubePoint */\n  toCubeInto(cubePoint) {\n    cubePoint.x = this.q;\n    cubePoint.z = this.r - (this.q - (this.q & 1)) / 2;\n    cubePoint.y = -cubePoint.x - cubePoint.z;\n    return cubePoint;\n  }\n\n  toCube() {\n    return this.toCubeInto(new CubePoint());\n  }\n}\n\n/**\n * @typedef {{toOddQOffset: () => OddQOffset}} OddQOffsetIsh\n */\n\nexport class OddQBox {\n  /**\n   * @param {OddQOffsetIsh} [topLeft]\n   * @param {OddQOffsetIsh} [bottomRight]\n   */\n  constructor(topLeft = new OddQOffset(), bottomRight = new OddQOffset()) {\n    this.topLeft = topLeft.toOddQOffset();\n    this.bottomRight = bottomRight.toOddQOffset();\n  }\n\n  copy() {\n    return new OddQBox(this.topLeft.copy(), this.bottomRight.copy());\n  }\n\n  /** @param {OddQBox} other */\n  copyFrom(other) {\n    this.topLeft.copyFrom(other.topLeft);\n    this.bottomRight.copyFrom(other.bottomRight);\n    return this;\n  }\n\n  toString() {\n    return 'OddQBox(' +\n      this.topLeft.toString() + ', ' +\n      this.bottomRight.toString() + ')';\n  }\n\n  screenCount() {\n    return this.screenCountInto(new ScreenPoint());\n  }\n\n  /** @param {ScreenPoint} screenPoint */\n  screenCountInto(screenPoint) {\n    const W = this.bottomRight.q - this.topLeft.q;\n    const H = this.bottomRight.r - this.topLeft.r;\n\n    // return the count number of hexes needed in screen x space and screen y\n    // space\n\n    // first one is a unit, each successive column backs 1/4 with the last\n    // const x = 1 + 3 / 4 * (W - 1);\n    screenPoint.x = (3 * W + 1) / 4;\n\n    // height backs directly, but we need an extra half cell except when we\n    // have only one column\n    screenPoint.y = H + (W > 1 ? 0.5 : 0);\n\n    return screenPoint;\n  }\n\n  /** @param {OddQOffsetIsh} pointArg */\n  contains(pointArg) {\n    const point = pointArg.toOddQOffset();\n    return point.q >= this.topLeft.q && point.q < this.bottomRight.q &&\n      point.r >= this.topLeft.r && point.r < this.bottomRight.r;\n  }\n\n  /** @param {OddQOffsetIsh} pointArg */\n  expandTo(pointArg) {\n    let expanded = false;\n    const point = pointArg.toOddQOffset();\n\n    if (point.q < this.topLeft.q) {\n      this.topLeft.q = point.q;\n      expanded = true;\n    } else if (point.q >= this.bottomRight.q) {\n      this.bottomRight.q = point.q + 1;\n      expanded = true;\n    }\n\n    if (point.r < this.topLeft.r) {\n      this.topLeft.r = point.r;\n      expanded = true;\n    } else if (point.r >= this.bottomRight.r) {\n      this.bottomRight.r = point.r + 1;\n      expanded = true;\n    }\n\n    return expanded;\n  }\n}\n","// @ts-check\n\n/** @enum {number} - resultant turn bits in a Rules table */\nexport const Turn = {\n  // relative turns\n  //    F -- +0 -- no turn, forward\n  //    B -- +3 -- u turn, backaward\n  //    P -- -2 -- double left turn\n  //    L -- -1 -- left turn\n  //    R -- +1 -- right turn\n  //    S -- +2 -- double right turn\n  RelForward: 0x0001,\n  RelBackward: 0x0002,\n  RelLeft: 0x0004,\n  RelRight: 0x0008,\n  RelDoubleLeft: 0x0010,\n  RelDoubleRight: 0x0020,\n\n  // absolute turns (for \"flat-top\" odd or even q hexagons)\n  //   NW -- ? -- North West\n  //   NO -- ? -- North\n  //   NE -- ? -- North East\n  //   SE -- ? -- South East\n  //   SO -- ? -- South\n  //   SW -- ? -- South West\n  AbsNorthWest: 0x0040,\n  AbsNorth: 0x0080,\n  AbsNorthEast: 0x0100,\n  AbsSouthEast: 0x0200,\n  AbsSouth: 0x0400,\n  AbsSouthWest: 0x0800,\n};\n\n/**\n * @param {Turn} turn - a bit field containing any/all chosen turn(s)\n * @param {number} dir - current heading direction for relative turns\n * @returns {Generator<number>} - resultant absolute direction heading(s)\n */\nexport function* turnDirs(turn, dir) {\n  let t = 0x0001;\n  for (; t <= 0x0020; t <<= 1) {\n    if (turn & t) {\n      yield (dir + (RelTurnDelta.get(t) || 0) + 6) % 6;\n    }\n  }\n  for (; t <= 0x0800; t <<= 1) {\n    if (turn & t) {\n      yield (AbsTurnDir.get(t) || 0);\n    }\n  }\n}\n\n/** @type {Map<Turn, number>} */\nexport const RelTurnDelta = new Map([\n  [Turn.RelBackward, 3],\n  [Turn.RelDoubleLeft, -2],\n  [Turn.RelLeft, -1],\n  [Turn.RelForward, 0],\n  [Turn.RelRight, 1],\n  [Turn.RelDoubleRight, 2],\n]);\n\n/** @type {Map<Turn, number>} */\nexport const AbsTurnDir = new Map([\n  [Turn.AbsSouthEast, 0],\n  [Turn.AbsSouth, 1],\n  [Turn.AbsSouthWest, 2],\n  [Turn.AbsNorthWest, 3],\n  [Turn.AbsNorth, 4],\n  [Turn.AbsNorthEast, 5],\n]);\n\n/** @type {Map<Turn, string>} */\nexport const RelTurnSymbol = new Map([\n  [Turn.RelBackward, 'B'],\n  [Turn.RelDoubleLeft, 'BL'],\n  [Turn.RelLeft, 'L'],\n  [Turn.RelForward, 'F'],\n  [Turn.RelRight, 'R'],\n  [Turn.RelDoubleRight, 'BR'],\n]);\n\n// TODO why no AbsTurnSymbol?\n\n/** @type {Map<string, Turn>} */\nexport const RelSymbolTurns = new Map([\n  ['B', Turn.RelBackward],\n  ['P', Turn.RelDoubleLeft],\n  ['L', Turn.RelLeft],\n  ['F', Turn.RelForward],\n  ['R', Turn.RelRight],\n  ['S', Turn.RelDoubleRight],\n]);\n\n/** @type {Map<string, Turn>} */\nexport const AbsSymbolTurns = new Map([\n  ['NW', Turn.AbsNorthWest],\n  ['NO', Turn.AbsNorth],\n  ['NE', Turn.AbsNorthEast],\n  ['SE', Turn.AbsSouthEast],\n  ['SO', Turn.AbsSouth],\n  ['SW', Turn.AbsSouthWest],\n]);\n","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(getSymbolShortDisplay).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var lines = buffer\n                .split(\"\\n\")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + \" \" + line;\n                }, this)\n                .join(\"\\n\");\n            message += \"\\n\" + pad(\"\", lastLineDigits + col) + \"^\\n\";\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(\" \") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo's thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = \"input \" + JSON.stringify(token.text[0]) + \" (lexer error)\";\n            lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        } else {\n            tokenDisplay = \"input (lexer error)\";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\\n');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n            // Display a \"state stack\" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push('A ' + symbolDisplay + ' based on:');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return 'character matching ' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + ' token';\n            } else if (symbol.test) {\n                return 'token matching ' + String(symbol.test);\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return '%' + symbol.type;\n            } else if (symbol.test) {\n                return '<' + String(symbol.test) + '>';\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","// @generated from id:2ca93388742b4da7a311d26c788bbaf95002b73588b88a4b0e70319aab4bd37c\n\n// Generated automatically by nearley, version 2.20.1\n// http://github.com/Hardmath123/nearley\nfunction id(x) { return x[0]; }\nlet Lexer = undefined;\nlet ParserRules = [\n    {\"name\": \"spec\", \"symbols\": [\"entries\"], \"postprocess\": ([entries]) => ({type: 'spec', entries: entries || []})},\n    {\"name\": \"entries\", \"symbols\": [\"entry\"]},\n    {\"name\": \"entries\", \"symbols\": [\"entry\", \"newline\", \"entries\"], \"postprocess\": ([head, _, tail]) => [head].concat(tail)},\n    {\"name\": \"comment$string$1\", \"symbols\": [{\"literal\":\"-\"}, {\"literal\":\"-\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"comment$macrocall$2\", \"symbols\": [/[^\\n]/]},\n    {\"name\": \"comment$macrocall$1$ebnf$1\", \"symbols\": [\"comment$macrocall$2\"]},\n    {\"name\": \"comment$macrocall$1$ebnf$1\", \"symbols\": [\"comment$macrocall$1$ebnf$1\", \"comment$macrocall$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"comment$macrocall$1\", \"symbols\": [\"comment$macrocall$1$ebnf$1\"], \"postprocess\": ([parts]) => parts.join('')},\n    {\"name\": \"comment\", \"symbols\": [\"_\", \"comment$string$1\", \"comment$macrocall$1\"], \"postprocess\": ([_0, _1, comment]) => ({type: 'comment', comment})},\n    {\"name\": \"entry\", \"symbols\": [\"assign\"], \"postprocess\": d => d[0]},\n    {\"name\": \"entry\", \"symbols\": [\"rule\"], \"postprocess\": d => d[0]},\n    {\"name\": \"entry\", \"symbols\": [\"directive\"], \"postprocess\": d => d[0]},\n    {\"name\": \"entry\", \"symbols\": [\"comment\"], \"postprocess\": d => d[0]},\n    {\"name\": \"directive$macrocall$2\", \"symbols\": [/[\\w]/]},\n    {\"name\": \"directive$macrocall$1$ebnf$1\", \"symbols\": [\"directive$macrocall$2\"]},\n    {\"name\": \"directive$macrocall$1$ebnf$1\", \"symbols\": [\"directive$macrocall$1$ebnf$1\", \"directive$macrocall$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"directive$macrocall$1\", \"symbols\": [\"directive$macrocall$1$ebnf$1\"], \"postprocess\": ([parts]) => parts.join('')},\n    {\"name\": \"directive$macrocall$4\", \"symbols\": [/[^\\n]/]},\n    {\"name\": \"directive$macrocall$3$ebnf$1\", \"symbols\": [\"directive$macrocall$4\"]},\n    {\"name\": \"directive$macrocall$3$ebnf$1\", \"symbols\": [\"directive$macrocall$3$ebnf$1\", \"directive$macrocall$4\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"directive$macrocall$3\", \"symbols\": [\"directive$macrocall$3$ebnf$1\"], \"postprocess\": ([parts]) => parts.join('')},\n    {\"name\": \"directive\", \"symbols\": [\"_\", {\"literal\":\"@\"}, \"directive$macrocall$1\", \"__\", \"directive$macrocall$3\"], \"postprocess\": ([_0, _1, name, _2, value]) => ({type: 'directive', name, value})},\n    {\"name\": \"assign\", \"symbols\": [\"identifier\", \"_\", {\"literal\":\"=\"}, \"_\", \"lit\"], \"postprocess\": ([id, _1, _2, _3, value]) => ({type: 'assign', id, value})},\n    {\"name\": \"rule\", \"symbols\": [\"ant\"], \"postprocess\": ([ant]) => ant},\n    {\"name\": \"rule$string$1\", \"symbols\": [{\"literal\":\"=\"}, {\"literal\":\">\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"rule\", \"symbols\": [\"when\", \"rule$string$1\", \"then\"], \"postprocess\": ([when, _1, then]) => ({type: 'rule', when, then})},\n    {\"name\": \"when\", \"symbols\": [\"expr\", {\"literal\":\",\"}, \"expr\"], \"postprocess\": ([state, _1, color]) => ({type: 'when', state, color})},\n    {\"name\": \"then\", \"symbols\": [\"thenState\", {\"literal\":\",\"}, \"thenColor\", {\"literal\":\",\"}, \"thenTurn\"], \"postprocess\": ([state, _1, color, _3, turn]) => ({type: 'then', state, color, turn})},\n    {\"name\": \"thenMode\", \"symbols\": [], \"postprocess\": () => '='},\n    {\"name\": \"thenMode\", \"symbols\": [{\"literal\":\"=\"}], \"postprocess\": () => '='},\n    {\"name\": \"thenMode\", \"symbols\": [{\"literal\":\"|\"}], \"postprocess\": () => '|'},\n    {\"name\": \"thenNoop\", \"symbols\": [\"_\", {\"literal\":\"_\"}, \"_\"], \"postprocess\": () => ({type: 'thenVal', mode: '_'})},\n    {\"name\": \"thenState\", \"symbols\": [\"thenNoop\"], \"postprocess\": d => d[0]},\n    {\"name\": \"thenState\", \"symbols\": [\"_\", \"thenMode\", \"sum\", \"_\"], \"postprocess\": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},\n    {\"name\": \"thenColor\", \"symbols\": [\"thenNoop\"], \"postprocess\": d => d[0]},\n    {\"name\": \"thenColor\", \"symbols\": [\"_\", \"thenMode\", \"sum\", \"_\"], \"postprocess\": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},\n    {\"name\": \"thenTurn\", \"symbols\": [\"thenNoop\"], \"postprocess\": d => d[0]},\n    {\"name\": \"thenTurn\", \"symbols\": [\"_\", \"thenMode\", \"sum\", \"_\"], \"postprocess\": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},\n    {\"name\": \"thenTurn\", \"symbols\": [\"_\", \"thenMode\", \"turnExpr\", \"_\"], \"postprocess\": ([_0, mode, value]) => ({type: 'thenVal', mode, value})},\n    {\"name\": \"turnExpr\", \"symbols\": [\"turn\"], \"postprocess\": ([name]) => ({type: 'turn', names: [name]})},\n    {\"name\": \"turnExpr\", \"symbols\": [\"turnExpr\", {\"literal\":\"|\"}, \"turnExpr\"], \"postprocess\": ([a, _1, b]) => ({type: 'turn', names: a.names.concat(b.names)})},\n    {\"name\": \"expr\", \"symbols\": [\"_\", \"sum\", \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"sumop\", \"symbols\": [\"_\", {\"literal\":\"+\"}, \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"sumop\", \"symbols\": [\"_\", {\"literal\":\"-\"}, \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"mulop\", \"symbols\": [\"_\", {\"literal\":\"*\"}, \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"mulop\", \"symbols\": [\"_\", {\"literal\":\"/\"}, \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"mulop\", \"symbols\": [\"_\", {\"literal\":\"%\"}, \"_\"], \"postprocess\": d => d[1]},\n    {\"name\": \"sum\", \"symbols\": [\"sum\", \"sumop\", \"mul\"], \"postprocess\": ([arg1, op, arg2]) => ({type: 'expr', op, arg1, arg2})},\n    {\"name\": \"sum\", \"symbols\": [\"mul\"], \"postprocess\": d => d[0]},\n    {\"name\": \"mul\", \"symbols\": [\"mul\", \"mulop\", \"fac\"], \"postprocess\": ([arg1, op, arg2]) => ({type: 'expr', op, arg1, arg2})},\n    {\"name\": \"mul\", \"symbols\": [\"fac\"], \"postprocess\": d => d[0]},\n    {\"name\": \"fac\", \"symbols\": [{\"literal\":\"(\"}, \"expr\", {\"literal\":\")\"}], \"postprocess\": d => d[1]},\n    {\"name\": \"fac\", \"symbols\": [\"lit\"], \"postprocess\": d => d[0]},\n    {\"name\": \"fac\", \"symbols\": [\"member\"], \"postprocess\": d => d[0]},\n    {\"name\": \"fac\", \"symbols\": [\"symbol\"], \"postprocess\": d => d[0]},\n    {\"name\": \"fac\", \"symbols\": [\"identifier\"], \"postprocess\": d => d[0]},\n    {\"name\": \"ant$string$1\", \"symbols\": [{\"literal\":\"a\"}, {\"literal\":\"n\"}, {\"literal\":\"t\"}, {\"literal\":\"(\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"ant\", \"symbols\": [\"_\", \"ant$string$1\", \"countTurns\", {\"literal\":\")\"}, \"_\"], \"postprocess\": ([_0, _1, turns]) => ({type: 'ant', turns})},\n    {\"name\": \"turns$string$1\", \"symbols\": [{\"literal\":\"t\"}, {\"literal\":\"u\"}, {\"literal\":\"r\"}, {\"literal\":\"n\"}, {\"literal\":\"s\"}, {\"literal\":\"(\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turns\", \"symbols\": [\"turns$string$1\", \"countTurns\", {\"literal\":\")\"}], \"postprocess\": ([_, turns]) => ({type: 'turns', turns})},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"L\"}], \"postprocess\": () => 'RelLeft'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"R\"}], \"postprocess\": () => 'RelRight'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"F\"}], \"postprocess\": () => 'RelForward'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"B\"}], \"postprocess\": () => 'RelBackward'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"P\"}], \"postprocess\": () => 'RelDoubleLeft'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"S\"}], \"postprocess\": () => 'RelDoubleRight'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"l\"}], \"postprocess\": () => 'RelLeft'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"r\"}], \"postprocess\": () => 'RelRight'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"f\"}], \"postprocess\": () => 'RelForward'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"b\"}], \"postprocess\": () => 'RelBackward'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"p\"}], \"postprocess\": () => 'RelDoubleLeft'},\n    {\"name\": \"turn\", \"symbols\": [{\"literal\":\"s\"}], \"postprocess\": () => 'RelDoubleRight'},\n    {\"name\": \"turn$string$1\", \"symbols\": [{\"literal\":\"N\"}, {\"literal\":\"W\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$1\"], \"postprocess\": () => 'AbsNorthWest'},\n    {\"name\": \"turn$string$2\", \"symbols\": [{\"literal\":\"N\"}, {\"literal\":\"O\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$2\"], \"postprocess\": () => 'AbsNorth'},\n    {\"name\": \"turn$string$3\", \"symbols\": [{\"literal\":\"N\"}, {\"literal\":\"E\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$3\"], \"postprocess\": () => 'AbsNorthEast'},\n    {\"name\": \"turn$string$4\", \"symbols\": [{\"literal\":\"S\"}, {\"literal\":\"E\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$4\"], \"postprocess\": () => 'AbsSouthEast'},\n    {\"name\": \"turn$string$5\", \"symbols\": [{\"literal\":\"S\"}, {\"literal\":\"O\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$5\"], \"postprocess\": () => 'AbsSouth'},\n    {\"name\": \"turn$string$6\", \"symbols\": [{\"literal\":\"S\"}, {\"literal\":\"W\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$6\"], \"postprocess\": () => 'AbsSouthWest'},\n    {\"name\": \"turn$string$7\", \"symbols\": [{\"literal\":\"n\"}, {\"literal\":\"w\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$7\"], \"postprocess\": () => 'AbsNorthWest'},\n    {\"name\": \"turn$string$8\", \"symbols\": [{\"literal\":\"n\"}, {\"literal\":\"o\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$8\"], \"postprocess\": () => 'AbsNorth'},\n    {\"name\": \"turn$string$9\", \"symbols\": [{\"literal\":\"n\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$9\"], \"postprocess\": () => 'AbsNorthEast'},\n    {\"name\": \"turn$string$10\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$10\"], \"postprocess\": () => 'AbsSouthEast'},\n    {\"name\": \"turn$string$11\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"o\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$11\"], \"postprocess\": () => 'AbsSouth'},\n    {\"name\": \"turn$string$12\", \"symbols\": [{\"literal\":\"s\"}, {\"literal\":\"w\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"turn\", \"symbols\": [\"turn$string$12\"], \"postprocess\": () => 'AbsSouthWest'},\n    {\"name\": \"countTurn\", \"symbols\": [\"turn\"], \"postprocess\": ([turn]) => ({count: {type: 'number', value: 1}, turn})},\n    {\"name\": \"countTurn\", \"symbols\": [\"decint\", \"turn\"], \"postprocess\": ([count, turn]) => ({count, turn})},\n    {\"name\": \"countTurns$ebnf$1\", \"symbols\": []},\n    {\"name\": \"countTurns$ebnf$1$subexpression$1\", \"symbols\": [\"__\", \"countTurn\"]},\n    {\"name\": \"countTurns$ebnf$1\", \"symbols\": [\"countTurns$ebnf$1\", \"countTurns$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"countTurns\", \"symbols\": [\"_\", \"countTurn\", \"countTurns$ebnf$1\", \"_\"], \"postprocess\": ([_, first, rest=[]]) => ([first, ...rest.map(([_, next]) => next)])},\n    {\"name\": \"member$subexpression$1\", \"symbols\": [\"member\"]},\n    {\"name\": \"member$subexpression$1\", \"symbols\": [\"symbol\"]},\n    {\"name\": \"member$subexpression$1\", \"symbols\": [\"identifier\"]},\n    {\"name\": \"member$subexpression$1\", \"symbols\": [\"lit\"]},\n    {\"name\": \"member\", \"symbols\": [\"member$subexpression$1\", {\"literal\":\"[\"}, \"expr\", {\"literal\":\"]\"}], \"postprocess\": ([[value], _1, item]) => ({type: 'member', value, item})},\n    {\"name\": \"symbol$ebnf$1\", \"symbols\": []},\n    {\"name\": \"symbol$ebnf$1\", \"symbols\": [\"symbol$ebnf$1\", /[\\w]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"symbol\", \"symbols\": [/[a-z]/, \"symbol$ebnf$1\"], \"postprocess\": ([head, tail]) => ({type: 'symbol', name: head + tail.join('')})},\n    {\"name\": \"identifier$ebnf$1\", \"symbols\": [/[\\w]/]},\n    {\"name\": \"identifier$ebnf$1\", \"symbols\": [\"identifier$ebnf$1\", /[\\w]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"identifier\", \"symbols\": [/[A-Z]/, \"identifier$ebnf$1\"], \"postprocess\": ([head, tail]) => ({type: 'identifier', name: head + tail.join('')})},\n    {\"name\": \"lit\", \"symbols\": [\"int\"], \"postprocess\": d => d[0]},\n    {\"name\": \"lit\", \"symbols\": [\"turns\"], \"postprocess\": d => d[0]},\n    {\"name\": \"int$string$1\", \"symbols\": [{\"literal\":\"0\"}, {\"literal\":\"x\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"int\", \"symbols\": [\"int$string$1\", \"hexint\"], \"postprocess\": d => d[1]},\n    {\"name\": \"int\", \"symbols\": [\"decint\"], \"postprocess\": d => d[0]},\n    {\"name\": \"hexint$macrocall$2\", \"symbols\": [/[0-9a-fA-F]/]},\n    {\"name\": \"hexint$macrocall$1$ebnf$1\", \"symbols\": [\"hexint$macrocall$2\"]},\n    {\"name\": \"hexint$macrocall$1$ebnf$1\", \"symbols\": [\"hexint$macrocall$1$ebnf$1\", \"hexint$macrocall$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"hexint$macrocall$1\", \"symbols\": [\"hexint$macrocall$1$ebnf$1\"], \"postprocess\": ([parts]) => parts.join('')},\n    {\"name\": \"hexint\", \"symbols\": [\"hexint$macrocall$1\"], \"postprocess\": ([num]) => ({type: 'number', value: parseInt(num, 16), base: 16})},\n    {\"name\": \"decint$macrocall$2\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"decint$macrocall$1$ebnf$1\", \"symbols\": [\"decint$macrocall$2\"]},\n    {\"name\": \"decint$macrocall$1$ebnf$1\", \"symbols\": [\"decint$macrocall$1$ebnf$1\", \"decint$macrocall$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"decint$macrocall$1\", \"symbols\": [\"decint$macrocall$1$ebnf$1\"], \"postprocess\": ([parts]) => parts.join('')},\n    {\"name\": \"decint\", \"symbols\": [\"decint$macrocall$1\"], \"postprocess\": ([num]) => ({type: 'number', value: parseInt(num, 10)})},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", /[\\s]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"], \"postprocess\": () => null},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [/[\\s]/]},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [\"__$ebnf$1\", /[\\s]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"__\", \"symbols\": [\"__$ebnf$1\"], \"postprocess\": () => null},\n    {\"name\": \"newline$ebnf$1\", \"symbols\": [{\"literal\":\"\\r\"}], \"postprocess\": id},\n    {\"name\": \"newline$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"newline\", \"symbols\": [\"newline$ebnf$1\", {\"literal\":\"\\n\"}], \"postprocess\": () => null}\n];\nlet ParserStart = \"spec\";\nexport default { Lexer, ParserRules, ParserStart };\n","// @ts-check\n\n// TODO these types can become the basis of a directly coded recursive descent\n// parser.js which can replace lang/grammar.{ne,js} entirely\n\n/** @typedef {(\n * | CommentNode\n * | DirectiveNode\n * | SpecNode\n * | AssignNode\n * | AntNode\n * | RuleNode\n * | WhenNode\n * | ThenNode\n * | ThenValNode\n * | MemberNode\n * | ExprNode<NumberNode|TurnsNode>\n * | IdentifierNode\n * | NumberNode\n * | SymbolNode\n * | TurnNode\n * | TurnsNode\n * )} Node */\n\n/** @typedef {object} CommentNode\n * @prop {\"comment\"} type\n * @prop {string} comment\n */\n\n/** @typedef {object} DirectiveNode\n * @prop {\"directive\"} type\n * @prop {string} name\n * @prop {string} value\n */\n\n/** @template Literal\n * @typedef {(\n * | Value<Literal>\n * | ExprNode<Literal>\n * )} Expr */\n\n/** @template Literal\n * @typedef {(\n * | MemberNode\n * | SymbolNode\n * | IdentifierNode\n * | Literal\n * )} Value */\n\n/** @typedef {object} SpecNode\n * @prop {\"spec\"} type\n * @prop {EntryNode[]} entries\n */\n\n/** @typedef {(\n * | AssignNode\n * | CommentNode\n * | DirectiveNode\n * | AntNode\n * | RuleNode\n * )} EntryNode */\n\n/** @typedef {Value<NumberNode|TurnsNode>} AnyValue */\n/** @typedef {Expr<NumberNode|TurnsNode>} AnyExpr */\n\n/** @typedef {object} AssignNode\n * @prop {\"assign\"} type\n * @prop {IdentifierNode} id\n * @prop {AnyExpr} value\n */\n\n/** @typedef {object} RuleNode\n * @prop {\"rule\"} type\n * @prop {WhenNode} when\n * @prop {ThenNode} then\n */\n\n/** @typedef {object} WhenNode\n * @prop {\"when\"} type\n * @prop {AnyExpr} state TODO should not be able to have turns\n * @prop {AnyExpr} color TODO should not be able to have turns\n */\n\n/** @typedef {object} ThenNode\n * @prop {\"then\"} type\n * @prop {ThenValNode} state TODO .value should not be be able to have turns\n * @prop {ThenValNode} color TODO .value should not be be able to have turns\n * @prop {ThenValNode} turn\n */\n\n/** @typedef {(\n * | {type: \"thenVal\", mode: (\"|\" | \"=\"), value: AnyExpr}\n * | {type: \"thenVal\", mode: \"_\"}\n * )} ThenValNode\n */\n\n/** @typedef {object} MemberNode\n * @prop {\"member\"} type\n * @prop {AnyValue} value TODO should not be able to have turns?\n * @prop {AnyExpr} item TODO should not be able to have turns?\n */\n\n/** @template Literal\n * @typedef {object} ExprNode\n * @prop {\"expr\"} type\n * @prop {ExprOp} op\n * @prop {Expr<Literal>} arg1\n * @prop {Expr<Literal>} arg2\n */\n\n/** @typedef {\"+\" | \"-\" | \"*\" | \"/\" | \"%\"} ExprOp */\n\n/** @typedef {object} IdentifierNode\n * @prop {\"identifier\"} type\n * @prop {string} name\n */\n\n/** @typedef {object} NumberNode\n * @prop {\"number\"} type\n * @prop {number} value\n * @prop {number} [base]\n */\n\n/** @typedef {object} SymbolNode\n * @prop {\"symbol\"} type\n * @prop {string} name\n */\n\n/** @typedef {(\n * | 'RelLeft'\n * | 'RelRight'\n * | 'RelForward'\n * | 'RelBackward'\n * | 'RelDoubleLeft'\n * | 'RelDoubleRight'\n * | 'AbsNorthWest'\n * | 'AbsNorth'\n * | 'AbsNorthEast'\n * | 'AbsSouthEast'\n * | 'AbsSouth'\n * | 'AbsSouthWest'\n * )} Turn */\n\n/** @typedef {object} TurnNode\n * @prop {\"turn\"} type\n * @prop {Turn[]} names\n */\n\n/** @typedef {object} AntNode\n * @prop {\"ant\"} type\n * @prop {CountTurn[]} turns\n */\n\n/** @typedef {object} TurnsNode\n * @prop {\"turns\"} type\n * @prop {CountTurn[]} turns\n */\n\n/** @typedef {object} CountTurn\n * @prop {NumberNode} count\n * @prop {Turn} turn\n */\n\n/** @typedef {Node['type']} NodeType */\n\n/**\n * @template {NodeType} T\n * @typedef {Extract<Node, {type: T}>} TypedNode\n */\n\n/**\n * @template {NodeType} T\n * @param {T} type\n * @param {Node} node\n * @returns {node is TypedNode<T>}\n */\nexport function isNodeType(type, node) {\n  return node.type === type;\n}\n\n/**\n * @param {Node} node\n * @returns {node is EntryNode}\n */\nexport function isEntryNode(node) {\n  switch (node.type) {\n    case 'ant':\n    case 'assign':\n    case 'comment':\n    case 'directive':\n    case 'rule':\n      return true;\n    default:\n      return false;\n  }\n}\n\n// TODO generic id/sym/value/expr lifts, and then used consistently throughout\n\n/**\n * @param {string} name\n * @param {string} value\n * @returns {DirectiveNode}\n */\nexport function directive(name, value) {\n  return { type: 'directive', name, value };\n}\n\n/**\n * @param {string} comment\n * @returns {CommentNode}\n */\nexport function comment(comment) {\n  return { type: 'comment', comment };\n}\n\n/**\n * @param {number} value\n * @param {number} [base] - defaults to base-10 if unspecified\n * @returns {NumberNode}\n */\nexport function number(value, base) {\n  return { type: 'number', value, base };\n}\n\n/**\n * @param {string} name\n * @returns {IdentifierNode}\n */\nexport function id(name) {\n  return { type: 'identifier', name };\n}\n\n/**\n * @param {string} name\n * @returns {SymbolNode}\n */\nexport function sym(name) {\n  return { type: 'symbol', name };\n}\n\n/**\n * @param {EntryNode[]} entries\n * @returns {SpecNode}\n */\nexport function spec(...entries) {\n  return { type: 'spec', entries };\n}\n\n/**\n * @param {string|IdentifierNode} id\n * @param {AnyExpr} value\n * @returns {AssignNode}\n */\nexport function assign(id, value) {\n  if (typeof id === 'string') id = { type: 'identifier', name: id };\n  return { type: 'assign', id, value };\n}\n\n/**\n * @param {WhenNode} when\n * @param {ThenNode} then\n * @returns {RuleNode}\n */\nexport function rule(when, then) {\n  return { type: 'rule', when, then };\n}\n\n/**\n * @param {CountTurn[]} turns\n * @returns {AntNode}\n */\nexport function ant(...turns) {\n  return { type: 'ant', turns };\n}\n\n/**\n * @param {CountTurn[]} turns\n * @returns {TurnsNode}\n */\nexport function turns(...turns) {\n  return { type: 'turns', turns };\n}\n\n/**\n * @param {AnyValue} value\n * @param {AnyExpr} item\n * @returns {MemberNode}\n */\nexport function member(value, item) {\n  return { type: 'member', value, item };\n}\n\n/**\n * @template {Node} S\n * @template {Node} T\n * @param {ExprOp} op\n * @param {S} arg1\n * @param {T} arg2\n * @returns {ExprNode<S|T>}\n */\nexport function expr(op, arg1, arg2) {\n  return { type: 'expr', op, arg1, arg2 };\n}\n\n/**\n * @param {AnyExpr} state\n * @param {AnyExpr} color\n * @returns {WhenNode}\n */\nexport function when(state, color) {\n  return ({ type: 'when', state, color });\n}\n\n/**\n * @param {AnyExpr|ThenValNode} state\n * @param {AnyExpr|ThenValNode} color\n * @param {AnyExpr|ThenValNode} turn\n * @returns {ThenNode}\n */\nexport function then(state, color, turn) {\n  return {\n    type: 'then',\n    state: thenVal(state),\n    color: thenVal(color),\n    turn: thenVal(turn),\n  };\n}\n\n/**\n * @param {AnyExpr|ThenValNode} value\n * @param {\"=\"|\"|\"} [mode]\n * @returns {ThenValNode}\n */\nexport function thenVal(value, mode = '=') {\n  return value.type === 'thenVal' ? value : { type: 'thenVal', mode, value };\n}\n\n/**\n * @param {AnyExpr} value\n * @returns {ThenValNode}\n */\nexport function thenSet(value) {\n  return { type: 'thenVal', mode: '=', value };\n}\n\n/**\n * @param {AnyExpr} value\n * @returns {ThenValNode}\n */\nexport function thenUpdate(value) {\n  return { type: 'thenVal', mode: '|', value };\n}\n\n/** @returns {ThenValNode} */\nexport function thenPass() {\n  return { type: 'thenVal', mode: '_' };\n}\n\n/**\n * @param {Node} node\n * @returns {node is AnyExpr}\n */\nexport function isAnyExpr(node) {\n  switch (node.type) {\n    // Expr<Literal>\n    case 'expr':\n      return true;\n\n    // is Value<Literal>\n    default:\n      return isAnyValue(node);\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {node is AnyValue}\n */\nexport function isAnyValue(node) {\n  switch (node.type) {\n    // Value<Literal>\n    case 'member':\n    case 'symbol':\n    case 'identifier':\n\n    // Literal = NumberNode | TurnsNode\n    case 'number':\n    case 'turns':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\n","// @ts-check\n\n// @ts-ignore\nimport nearley from 'nearley';\n\nimport * as rezult from '../rezult.js';\n\nimport grammarRules from './grammar_rules.js';\nconst grammar = nearley.Grammar.fromCompiled(grammarRules);\n\nimport { isNodeType } from './grammar.js';\n\n/** @typedef {import('./grammar.js').Node} Node */\n/** @typedef {import('./grammar.js').NodeType} NodeType */\n/** @template T @typedef {import('./grammar.js').TypedNode<T>} TypedNode */\n\n/**\n * @template {NodeType} T\n * @param {T} type\n * @param {Node} node\n * @returns {TypedNode<T>}\n */\nfunction asTypedNode(type, node) {\n  if (!isNodeType(type, node)) throw new Error(\n    `expected a ${JSON.stringify(type)} grammar node, ` +\n    `got a ${JSON.stringify(type)} node`);\n  return node;\n}\n\n/** @param {string} str */\nexport default function parse(str) {\n  if (typeof str !== 'string') {\n    return rezult.error(new Error('invalid argument, not a string'));\n  }\n  return rezult.catchErr(() => {\n    const parser = new nearley.Parser(grammar);\n    parser.feed(str);\n\n    /** @type {{ results: Node[] }} */\n    const { results } = parser;\n    switch (results.length) {\n      case 0:\n        return rezult.error(new Error('no parse result'));\n      case 1:\n        return rezult.just(asTypedNode('spec', results[0]));\n      default:\n        return rezult.error(new Error('ambiguous parse'));\n    }\n  });\n}\n","// @ts-check\n\n/** Builds a canonical RLE string from possibly redundant parts.\n *\n * Exemplars:\n * - \"A A A\" => \"3A\"\n * - \"3A 2A\" => \"5A\"\n *\n * Except that all tokenization concerns are up to the caller, so this builder\n * takes pre-parsed (count: number, sym: string) pairs, and returns a list\n * containing accumulated terms (not including the current one). The caller\n * shouldn't really care about the return value until after a terminal () call.\n *\n * Usage:\n *   const input = 'A B B 3C 3D D';\n *   const {consume, finish} = RLEBuilder();\n *   for (const token of input.split(/\\s+/)) {\n *     consume(token);\n *     // NOTE: caller may parser their own count/sym apart if necessary and call consume(count, sym)\n *   }\n *   const output = finish().join(' ');\n *   // output = \"A 2B 3C 4D\"\n *\n * NOTE: any empty symbol strings and counts <= 0 are elided\n */\nexport function RLEBuilder() {\n  /** @type {[count: number, sym: string][]} */\n  let parts = [];\n  let cur = '', curCount = 0;\n\n  return {\n    /**\n     * NOTE: altho it's the sym agument that is formally optional, one should\n     * think of this signature more like consume([count, ]sym):\n     * - if a single string argument is given, any numeric prefix is parsed out\n     *   and becomes count (default 1)\n     * - if a single numeric argument is given, that's a noop (empty symbol)\n     * - if two strings are given, any non-numeric suffix in the count string\n     *   is ignored\n     * - those last two cases are just unfortunate outcomes of javascript's\n     *   semimplicit type system, and not really intended use cases\n     *\n     * @param {string|number} count\n     * @param {string} [sym]\n     */\n    consume(count, sym) {\n      if (sym === undefined) {\n        if (typeof count != 'string') { return }\n        const match = /(\\d*)(\\w+)/.exec(count);\n        if (!match) { return }\n        count = match[1], sym = match[2];\n      }\n      if (typeof count == 'string') {\n        count = parseInt(count);\n        if (isNaN(count)) {\n          count = 1;\n        }\n      }\n\n      if (cur !== sym) {\n        if (cur && curCount) {\n          parts.push([curCount, cur]);\n        }\n        cur = sym, curCount = 0;\n      }\n      curCount += count;\n    },\n\n    finish() {\n      if (cur && curCount) {\n        parts.push([curCount, cur]);\n      }\n      const res = parts;\n      parts = [], cur = '', curCount = 0;\n      return res;\n    }\n  };\n}\n\n/** @param {Iterable<[count: string|number, sym?: string]>} countsyms */\nexport function from(countsyms) {\n  const { consume, finish } = RLEBuilder();\n  for (const [count, sym] of countsyms) {\n    consume(count, sym);\n  }\n  return finish();\n}\n","// @ts-check\n\nimport { from as rleFrom } from './rle-builder.js';\n\n/** @typedef {import('./grammar.js').Node} Node */\n\n\n// TODO reconcile with ./constants.js\nconst TurnSyms = {\n  RelLeft: 'L',\n  RelRight: 'R',\n  RelForward: 'F',\n  RelBackward: 'B',\n  RelDoubleLeft: 'P',\n  RelDoubleRight: 'S',\n  AbsNorth: 'NO',\n  AbsNorthWest: 'NW',\n  AbsNorthEast: 'NE',\n  AbsSouth: 'SO',\n  AbsSouthEast: 'SE',\n  AbsSouthWest: 'SW'\n};\n\n// TODO: de-dupe\nconst opPrec = ['+', '-', '*', '/', '%'];\n\n/**\n * @param {Node[]} nodes\n * @returns {Generator<string>}\n */\nexport default function* toSpecString(...nodes) {\n  yield* toString(0, ...nodes);\n}\n\n/**\n * @param {number} outerPrec\n * @param {Node[]} nodes\n * @returns {Generator<string>}\n */\nfunction* toString(outerPrec, ...nodes) {\n  for (const node of nodes) {\n    switch (node.type) {\n\n      case 'spec': {\n        const { entries } = node;\n        for (const entry of entries) {\n          yield* toString(outerPrec, entry);\n        }\n        break;\n      }\n\n      case 'comment': {\n        const { comment } = node;\n        yield `--${comment}`;\n        break;\n      }\n\n      case 'directive': {\n        const { name, value } = node;\n        yield `@${name} ${value}`\n        break;\n      }\n\n      case 'assign': {\n        const { id: { name }, value } = node;\n        const it = toString(outerPrec, value)\n        yield `${name} = ${next(it, '')}`;\n        yield* it;\n        break;\n      }\n\n      case 'rule': {\n        const { when, then } = node;\n        const it = toString(outerPrec, when, then)\n        yield `${next(it, '')} => ${next(it, '')}`;\n        yield* it;\n        break;\n      }\n\n      case 'when': {\n        const { state, color } = node;\n        const it = toString(outerPrec, state, color);\n        yield `${next(it, '')}, ${next(it, '')}`;\n        yield* it;\n        break;\n      }\n\n      case 'then':\n        const { state, color, turn } = node;\n        const it = toString(outerPrec, state, color, turn);\n        yield `${next(it, '')}, ${next(it, '')}, ${next(it, '')}`;\n        yield* it;\n        break;\n\n      case 'thenVal': {\n        const { mode } = node;\n        if (mode === '_') {\n          yield '_';\n          break;\n        }\n\n        const { value } = node;\n        const it = toString(outerPrec, value);\n        yield `${mode === '=' ? '' : mode}${next(it, '')}`;\n        yield* it;\n        break;\n      }\n\n      case 'member': {\n        const { value, item } = node;\n        const it = toString(outerPrec, value, item);\n        yield `${next(it, '')}[${next(it, '')}]`;\n        yield* it;\n        break;\n      }\n\n      case 'expr': {\n        const { op, arg1, arg2 } = node;\n        const prec = opPrec.indexOf(op)\n        const it = toString(outerPrec, arg1, arg2);\n        const expr = `${next(it, '')} ${op} ${next(it, '')}`;\n        yield prec < outerPrec ? `(${expr})` : expr;\n        yield* it;\n        break;\n      }\n\n      case 'identifier':\n      case 'symbol': {\n        const { name } = node;\n        yield name;\n        break;\n      }\n\n      case 'ant':\n      case 'turns': {\n        const { type, turns } = node;\n        yield `${type}(${rleFrom(turns\n          .map(({ count: { value: count }, turn }) => [count, TurnSyms[turn]])\n        )\n          .map(([count, sym]) => count > 1 ? `${count}${sym}` : sym)\n          .join(' ')})`;\n        break;\n      }\n\n      case 'turn': {\n        const { names } = node;\n        yield names.map(name => TurnSyms[name]).join('|');\n        break;\n      }\n\n      case 'number': {\n        const { value, base } = node;\n        yield value.toString(base);\n        break;\n      }\n\n      default:\n        assertNever(node, 'invalid grammar node');\n    }\n  }\n}\n\n/** @template T\n * @param {Iterator<T>} it\n * @param {T} or\n */\nfunction next(it, or) {\n  const { done, value } = it.next();\n  return done ? or : value;\n}\n\n/**\n * @param {never} impossible\n * @param {string} mess\n */\nfunction assertNever(impossible, mess) {\n  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);\n}\n","// @ts-check\n\nimport {\n  assign,\n  expr,\n  isAnyExpr,\n  isAnyValue,\n  isEntryNode,\n  isNodeType,\n  member,\n  number,\n  rule,\n  spec,\n  sym,\n  then,\n  thenPass,\n  thenSet,\n  thenVal,\n  turns,\n  when,\n} from './grammar.js';\n\n/** @typedef {import('./grammar.js').AnyExpr} AnyExpr */\n/** @typedef {import('./grammar.js').ThenValNode} ThenValNode */\n/** @typedef {import('./grammar.js').CountTurn} CountTurn */\n\n/** @typedef {import('./grammar.js').Node} Node */\n/** @typedef {import('./grammar.js').SpecNode} SpecNode */\n/** @typedef {import('./grammar.js').NodeType} NodeType */\n\n/** @template T @typedef {import('./grammar.js').TypedNode<T>} TypedNode */\n\n/**\n * @param {SpecNode} spec\n * @returns {Generator<{name: string, label?: string, then: (spec: SpecNode) => SpecNode}>}\n */\nexport function* actions(spec) {\n  if (\n    spec.entries.some(({ type }) => type == 'ant') &&\n    spec.entries.every(({ type }) => type != 'rule')\n  ) yield {\n    name: 'liftToTurmite',\n    label: 'Convert To Turmite',\n    then: spec => transformed(spec,\n      matchType('ant', ({ turns }) => antRule(turns))) || spec,\n  };\n}\n\n/** @param {string} str */\nexport function isJustAnt(str) {\n  return /^\\s*ant(\\(.*|\\s*$)/.test(str);\n}\n\n/**\n * @param {CountTurn[]} antTurns\n * @param {object} options\n * @param {number} [options.state]\n * @param {AnyExpr} [options.whenState]\n * @param {ThenValNode} [options.thenState]\n */\nexport function antRule(antTurns, {\n  state = 0,\n  whenState = number(state),\n  thenState = thenSet(number(state)),\n} = {}) {\n  const c = sym('c');\n  return rule(when(whenState, c), then(\n    thenState,\n    expr('+', c, number(1)),\n    member(turns(...antTurns), c),\n  ));\n}\n\n/**\n * @template {NodeType} T\n * @param {T} type\n * @param {TypedNodeTransform<T>} fn\n * @returns {NodeTransform}\n */\nexport function matchType(type, fn) {\n  return node => isNodeType(type, node)\n    ? fn(node)\n    : undefined;\n}\n\n/** @template {NodeType} T\n * @callback TypedNodeTransform\n * @param {TypedNode<T>} node\n * @returns {Node|null|void}\n */\n\n/** @callback NodeTransform\n * @param {Node} node\n * @returns {Node|null|void}\n */\n\n/**\n * @template {Node} NT\n * @param {NT} node\n * @param {NodeTransform[]} xforms\n * @returns {NT|null}\n */\nexport function transformed(node, ...xforms) {\n  const oldType = node.type;\n\n  /**\n   * @param {Node} n\n   * @returns {n is NT}\n   */\n  function isSameType(n) {\n    return n.type === oldType;\n  }\n\n  const newNode = transform(node, ...xforms);\n  if (newNode === null) return null;\n  if (!newNode) return node;\n  if (!isSameType(newNode)) throw new Error('invalid replacement node');\n\n  return newNode;\n}\n\n/**\n * @param {Node} node\n * @param {NodeTransform[]} xforms\n * @returns {Node|null|void}\n */\nexport function transform(node, ...xforms) {\n  if (!xforms.length) return node;\n\n  /** @type {NodeTransform} */\n  const xform = xforms.length > 1\n    ? node => {\n      for (const xform of xforms) {\n        node = xform(node) || node;\n      }\n      return node;\n    }\n    : xforms[0];\n  return each(node);\n\n  /** @param {Node} node @returns {Node|null|void} */\n  function each(node) {\n    let newNode = xform(node);\n    if (newNode === null) return null; // explicit delete\n    if (newNode && newNode !== node) {\n      newNode = each(newNode) || newNode;\n    }\n    node = newNode || node;\n    const res = descend(node);\n    return res === undefined ? node : res;\n  }\n\n  /** @param {Node} node @returns {Node|null|void} */\n  function descend(node) {\n    switch (node.type) {\n\n      case 'spec': {\n        let any = false;\n        const entries = node.entries.map(entry => {\n          const rep = each(entry);\n          if (rep && !isEntryNode(rep))\n            throw new Error('invalid replacement spec entry');\n          if (rep === undefined) return entry;\n          any = any || rep !== entry;\n          return rep;\n        }).filter(notNull);\n        return !any ? undefined // no change\n          : !entries.length ? null // delete if empty\n            : spec(...entries);\n      }\n\n      case 'assign': {\n        let id = each(node.id);\n        let value = each(node.value);\n        if (id === null || value === null) return null; // delete spreads\n        if (!id && !value) return undefined; // no change\n        if (!id) id = node.id;\n        else if (id.type !== 'identifier') throw new Error('invalid replacement identifier node');\n        if (!value) value = node.value;\n        else if (!isAnyExpr(value)) throw new Error('invalid replacement value node');\n        return assign(id, value);\n      }\n\n      case 'rule': {\n        let when = each(node.when);\n        let then = each(node.then);\n        if (when === null || then === null) return null; // delete spreads\n        if (!when && !then) return undefined; // no change\n        if (!when) when = node.when;\n        else if (when.type !== 'when') throw new Error('invalid replacement when node');\n        if (!then) then = node.then;\n        else if (then.type !== 'then') throw new Error('invalid replacement then node');\n        return rule(when, then);\n      }\n\n      case 'when': {\n        let state = each(node.state);\n        let color = each(node.color);\n        if (state === null || color === null) return null; // delete spreads\n        if (!state && !color) return undefined; // no change\n        if (!state) state = node.state;\n        else if (!isAnyExpr(state)) throw new Error('invalid replacement when.state node');\n        if (!color) color = node.color;\n        else if (!isAnyExpr(color)) throw new Error('invalid replacement when.color node');\n        return when(state, color);\n      }\n\n      case 'then': {\n        let state = each(node.state);\n        let color = each(node.color);\n        let turn = each(node.turn);\n        if (state === null) state = thenPass(); // deleted clause now passes\n        if (color === null) color = thenPass(); // deleted clause now passes\n        if (turn === null) turn = thenPass(); // deleted clause now passes\n        if (!state && !color && !turn) return undefined; // no change\n        if (!state) state = node.state;\n        else if (state.type !== 'thenVal') throw new Error('invalid replacement then.state node');\n        if (!color) color = node.color;\n        else if (color.type !== 'thenVal') throw new Error('invalid replacement then.color node');\n        if (!turn) turn = node.turn;\n        else if (turn.type !== 'thenVal') throw new Error('invalid replacement then.turn node');\n        // delete spreads only if all clauses now pass (at least one was just deleted above)\n        if (state.mode === '_' && color.mode === '_' && turn.mode === '_') return null;\n        return then(state, color, turn);\n      }\n\n      case 'thenVal': {\n        const { mode } = node;\n        if (mode == '_') return undefined; // no change\n        let value = each(node.value);\n        if (value === null) return null; // delete spreads\n        if (!value) return undefined; // no change\n        if (!isAnyExpr(value)) throw new Error('invalid replacement then value node');\n        return thenVal(value, mode);\n      }\n\n      case 'member': {\n        let item = each(node.item);\n        let value = each(node.value);\n        if (item === null || value === null) return null; // delete spreads\n        if (!item && !value) return undefined; // no change\n        if (!item) item = node.item;\n        else if (!isAnyExpr(item)) throw new Error('invalid replacement item node');\n        if (!value) value = node.value;\n        else if (!isAnyValue(value)) throw new Error('invalid replacement value node');\n        return member(value, item);\n      }\n\n      case 'expr': {\n        const { op } = node;\n        let arg1 = each(node.arg1);\n        let arg2 = each(node.arg2);\n        if (arg1 === null || arg2 === null) return null; // delete spreads\n        if (!arg1 && !arg2) return undefined; // no change\n        if (!arg1) arg1 = node.arg1;\n        else if (!isAnyExpr(arg1)) throw new Error('invalid replacement arg1 node');\n        if (!arg2) arg2 = node.arg2;\n        else if (!isAnyExpr(arg2)) throw new Error('invalid replacement arg2 node');\n        return expr(op, arg1, arg2);\n      }\n\n      case 'ant':\n      case 'comment':\n      case 'directive':\n      case 'identifier':\n      case 'number':\n      case 'symbol':\n      case 'turn':\n      case 'turns':\n        return undefined;\n\n      default:\n        assertNever(node, 'invalid transform node');\n        return undefined;\n    }\n  }\n}\n\n/** @template T\n * @param {T|null} val\n * @returns {val is Exclude<T, null>}\n */\nfunction notNull(val) {\n  return val !== null;\n}\n\n/**\n * @param {never} impossible\n * @param {string} mess\n */\nfunction assertNever(impossible, mess) {\n  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);\n}\n","// @ts-check\n\nimport * as rezult from '../rezult.js';\nimport * as constants from './constants.js';\n\nimport * as analyze from './analyze.js';\nimport toSpecString from './tostring.js';\n\nimport {\n  assign,\n  id,\n  member,\n} from './grammar.js';\n\n/** @typedef {import('./grammar.js').Node} Node */\n/** @typedef {import('./grammar.js').SpecNode} SpecNode */\n/** @typedef {import('./grammar.js').AssignNode} AssignNode */\n/** @typedef {import('./grammar.js').RuleNode} RuleNode */\n/** @typedef {import('./grammar.js').WhenNode} WhenNode */\n/** @typedef {import('./grammar.js').ThenNode} ThenNode */\n/** @typedef {import('./grammar.js').ThenValNode} ThenValNode */\n/** @typedef {import('./grammar.js').NumberNode} NumberNode */\n/** @typedef {import('./grammar.js').TurnsNode} TurnsNode */\n/** @typedef {import('./grammar.js').TurnNode} TurnNode */\n/** @typedef {import('./grammar.js').AnyExpr} AnyExpr */\n/** @template T @typedef {import('./grammar.js').Expr<T>} Expr */\n\n// TODO: de-dupe\nconst opPrec = ['+', '-', '*', '/', '%'];\n\n/** @typedef {{[key: number]: number}} Rules - A turmite rule lookup table\n *\n * Keys have 2 bit-packed fields encoding color and state:\n * - color: the value of the cell currently occupied by the turmite\n * - state: the turmite's current internal state value; has no intrinsic\n *          semantics other than as part of rules table keys, broadening\n *          the space of potential rules greatly as compared to an ant that\n *          merely dispatches on color\n *\n * Values have 3 bit-packed fields encoding result color, state, and turn:\n * - color: the cell currently occupied by the turmite will have its color\n *          changed to this value\n * - state: the turmite's state value will be set to this; its primary purpose\n *          is to expand the rule table keyspace, allowing for things like\n *          multiple \"modes\" of turmite rules to be packed into one table\n * - turn: bit field encoding what turn(s) the turmite should make after\n *         updating color and state as above; having multiple turn bits set\n *         implies a \"fork\" (creation of one or more new turmites)\n *\n * Therefore a rules table MUST have a specific/static length to fully\n * encompass all possible color|state keys; see RuleConstants below for how\n * particulars are specified.\n */\n\n/** @typedef {object} RuleConstants - specifies rule lookup table particulars\n * @prop {number} MaxColor - maximum color value; should be some 2^N-1\n * @prop {number} MaxState - maximum state value; should be some 2^N-1\n * @prop {number} MaxTurn - maximum turn value; should be some 2^N-1\n * @prop {number} MaskResultColor - color field mask for result extraction\n * @prop {number} MaskResultState - state field mask for result extraction\n * @prop {number} MaskResultTurn - turn field mask for result extraction\n * @prop {number} ColorShift - bit width to shift color values by when packing keys and extracting results\n * @prop {number} TurnShift - bit width to shift turn values by when extracting results\n * NOTE: state values live in the lowest bits and are therefore unshifted\n */\n\n/** @callback Builder\n * @param {Rules} rules\n * @param {RuleConstants} ruleSpec\n * @returns {rezult.Result<Built>}\n */\n\n/** @typedef {object} Built\n * @prop {number} numColors\n * @prop {number} numStates\n * @prop {string} specString\n */\n\n/**\n * @param {SpecNode} spec\n * @returns {rezult.Result<Builder>}\n */\nexport default function compileBuilder(spec) {\n  const lines = compileCode(spec);\n  const codeRes = rezult.catchErr(() => rezult.just([...endLines(lines)].join('')));\n\n  const funcRes = rezult.bind(codeRes, code => {\n    try {\n      return rezult.just(Function(`\"use strict\"; return (${code})`));\n    } catch (codeErr) {\n      return rezult.error(new Error(`${codeErr}\\nTrying to compile:\\n${code}`));\n    }\n  });\n\n  const valRes = rezult.bind(funcRes, func =>\n    rezult.catchErr(() => rezult.just(func())));\n\n  return rezult.bind(valRes, value => {\n    // TODO replace this runtime type validation with a test-time typecheck of\n    // some example code\n\n    if (typeof value != 'function') {\n      return rezult.error(new Error(\n        `invalid builder function, got a ${typeof value} instead of a function`))\n    }\n\n    return rezult.just(/** @type {Builder} */(value));\n  });\n}\n\n/** @typedef {\"value\"|\"module\"} CodeFormat */\n\n/**\n * @param {SpecNode} spec\n * @param {object} [options]\n * @param {CodeFormat} [options.format]\n */\nexport function compileCode(spec, { format = 'value' } = {}) {\n  const scope = makeScope();\n\n  return compileContent(spec);\n\n  /** @param {SpecNode} spec */\n  function* compileContent(spec) {\n    switch (format) {\n      case 'value':\n        yield* compileArrowFn(scope, ['_rules', 'World'], function*() {\n          yield* compileDefinitions(spec);\n          yield* compileRuleBuilder(spec);\n        });\n        break;\n\n      case 'module':\n        yield* compileDefinitions(spec);\n        yield* compileFunction(scope, 'export default build', ['_rules', 'World'], function*() {\n          yield* compileRuleBuilder(spec);\n        });\n        break;\n\n      default:\n        assertNever(format, 'invalid format');\n    }\n  }\n\n  /** @param {SpecNode} spec */\n  function* compileDefinitions(spec) {\n    scope.define('specString');\n    yield* amend({\n      head: 'const specString = ',\n      cont: '  ',\n      zero: `''`,\n      foot: ';',\n    }, multiLineQuoted(toSpecString(spec)));\n    yield '';\n\n    scope.define('numColors');\n    yield `const numColors = ${countNumColors(spec)};`;\n    yield '';\n  }\n\n  /**\n   * @param {Node} node\n   * @param {amendments} [params]\n   */\n  function* compileSpecComment(node, params) {\n    let spec = toSpecString(node);\n    if (params) spec = amend(params, spec);\n    yield* comment(spec);\n  }\n\n  /** @param {SpecNode} spec */\n  function* compileRuleBuilder(spec) {\n    yield 'if (numColors > World.MaxColor+1) return {err: `required numColors:${numColors} exceeds world max:(${World.MaxColor})`};';\n    yield '';\n\n    scope.define('_states');\n    yield 'const _states = new Set();';\n    yield '';\n\n    for (const entry of spec.entries) {\n      switch (entry.type) {\n        case 'comment':\n          yield* comment([entry.comment.trimStart()]);\n          break;\n\n        case 'directive':\n          yield* comment([`@${entry.name} ${entry.value.trimStart()}`]);\n          break;\n\n        case 'assign':\n          yield '';\n          yield* compileSpecComment(entry, { head: 'assign: ' });\n          yield* compileAssign(entry);\n          break;\n\n        case 'ant':\n          yield '';\n          yield* compileSpecComment(entry, { head: 'rule: ' });\n          yield* compileRule(analyze.antRule(entry.turns));\n          break;\n\n        case 'rule':\n          yield '';\n          yield* compileSpecComment(entry, { head: 'rule: ' });\n          yield* compileRule(entry);\n          break;\n\n        default:\n          assertNever(entry, 'invalid rule node');\n      }\n    }\n\n    yield 'return {value: {specString, numColors, numStates: _states.size}};';\n  }\n\n  /** @param {AssignNode} assign */\n  function* compileAssign({ id: { name }, value }) {\n    scope.define(name);\n    yield `let ${name} = ${compileValue(scope, value)};`; // TODO can this be constified?\n  }\n\n  /** @param {RuleNode} rule */\n  function* compileRule(rule) {\n    yield* scope.block(function*() {\n      /** @type {AssignNode[]} */\n      const assigns = [];\n\n      const xrule = analyze.transformed(rule,\n\n        // TODO possible, but uncertain if should bring back implicit indexing\n        // analyze.matchType('then', ({ state, color, turn }) => {\n        //   const { mode } = turn;\n        //   if (mode === '_') return;\n        //\n        //   const { value } = turn;\n        //   if (value.type !== 'turns') return;\n        //\n        //   /** @type {AnyExpr|null} */\n        //   let colorExpr = null;\n        //   analyze.transform(rule, analyze.matchType('when', ({ color }) => { colorExpr = color }));\n        //   if (!colorExpr) throw new Error('unablet to find when-color expression to auto-index then-turns');\n        //\n        //   turn = analyze.thenVal(analyze.member(value, colorExpr), mode);\n        //   return analyze.then(state, color, turn);\n        // }),\n\n        analyze.matchType('member', ({ value, item }) => {\n          switch (value.type) {\n            case 'symbol':\n            case 'identifier':\n              return;\n            default:\n              const { type } = value;\n              const name = scope.gen(`${type[0].toUpperCase()}${type.slice(1)}`);\n              assigns.push(assign(name, value));\n              return member(id(name), item);\n          }\n        }),\n\n      );\n      if (!xrule) {\n        yield* comment([\n          'eliminated by transform',\n          ...JSON.stringify(rule, null, 2).split(/\\n/)\n        ]);\n        return;\n      }\n\n      const { when, then } = xrule;\n      for (const assign of assigns)\n        yield* compileAssign(assign);\n      yield* compileRuleBody(when, then);\n    });\n  }\n\n  /**\n   * @param {WhenNode} when\n   * @param {ThenNode} then\n   */\n  function* compileRuleBody(\n    { state: whenState, color: whenColor },\n    { state: thenState, color: thenColor, turn: thenTurn },\n  ) {\n\n    /** @typedef {object} ThenDecl\n     * @prop {string} name\n     * @prop {string} mask\n     * @prop {string} max\n     * @prop {string} [shift]\n     */\n\n    const thens = /** @type {({then: ThenValNode} & ThenDecl)[]} */ ([\n      {\n        name: 'state',\n        then: thenState,\n        mask: 'World.MaskResultState',\n        max: 'World.MaxState',\n        shift: 'World.ColorShift',\n      },\n      {\n        name: 'color',\n        then: thenColor,\n        mask: 'World.MaskResultColor',\n        max: 'World.MaxColor',\n        shift: 'World.TurnShift',\n      },\n      {\n        name: 'turn',\n        then: thenTurn,\n        mask: 'World.MaskResultTurn',\n        max: 'World.MaxTurn',\n      },\n    ]).map(({ then, ...decl }) => {\n      let isEmpty = true;\n\n      const { mode } = then;\n      if (mode !== '_') {\n        const { value } = then;\n        isEmpty = mode === '|' && compileValue(\n          // ignore symbol defined check, all we care about here: \"is the expression statically 0?\"\n          { has() { return true } }, value, opPrec.length) === '0';\n      }\n\n      return { then, isEmpty, ...decl };\n    });\n    if (thens.every(({ isEmpty }) => isEmpty)) return;\n\n    /** @typedef {object} WhenDecl\n     * @prop {string} name\n     * @prop {string} cap\n     * @prop {string} sym\n     * @prop {string} max\n     * @prop {string} [shift]\n     * @prop {(cap: string) => string} [init]\n     */\n\n    const whens = /** @type {({when: AnyExpr} & WhenDecl)[]} */ ([\n      {\n        when: whenState,\n        name: 'state',\n        cap: '_state',\n        sym: '_stateKey',\n        shift: 'World.ColorShift',\n        max: 'World.MaxState',\n        init: cap => `_states.add(${cap});`,\n      },\n      {\n        when: whenColor,\n        name: 'color',\n        cap: '_color',\n        sym: '_colorKey',\n        max: 'World.MaxColor',\n      },\n    ]);\n\n    {\n      const maskParts = thens\n        .map(({ then: { mode }, mask }) => mode === '=' ? mask : '')\n        .filter(part => part);\n      switch (maskParts.length) {\n        case 0:\n          break;\n\n        case 1:\n          scope.define('_priorMask');\n          yield `const _priorMask = ~${maskParts[0]};`;\n          yield '';\n          break;\n\n        default:\n          scope.define('_priorMask');\n          yield `const _priorMask = ~(${maskParts\n            .reduce((mask, part) => `${mask}${mask ? ' | ' : ''}${part}`)});`;\n          yield '';\n      }\n    }\n\n    yield* compileWhenMatch(0);\n\n    /**\n     * @param {number} i -- whens[i]\n     * @returns {Generator<string>}\n     */\n    function* compileWhenMatch(i, priorKey = '') {\n      if (i < whens.length) {\n        const\n          { name, when, cap, sym, shift, max, init } = whens[i],\n          body = function*() {\n            let keyExpr = cap;\n            if (shift) {\n              if (priorKey) keyExpr = `(${priorKey} | ${keyExpr})`;\n              keyExpr = `${keyExpr} << ${shift}`;\n            } else if (priorKey) keyExpr = `${priorKey} | ${keyExpr}`;\n            scope.define(sym);\n            yield `const ${sym} = ${keyExpr};`;\n            if (init) yield init(cap);\n            yield '';\n            yield* compileWhenMatch(i + 1, sym);\n          };\n\n        yield* compileSpecComment(when, { head: `when ${name} matches: ` });\n\n        switch (when.type) {\n          case 'symbol':\n          case 'expr':\n            yield* amend(`for (let ${cap} = 0; ${cap} <= ${max}; ${cap}++) `, scope.block(function*() {\n              scope.define(cap);\n\n              const syms = [...freeSymbols(when, scope)];\n              if (syms.length > 1) {\n                throw new Error('matching more than one variable is unsupported');\n              }\n              const free = syms[0];\n              if (!free) {\n                throw new Error('no match variable');\n              }\n              scope.define(free);\n\n              const matchExpr = solve(scope, free, cap, when);\n              if (matchExpr === cap) {\n                yield `const ${free} = ${matchExpr};`;\n              } else {\n                yield `const ${free} = (${max} + ${matchExpr}) % ${max};`;\n                // TODO: gratuitous guard, only needed if division is involved\n                yield `if (Math.floor(${free}) !== ${free}) continue;`;\n              }\n\n              yield* body();\n            }));\n            break;\n\n          case 'number':\n            scope.define(cap);\n            yield `const ${cap} = ${when.value};`;\n            yield* body();\n            break;\n\n          default:\n            throw new Error(`unsupported match type ${when.type}`);\n        }\n      }\n\n      else {\n        /** @type {string[]} */\n        const parts = [];\n\n        const reduceParts = () => {\n          while (parts.length > 1) {\n            const b = parts.pop();\n            const a = parts.pop();\n            parts.push(`${a}\\n| ${b}`);\n          }\n          return parts.pop() || '';\n        };\n\n        for (const { name, then, max, shift } of thens) {\n          const { mode } = then;\n\n          if (mode !== '_') {\n            const { value } = then;\n            const comment = compileSpecComment(\n              value,\n              { head: `then ${name} ${mode}${mode == '=' ? '' : '='} ` });\n            const expr = compileValue(scope, value, opPrec.length);\n            if (expr !== '0') {\n              // TODO &max is only valid if max is some 2^N-1, otherwise should use Math.min(max, ...)\n              parts.push(`${expr} & ${max} ${[...comment].join('\\n')}`);\n            } else yield* comment;\n          }\n\n          if (parts.length && shift) {\n            parts.push(`( ${reduceParts()}\\n) << ${shift}`);\n          }\n        }\n\n        if (scope.has('_priorMask')) {\n          parts.unshift(`_rules[${priorKey}] & _priorMask`);\n        }\n\n        if (parts.length) {\n          yield* amend({\n            head: `_rules[${priorKey}] = `,\n            cont: '  ',\n          }, reduceParts().split(/\\n/));\n          yield '  ;';\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {Scope} scope\n * @param {string} name\n * @param {string[]} args\n * @param {() => Iterable<string>} body\n */\nfunction compileFunction(scope, name, args, body) {\n  const argNames = args.map(arg => {\n    const match = /^(\\w+)\\s*=.*$/.exec(arg);\n    return match ? match[1] : arg;\n  });\n\n  let func = 'function';\n\n  const lastSpace = name.lastIndexOf(' ')\n  if (lastSpace >= 0) {\n    // keywords like export default async (static final frozen :S)\n    func = `${name.slice(lastSpace)} ${func}`;\n    name = name.slice(lastSpace + 1);\n  }\n\n  if (name.startsWith('*')) func = `${func}*`, name = name.slice(1);\n  if (name) scope.define(name), func = `${func} ${name}`;\n\n  return amend(`${func}(${args.join(', ')}) `, scope.block(function*() {\n    scope.define(...argNames);\n    yield* body();\n  }));\n}\n\n/**\n * @param {Scope} scope\n * @param {string[]} args\n * @param {() => Iterable<string>} body\n */\nfunction compileArrowFn(scope, args, body) {\n  const argNames = args.map(arg => {\n    const match = /^(\\w+)\\s*=.*$/.exec(arg);\n    return match ? match[1] : arg;\n  });\n  return amend(`(${args.join(', ')}) => `, scope.block(function*() {\n    scope.define(...argNames);\n    yield* body();\n  }));\n}\n\n/** @param {SpecNode} spec */\nfunction countNumColors(spec) {\n  let numColors = 0;\n  analyze.transform(spec, node => {\n    switch (node.type) {\n      case 'directive': {\n        const { name, value } = node;\n        if (name !== 'numColors') return;\n        const n = parseInt(value);\n        if (!isNaN(n)) numColors = Math.max(numColors, n);\n        break;\n      }\n\n      case 'ant':\n      case 'turns': {\n        const { turns } = node;\n        numColors = Math.max(numColors, turns.length);\n        break;\n      }\n    }\n  });\n  return numColors;\n}\n\n/** @typedef {ReturnType<makeScope>} Scope */\n\nfunction makeScope() {\n  /** @type {Set<string>[]} */\n  const stack = [];\n\n  /** @type {Set<string>} */\n  let scope = new Set();\n\n  function push() {\n    stack.push(scope);\n    scope = new Set([...scope]);\n  }\n\n  function pop() {\n    scope = stack.pop() || new Set();\n  }\n\n  return {\n    /// stack\n    push, pop,\n\n    /// current scope\n    [Symbol.iterator]() {\n      return scope[Symbol.iterator]();\n    },\n\n    /** @param {string} name */\n    has(name) {\n      return scope.has(name);\n    },\n\n    /** @param {string[]} names */\n    define(...names) {\n      for (const name of names) {\n        if (scope.has(name))\n          throw new Error(`redefinition of symbol ${name}`);\n        scope.add(name);\n      }\n    },\n\n    /// convenience utilities\n\n    /** @param {string} name */\n    gen(name) {\n      for (let i = 1; /* TODO non-infinite? */; i++) {\n        const uname = name + i;\n        if (!scope.has(uname)) {\n          return uname;\n        }\n      }\n    },\n\n    /** @param {(() => Iterable<string>)} body */\n    *block(body) {\n      push();\n      yield* block(body());\n      pop();\n    },\n\n  };\n}\n\n/**\n * @param {Scope} scope\n * @param {string} cap\n * @param {string} sym\n * @param {AnyExpr} expr - TODO what even does it mean to solve a turns expression; tighten?\n * @param {number} [outerPrec]\n * @returns {string}\n */\nfunction solve(scope, cap, sym, expr, outerPrec = 0) {\n  const invOp = {\n    '+': '-',\n    '*': '/',\n    '-': '+',\n    '/': '*'\n  };\n\n  /** @type {string[]} */\n  const stack = [sym, ...genStack(expr)];\n\n  /** @returns {string} */\n  const consume = (outerPrec = 0) => {\n    const arg = stack.pop();\n    if (!arg) return 'undefined';\n\n    const prec = opPrec.indexOf(arg);\n    if (prec >= 0) {\n      const b = consume(prec);\n      const a = consume(prec);\n      return prec < outerPrec\n        ? `(${a} ${arg} ${b})`\n        : `${a} ${arg} ${b}`;\n    }\n\n    return arg;\n  };\n\n  const res = consume(outerPrec);\n  if (stack.length) throw new Error('leftover solution stack');\n  return res;\n\n  /**\n   * @param {AnyExpr} expr\n   * @returns {Generator<string>}\n   */\n  function* genStack(expr) {\n    switch (expr.type) {\n\n      case 'expr':\n        const { op, arg1, arg2 } = expr;\n\n        const leftHasSym = usedSymbols(arg1).has(cap);\n        const rightHasSym = usedSymbols(arg2).has(cap);\n        if (leftHasSym && rightHasSym) {\n          // TODO: solve each side to intermediate values\n          throw new Error('matching complex expressions not supported');\n        }\n\n        switch (op) {\n\n          case '+':\n          case '*':\n            // color = c [*+] 6 = 6 [*+] c\n            // c = color [/-] 6\n            if (leftHasSym) {\n              yield* genStack(arg2);\n              yield invOp[op];\n              yield* genStack(arg1);\n              return;\n            }\n            if (rightHasSym) {\n              yield* genStack(arg1);\n              yield invOp[op];\n              yield* genStack(arg2);\n              return;\n            }\n            break;\n\n          case '-':\n          case '/':\n            if (leftHasSym) {\n              // color = c [-/] 6\n              // c = color [+*] 6\n              yield* genStack(arg2);\n              yield invOp[op];\n              yield* genStack(arg1);\n              return;\n            }\n            if (rightHasSym) {\n              // color = 6 [-/] c\n              // c = 6 [-/] color\n              yield* genStack(arg1);\n              yield op;\n              yield* genStack(arg2);\n              return;\n            }\n            break;\n\n          case '%':\n            throw new Error(`unimplemented modulo operator solving`);\n\n          default:\n            assertNever(op, 'invalid expression operator');\n        }\n        break;\n\n      case 'symbol':\n        if (expr.name !== cap) yield expr.name;\n        return;\n    }\n\n    yield compileValue(scope, expr);\n  }\n}\n\n/**\n * @param {{has: (name: string) => boolean}} scope\n * @param {AnyExpr|TurnNode} node\n * @param {number} [outerPrec]\n * @returns {string}\n */\nfunction compileValue(scope, node, outerPrec = 0) {\n  switch (node.type) {\n\n    case 'turn':\n      return `0x${node.names\n        .reduce((turn, name) => turn | constants.Turn[name], 0)\n        .toString(16).padStart(2, '0')}`;\n\n    case 'turns':\n      const parts = [];\n      for (const { count, turn } of node.turns) {\n        const turnStr = `0x${constants.Turn[turn]\n          .toString(16).padStart(2, '0')}`;\n        for (let i = 0; i < count.value; i++) {\n          parts.push(turnStr);\n        }\n      }\n      return `[${parts.join(', ')}]`;\n\n    case 'expr':\n      const prec = opPrec.indexOf(node.op);\n      const val1 = compileValue(scope, node.arg1, prec);\n      const val2 = compileValue(scope, node.arg2, prec);\n      const exprStr = `${val1} ${node.op} ${val2}`;\n      return prec < outerPrec ? `(${exprStr})` : exprStr;\n\n    case 'member':\n      const baseVal = compileValue(scope, node.value, 0);\n      const itemVal = compileValue(scope, node.item, opPrec.length);\n      return `${baseVal}[${`${itemVal} % ${baseVal}.length`}]`;\n\n    case 'symbol':\n    case 'identifier':\n      if (!scope.has(node.name)) {\n        throw new Error(`undefined ${node.type} ${JSON.stringify(node.name)}`);\n      }\n      return node.name;\n\n    case 'number':\n      switch (node.base) {\n        case 16:\n          return `0x${node.value.toString(16)}`;\n        default:\n          return node.value.toString(10);\n      }\n\n    default:\n      assertNever(node, 'invalid value node');\n      return `/* invalid node type */`; // unreachable branch, but tsc can't prove that?\n  }\n}\n\n/**\n * @param {AnyExpr} expr\n * @param {{has: (name: string) => boolean}} symbols\n */\nfunction* freeSymbols(expr, symbols) {\n  for (const name of usedSymbols(expr)) {\n    if (!symbols.has(name)) yield name;\n  }\n}\n\n/** @param {AnyExpr} expr */\nfunction usedSymbols(expr) {\n  /** @type {Set<string>} */\n  const used = new Set();\n  analyze.transform(expr, analyze.matchType('symbol', ({ name }) => {\n    used.add(name);\n  }));\n  return used;\n}\n\n/** @param {Iterable<string>} lines */\nfunction* multiLineQuoted(lines) {\n  // NOTE: there's a similar routine in glsl-loader.js\n  let next = '';\n  for (const line of lines) {\n    if (next) {\n      yield `${next} +`;\n    }\n    next = JSON.stringify(line + '\\n');\n  }\n  if (next) {\n    yield next;\n  }\n}\n\n/** @param {Iterable<string>} lines */\nfunction* comment(lines, mark = '// ') {\n  yield* prefix(mark, lines);\n}\n\n/**\n* @param {string} prefix\n* @param {Iterable<string>} lines\n*/\nfunction* prefix(prefix, lines) {\n  const allSpace = prefix.trim().length == 0;\n  for (const line of lines) {\n    yield line || !allSpace ? prefix + line : line;\n  }\n}\n\n/** @param {Iterable<string>} lines */\nexport function* endLines(lines, nl = '\\n') {\n  for (const line of lines) {\n    yield line + nl;\n  }\n}\n\n/** @typedef {object} amendments\n * @prop {string} [head] - prefix for the first line\n * @prop {string} [foot] - suffix for the last line\n * @prop {string} [cont] - prefix for all lines after the first\n * @prop {string} [zero] - filler value when lines is empty\n */\n\n/** @param {(Iterable<string>|string)[]} parts */\nfunction* block(...parts) {\n  yield* wrap({ head: '{', cont: '  ', foot: '}' }, ...parts)\n}\n\n/**\n * @param {amendments} params\n * @param {(Iterable<string>|string)[]} parts\n */\nfunction* wrap({ head = '', foot = '', cont = '', zero = 'undefined' }, ...parts) {\n  if (head) {\n    yield head;\n  }\n  let any = false;\n  for (const line of chain(...parts)) {\n    yield cont ? `${cont}${line}` : line;\n    any = true;\n  }\n  if (!any && zero) {\n    yield zero;\n  }\n  if (foot) {\n    yield foot;\n  }\n}\n\n/**\n * @param {string|amendments} params\n * @param {(Iterable<string>|string)[]} parts\n */\nfunction* amend(params, ...parts) {\n  if (typeof params == 'string') {\n    params = { head: params };\n  }\n  const { head = '', foot = '', cont = '', zero = 'undefined' } = params;\n  let last = '', any = false;\n  for (const line of chain(...parts)) {\n    if (!any) {\n      any = true;\n      last = `${head}${line}`;\n    } else {\n      yield last;\n      last = `${cont}${line}`;\n    }\n  }\n  if (any) {\n    yield `${last}${foot}`;\n  } else {\n    yield `${head}${zero}${foot}`;\n  }\n}\n\n/** @param {(Iterable<string>|string)[]} parts */\nfunction* chain(...parts) {\n  for (const part of parts) {\n    if (typeof part == 'string') {\n      yield part;\n    } else {\n      yield* part;\n    }\n  }\n}\n\n/**\n * @param {never} impossible\n * @param {string} mess\n */\nfunction assertNever(impossible, mess) {\n  throw new Error(`${mess}: ${JSON.stringify(impossible)}`);\n}\n","// @ts-check\n\nimport { OddQOffset } from '../coord.js';\nimport * as rezult from '../rezult.js';\n\nimport * as constants from './constants.js';\n\nimport parseRaw from './parse.js';\nimport toSpecString from './tostring.js';\n\nimport {\n  default as compileBuilder,\n  compileCode, endLines as addLineEnds\n} from './compile.js';\n\n/** @typedef {import('./compile.js').RuleConstants} RuleConstants */\n/** @typedef {import('./compile.js').Builder} Builder */\n\nimport { actions, isJustAnt } from './analyze.js';\n\n/**\n * @param {string} str\n * @returns {Generator<{name: string, label?: string, then: (spec: string) => string}>}\n */\nexport function* ruleActions(str) {\n  const { value: spec } = parseRaw(str);\n  if (!spec) return;\n  for (const { then, ...action } of actions(spec)) yield {\n    ...action, then(str) {\n      const { value: spec } = parseRaw(str);\n      if (!spec) return str;\n      const newSpec = then(spec);\n      return [...toSpecString(newSpec)].join('\\n');\n    }\n  };\n}\n\n/** @param {string} spec */\nexport function* ruleHelp(spec) {\n  if (isJustAnt(spec)) yield* help.ant();\n  else yield* help.turmite();\n}\n\n/** @type {{[topic: string]: () => Iterable<string>}} */\nconst help = {\n\n  *ant() {\n    yield '# Basic Ant Rule Format'\n    yield '';\n    yield '    ant(<number>?<turn>...)';\n    yield '';\n    yield 'Each <turn> may be one of:';\n    yield '  - L=left, R=right';\n    yield '  - B=back, F=forward';\n    yield '  - P=port, S=starboard (these are rear-facing left/right)';\n    yield '';\n    yield '## Examples';\n    yield '';\n    yield '    ant( R L )';\n    yield '    ant( 2L 13R 2L )';\n    yield '    ant( 2L 13R 2L 42F )';\n  },\n\n  *turmite() {\n    yield '# Turmite Rule Format';\n    yield '';\n    yield 'The basic turmite rule form is:';\n    yield '    <when> => <then>';\n    yield '';\n    yield 'Where <when> has the form:';\n    yield '    <state>, <color>';\n    yield 'The state> and <color> are simple numeric (uint8) expressions that match against the world tile color (uint8) and internal turmite state (uint8).';\n    yield 'For example, a <color> term of 2*c only matches even colors';\n    yield '';\n    yield 'Similarly <then> has the form:';\n    yield '    <state>, <color>, <turn>';\n    yield '';\n    yield '- <turn> may be one of L, R, F, B, P, or S as to an ant(...) rule';\n    yield '  - additonal absolute directions are supported: NW, NO, NE, SE, SO, and SW';\n    yield '- <turn> may also be an indexed turns(...)[INDEX] expression';\n    yield '- right hand side expressions may reference symbols matched on the left';\n    yield '  - e.g. the basic ant(...) construction translates to 0, c => 0, c + 1 turns(...)[c]';\n    yield '- finally, variable assignments may precede rules, to define things like a turn sequence for use in multiple places';\n    yield '';\n    yield '## Examples';\n    yield '';\n    yield 'To make a bi-modal ant that switches between LR / RL rules on every 16-th color:';\n    yield '    0, c => 0, c + 1, turns(L R)[c]'\n    yield '    1, c => 1, c + 1, turns(R L)[c]'\n    yield '    0, 16 * c - 1 => 1, _, _'\n    yield '    1, 16 * c - 1 => 0, _, _'\n  },\n\n};\n\n/** @param {string} str */\nexport function parse(str) {\n  return rezult.bind(parseRaw(str), spec => compileBuilder(spec));\n}\n\nexport class Turmite {\n\n  static TestSpec = {\n    MaxColor: 0xff,\n    MaxState: 0xff,\n    MaxTurn: 0xffff,\n\n    MaskResultState: 0xff000000,\n    MaskResultColor: 0x00ff0000,\n    MaskResultTurn: 0x0000ffff,\n\n    ColorShift: 8,\n    TurnShift: 16,\n\n    // TODO: these are non-standard currently, but should be standardized\n    //       starting here to not hardcode below in dump()\n\n    ColorByteWidth: 1,\n    StateByteWidth: 1,\n    TurnByteWidth: 2,\n\n    ResultByteWidth: 4,\n    ResultStateShift: 24,\n    ResultColorShift: 16,\n    ResultTurnShift: 0,\n\n    KeyByteWidth: 2,\n    KeyStateMask: 0xff00,\n    KeyColorMask: 0x00ff,\n    KeyColorShift: 0,\n    KeyStateShift: 8,\n  };\n\n  /**\n   * @param {string|Builder} arg\n   * @param {RuleConstants} [spec]\n   * @param {Turmite} [ent]\n   * @returns {rezult.Result<Turmite>}\n   */\n  static from(arg, spec = Turmite.TestSpec, ent = new Turmite()) {\n    if (typeof arg === 'string') {\n      const { value, err: parseErr } = parse(arg);\n      if (parseErr) {\n        return rezult.error(parseErr);\n      }\n      arg = value;\n    }\n\n    ent.reset();\n    ent.rules.fill(0);\n\n    const { value: built, err: buildErr } = arg(ent.rules, spec);\n    if (buildErr) {\n      return rezult.error(buildErr);\n    }\n\n    const { numColors, numStates, specString } = built;\n    ent.numColors = numColors;\n    ent.numStates = numStates;\n    ent.specString = specString;\n\n    return rezult.just(ent);\n  }\n\n  constructor() {\n    this.numStates = 0;\n    this.numColors = 0;\n    this.specString = '<null turmite>';\n    this.rules = new Uint32Array(256 * 256);\n    this.dir = 0;\n    this.pos = new OddQOffset(0, 0);\n    this.state = 0;\n    this.index = 0;\n  }\n\n  reset() {\n    this.dir = 0;\n    this.pos.scale(0);\n    this.state = 0;\n  }\n\n  toString() {\n    return this.specString || '<UNKNOWN turmite>';\n  }\n\n  /** @typedef {object} World\n   * @prop {(index: number, fn: (dir: number, state: number, datum: number) => {dir: number, state: number, datum: number}) => void} updateEnt\n   */\n\n  /** @param {World} world */\n  step(world) {\n    const { rules, index } = this;\n    world.updateEnt(index, (dir, state, datum) => {\n\n      // TODO get XXX constants from a spec: RuleConstants arg\n      const color = datum & 0x00ff; // XXX World.MaskColor\n      const flags = datum & 0xff00; // XXX World.MaskFlags\n      const ruleIndex = state << 8 | color; // XXX World.ColorShift\n      const rule = rules[ruleIndex];\n      const turn = rule & 0x0000ffff; // XXX World.MaskResultTurn\n      const write = (rule & 0x00ff0000) >> 16; // XXX &World.MaskResultColor >>World.TurnShift\n      state = (rule & 0xff000000) >> 24; // XXX World.MaskResultState >>(World.TurnShift+World.ColorShift)\n      datum = flags | write | 0x0100; // XXX World.FlagVisited\n\n      const newDirs = [...constants.turnDirs(turn, dir)];\n      switch (newDirs.length) {\n        case 0:\n          break;\n        case 1:\n          dir = newDirs[0];\n          break;\n        default:\n          throw new Error('turmite forking unimplemented');\n      }\n\n      return { dir, state, datum };\n    });\n  }\n}\n\n/**\n * @param {string} str\n * @param {object} [options]\n * @param {boolean} [options.endLines]\n * @param {import('./compile.js').CodeFormat} [options.format]\n */\nexport function compile(str, {\n  endLines = false,\n  format = 'value',\n} = {}) {\n  const spec = rezult.toValue(parseRaw(str));\n  const lines = compileCode(spec, { format });\n  return endLines ? addLineEnds(lines) : lines;\n}\n","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\n\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\n\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\n\nexport function multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\n\nexport function calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\n\nexport function ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\n\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nexport function invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\n\nexport function fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\n * Returns a string representation of a quatenion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var clone = vec4.clone;\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\n\nexport var fromValues = vec4.fromValues;\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nexport var copy = vec4.copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nexport var set = vec4.set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\n\nexport var add = vec4.add;\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\n\nexport var scale = vec4.scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nexport var dot = vec4.dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\n\nexport var lerp = vec4.lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport var length = vec4.length;\n/**\n * Alias for {@link quat.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\n\nexport var squaredLength = vec4.squaredLength;\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nexport var normalize = vec4.normalize;\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var exactEquals = vec4.exactEquals;\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {ReadonlyQuat} a The first vector.\n * @param {ReadonlyQuat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport var equals = vec4.equals;\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\n\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\n\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\n\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;","import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","// @ts-check\n\n// TODO:\n// - detect uniform and attr names by static analysis\n// - pursue tighter integration with GLSLShader\n\nexport class GLProgram {\n\n  /**\n   * @param {WebGLRenderingContext} gl\n   * @param {WebGLProgram} prog\n   * @param {Iterable<string>} uniformNames\n   * @param {Iterable<string>} attrNames\n   */\n  constructor(gl, prog, uniformNames, attrNames) {\n\n    /** @type {{[name: string]: WebGLUniformLocation}} */\n    const uniform = {};\n\n    /** @type {{[name: string]: number}} */\n    const attr = {};\n\n    for (const name of uniformNames) {\n      const loc = gl.getUniformLocation(prog, name);\n      if (!loc) {\n        throw new Error(`unable to find uniform ${name}`);\n      }\n      uniform[name] = loc;\n    }\n\n    for (const name of attrNames) {\n      const loc = gl.getAttribLocation(prog, name);\n      if (loc < 0) {\n        throw new Error(`unable to find attrib ${name}`);\n      }\n      attr[name] = loc;\n    }\n\n    this.gl = gl;\n    this.prog = prog;\n    this.uniform = uniform;\n    this.attr = attr;\n  }\n\n  use() {\n    const { gl, prog } = this;\n    gl.useProgram(prog);\n  }\n\n  enable() {\n    const { gl, attr } = this;\n    this.use();\n    for (const attrLoc of Object.values(attr)) {\n      gl.enableVertexAttribArray(attrLoc);\n    }\n  }\n\n  disable() {\n    const { gl, attr } = this;\n    for (const attrLoc of Object.values(attr)) {\n      gl.disableVertexAttribArray(attrLoc);\n    }\n  }\n\n}\n","// @ts-check\n\n/** @typedef {import(\"./colorgen.js\").ColorTuple} ColorTuple */\n\nexport class GLPalette {\n\n  /**\n   * @param {WebGLRenderingContext} gl\n   * @param {object} options\n   * @param {number} options.unit\n   * @param {\"rgb\"|\"srgb\"} [options.format]\n   * @param {Iterable<ColorTuple>} [options.colors]\n   */\n  constructor(gl, { unit, format: formatArg = 'rgb', colors }) {\n    const format = function() {\n      if (formatArg == 'srgb') {\n        const extSRGB = gl.getExtension('EXT_sRGB');\n        if (extSRGB) {\n          return extSRGB.SRGB_EXT;\n        } else {\n          console.warn('sRGB Gl extension not available, falling back to RGB colorspace')\n        }\n      }\n      return gl.RGB;\n    }();\n    const data = new Uint8Array(256 * 3);\n    const tex = gl.createTexture();\n\n    this.gl = gl;\n    this.unit = unit;\n    this.format = format;\n    this.data = data;\n    this.tex = tex;\n\n    gl.activeTexture(gl.TEXTURE0 + unit);\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    if (colors) {\n      this.setColorsRGB(colors);\n    }\n  }\n\n  /** @param {WebGLUniformLocation} uSampler */\n  use(uSampler) {\n    const { gl, unit } = this;\n    gl.activeTexture(gl.TEXTURE0 + unit);\n    gl.uniform1i(uSampler, unit);\n  }\n\n  /** @param {Iterable<ColorTuple>} [rgbColors] */\n  setColorsRGB(rgbColors = []) {\n    const { gl, unit, tex, format, data } = this;\n    data.fill(0);\n    setNumbers(data, function*() {\n      for (const [r, g, b] of rgbColors) {\n        yield Math.round(255 * r);\n        yield Math.round(255 * g);\n        yield Math.round(255 * b);\n      }\n    }());\n\n    gl.activeTexture(gl.TEXTURE0 + unit);\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texImage2D(\n      gl.TEXTURE_2D, 0, format,\n      256, 1, 0,\n      format, gl.UNSIGNED_BYTE, data);\n  }\n\n}\n\n// TODO merge with view_gl.js\n\n/**\n * @param {{readonly length: number, [index: number]: number}|null} ar\n * @param {Iterable<number>} ns\n */\nfunction setNumbers(ar, ns) {\n  const length = ar?.length;\n  if (!length) {\n    return;\n  }\n  let i = 0;\n  for (const n of ns) {\n    ar[i] = n;\n    if (++i >= length) { return; }\n  }\n}\n\n","// @ts-check\n\nimport {\n  add as rangeListAdd,\n  each as rangeListEach,\n} from './rangelist.js';\n/** @typedef {import('./rangelist.js').RangeList} RangeList */\n\n/**\n * @typedef {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} someTypedArray\n */\n\n// TODO would be nice to generalize this beyond the fixed verts/colors attributes\n\nexport class TileGLBuffer {\n  /**\n   * @param {number} id\n   * @param {GLBuffer} elements\n   * @param {LazyGLBuffer} verts\n   * @param {LazyGLBuffer} colors\n   */\n  constructor(id, elements, verts, colors) {\n    this.id = id;\n    /** @type {BufferIndex} */\n    this.index = [];\n    /** @type {Map<number, [begin: number, end: number]>} */\n    this.tileRanges = new Map();\n    this.usedElements = 0;\n    this.elements = elements;\n    this.verts = verts;\n    this.colors = colors;\n  }\n\n  get capacity() {\n    return Math.min(\n      this.verts.capacity,\n      this.colors.capacity,\n    );\n  }\n\n  reset() {\n    this.index.length = 0;\n    this.tileRanges.clear();\n    this.usedElements = 0;\n  }\n\n  /** @param {number} offset */\n  addElement(offset) {\n    this.elements.data[this.usedElements++] = offset;\n  }\n\n  flush() {\n    this.verts.flush();\n    this.colors.flush();\n    this.shipElements();\n  }\n\n  shipElements() {\n    this.elements.ship(0, this.usedElements);\n  }\n\n  /**\n   * @param {number} id\n   * @param {number} length\n   */\n  addTile(id, length) {\n    const { index, tileRanges, capacity } = this;\n    const [i, j/*,  w */] = placeTile(index, capacity, length);\n    if (i < 0) {\n      return -1;\n    }\n\n    if (i < index.length) {\n      scavengeTombstone(index, i, length);\n      index[i] = id;\n    } else {\n      index.push(id, length);\n    }\n    tileRanges.set(id, [j, j + length]);\n    return j;\n  }\n\n  /** @param {number} id */\n  removeTile(id) {\n    const { index, tileRanges } = this;\n    tileRanges.delete(id);\n    for (let i = 0; i < index.length; i += 2) {\n      if (index[i] === id) {\n        // set tombstone...\n        index[i] = 0;\n        // ...prune trailing tombstones\n        while (index[index.length - 2] === 0) {\n          index.length -= 2;\n        }\n        break;\n      }\n    }\n  }\n\n  /** @param {number} id */\n  tileOffset(id) {\n    const range = this.tileRanges.get(id);\n    return range ? range[0] : -1;\n  }\n}\n\nexport class GLBuffer {\n  /**\n   * @param {WebGLRenderingContext} gl\n   * @param {number} target\n   * @param {number} width\n   * @param {someTypedArray} data\n   */\n  constructor(gl, target, width, data) {\n    this.gl = gl;\n    this.target = target;\n    this.width = width;\n    this.data = data;\n    this.buf = this.gl.createBuffer();\n    this.gl.bindBuffer(this.target, this.buf);\n    this.gl.bufferData(this.target, this.data, gl.STATIC_DRAW);\n  }\n\n  get capacity() {\n    return this.data.length / this.width;\n  }\n\n  /**\n   * @param {number} lo\n   * @param {number} hi\n   */\n  ship(lo, hi) {\n    const { gl, target, buf, data, width } = this;\n    const begin = lo * width, end = hi * width;\n    gl.bindBuffer(target, buf);\n    gl.bufferSubData(target,\n      begin * data.BYTES_PER_ELEMENT,\n      data.subarray(begin, end));\n  }\n}\n\nexport class LazyGLBuffer extends GLBuffer {\n  /**\n   * @param {WebGLRenderingContext} gl\n   * @param {number} target\n   * @param {number} width\n   * @param {someTypedArray} data\n   */\n  constructor(gl, target, width, data) {\n    super(gl, target, width, data);\n    /** @type {RangeList} */\n    this.inval = [];\n  }\n\n  /**\n   * @param {number} lo\n   * @param {number} hi\n   */\n  invalidate(lo, hi) {\n    rangeListAdd(this.inval, lo, hi);\n  }\n\n  flush() {\n    const { gl, inval, target, buf, data, width } = this;\n    if (!inval.length) {\n      return;\n    }\n    gl.bindBuffer(target, buf);\n    for (const { begin, end } of rangeListEach(inval)) {\n      const i = begin * width;\n      const j = end * width;\n      gl.bufferSubData(target, data.BYTES_PER_ELEMENT * i, data.subarray(i, j));\n    }\n    inval.length = 0;\n  }\n}\n\n// TODO: unexport placeTile and scavengeTombstone once we can expand the test horizon past them\n\n/** BufferIndex is a stride-2 array of [tileId, length] pairs, used to allot gl\n * buffer space to tiles of varying sizes.\n *\n * @typedef {number[]} BufferIndex\n */\n\n/** placeTile returns the best place for a tile of length elements within the\n * an indexed buffer. Attempts to re-use any tombstoned prior allotments before\n * alloting at the end of buffer, but only if doing so would waste less buffer\n * space.\n *\n * @param {BufferIndex} index\n * @param {number} capacity - of the underlying buffer\n * @param {number} length - of the tile to place\n * @returns {[i: number, offset: number, waste: number]} - i in index, offset\n * in the underlying buffer, waste is a minmized fragmentation metric\n */\nexport function placeTile(index, capacity, length) {\n  let bestIndex = -1, bestOffset = -1, best = -1;\n  let offset = 0;\n\n  let freeIndex = -1, freeOffset = -1, freeLength = 0;\n  for (let i = 0; i < index.length; i += 2) {\n    const tileId = index[i];\n    const tileLength = index[i + 1];\n    if (!tileId) {\n      if (freeLength === 0) {\n        freeIndex = i;\n        freeOffset = offset;\n      }\n      freeLength += tileLength;\n      if (length <= freeLength) {\n        const waste = freeLength - length;\n        if (best < 0 || waste < best) {\n          bestIndex = freeIndex;\n          bestOffset = freeOffset;\n          best = waste;\n        }\n      }\n    } else if (freeLength !== 0) {\n      freeIndex = -1;\n      freeOffset = -1;\n      freeLength = 0;\n    }\n    offset += tileLength;\n  }\n\n  const free = capacity - offset;\n  if (length <= free) {\n    const waste = free - length;\n    if (best < 0 || waste < best) {\n      bestIndex = index.length;\n      bestOffset = offset;\n      best = waste;\n    }\n  }\n\n  return [bestIndex, bestOffset, best];\n}\n\n/** scavenge space from a prior allotment that has been tombstoned.\n * Any remnant space is placed in a new sucessor tombstone for future allotment.\n *\n * @param {BufferIndex} index\n * @param {number} i\n * @param {number} length\n */\nexport function scavengeTombstone(index, i, length) {\n  if (index[i]) {\n    throw new Error('not a tombstone');\n  }\n\n  let tileLength = index[i + 1];\n  index[i + 1] = length;\n\n  // coalesce range; we assume that we've been told an index of a usable set\n  // of tombstones, and so don't range check here\n  let j = i + 2, k;\n  let spare = 0;\n  for (; tileLength < length; j += 2) {\n    tileLength += index[j + 1];\n    spare += 2;\n  }\n\n  // truncate (finish any coalesce)\n  if (spare > 0) {\n    k = i + 2;\n    while (j < index.length) {\n      index[k++] = index[j++];\n    }\n    j = i + 2;\n  }\n\n  // distribute leftover\n  if (length < tileLength) {\n    const remain = tileLength - length;\n    if (!index[j]) {\n      // easy, give it to the next tombstone\n      index[j + 1] += remain;\n    } else {\n      // split into new tombstone\n      let n = index.length - j;\n      if (spare >= 2) {\n        spare -= 2;\n      } else {\n        index.push(0, 0);\n      }\n      k = index.length - 1;\n      for (; n-- > 0; k--) index[k] = index[k - 2];\n      index[j] = 0;\n      index[j + 1] = remain;\n    }\n  }\n\n  index.length -= spare;\n}\n","// @ts-check\n\n/** RangeList is a stride-2 array of numbers.\n * Each pair of numbers is a [begin, end] inclusive range interval.\n * The ranges are mutually disjoint and kept in ascending order.\n *\n * @typedef {number[]} RangeList\n */\n\n/**\n * @param {RangeList} rl\n * @param {number} begin\n * @param {number} end\n */\nexport function add(rl, begin, end) {\n  if (end < begin) {\n    throw new Error(\"invalid range\");\n  }\n\n  // won't add degenerate ranges\n  if (end === begin) {\n    return;\n  }\n\n  // find begin\n  // TODO: use binary search\n  let found = false;\n  let i = 0;\n  for (; i < rl.length; i += 2) {\n    if (begin <= rl[i] - 1) {\n      // ... @i:[begin <= a-1 < b] ...\n      rl[i] = begin;\n      found = true;\n      break;\n    }\n    if (begin <= rl[i + 1] + 1) {\n      // ... @i:[a < begin <= b+1] ...\n      found = true;\n      break;\n    }\n  }\n  // ... < [end < begin]\n  if (!found) {\n    rl.push(begin, end);\n    return;\n  }\n\n  // seek end\n  let j = i;\n  found = false;\n  for (; j < rl.length; j += 2) {\n    if (end < rl[j] - 1) {\n      // ... @i:[a <= begin <= b] ... @j:[end < c-1 < d] ...\n      if (j === i) {\n        throw new Error(\"degenerate range detected\"); // should not be possible\n      }\n      found = true;\n      break;\n    }\n    if (end <= rl[j + 1] + 1) {\n      // ... @i:[a <= begin <= b] ... @j:[c < end <= d+1] ...\n      if (j === i) {\n        // ... @i:[a <= begin < end <= b] ...\n        return;\n      }\n      end = rl[j + 1] + (end === rl[j + 1] + 1 ? 1 : 0);\n      j += 2;\n      found = true;\n      break;\n    }\n  }\n  // ... @i:[a-1 <= begin < b] ...coalesced... < end\n  if (!found) {\n    rl[i + 1] = end;\n    rl.length = i + 2;\n    return;\n  }\n\n  // coalesce\n  // ... @i:[a-1 <= begin < end] ...coalesced... @j ...tail...\n  rl[i + 1] = end;\n  i += 2;\n  if (i == j) {\n    return;\n  }\n  // TODO: rl.copyWithin\n  while (j < rl.length) {\n    rl[i++] = rl[j++];\n    rl[i++] = rl[j++];\n  }\n  rl.length = i;\n  return;\n}\n\n/** @param {RangeList} rl */\nexport function* each(rl) {\n  for (let i = 0; i < rl.length;) {\n    const begin = /** @type {number} */ (rl[i++]);\n    const end = /** @type {number} */ (rl[i++]);\n    yield { begin, end };\n  }\n}\n","// @ts-check\n\nimport {\n  OddQOffset,\n  OddQBox,\n} from './coord.js';\n\n/**\n * @typedef {object} oddQPotent\n * @prop {(oqo: OddQOffset) => void} toOddQOffsetInto\n */\n\n/** @type {OddQHexTile[]} */\nconst pool = [];\n\nexport class OddQHexTile {\n  static NextId = 1;\n\n  static alloc() {\n    if (pool.length > 0) {\n      const tile = pool.shift()\n      if (tile !== undefined) {\n        return tile;\n      }\n    }\n    return new OddQHexTile();\n  }\n\n  /** @param {OddQHexTile} tile */\n  static free(tile) {\n    pool.push(tile);\n  }\n\n  free() {\n    OddQHexTile.free(this);\n  }\n\n\n  constructor() {\n    this.id = OddQHexTile.NextId++;\n    this.origin = new OddQOffset();\n    this.oqo = new OddQOffset();\n    this.width = 0;\n    this.height = 0;\n    /** @type {null|Uint16Array} */\n    this.data = null;\n    this.dirty = false;\n  }\n\n  /**\n   * @param {oddQPotent} origin\n   * @param {number} width\n   * @param {number} height\n   */\n  init(origin, width, height) {\n    const need = width * height;\n    const needBytes = need * Uint16Array.BYTES_PER_ELEMENT;\n    origin.toOddQOffsetInto(this.origin);\n    this.width = width;\n    this.height = height;\n    if (this.data === null || this.data.buffer.byteLength < needBytes) {\n      this.data = new Uint16Array(need);\n    } else {\n      if (this.data.length !== need) {\n        this.data = new Uint16Array(this.data.buffer, 0, need);\n      }\n      this.data.fill(0);\n    }\n    this.dirty = false;\n    return this;\n  }\n\n  boundingBox() {\n    const { origin, width, height } = this;\n    return new OddQBox(origin, origin.copy().addTo(width, height));\n  }\n\n  centerPoint() {\n    const { origin, width, height } = this;\n    return new OddQOffset(\n      origin.q + Math.floor(width / 2),\n      origin.r + Math.floor(height / 2)\n    );\n  }\n\n  /**\n   * @param {oddQPotent} point\n   */\n  pointToIndex(point) {\n    const { oqo, origin, width } = this;\n    point.toOddQOffsetInto(oqo);\n    return (oqo.r - origin.r) * width +\n      (oqo.q - origin.q);\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @param {(datum: number, point: oddQPotent) => number} func\n   * @returns {number}\n   */\n  update(point, func) {\n    const { data } = this;\n    if (!data) {\n      return NaN;\n    }\n    const i = this.pointToIndex(point);\n    const datum = func(orNaN(data[i]), point);\n    data[i] = datum;\n    return datum;\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @returns {number}\n   */\n  get(point) {\n    const { data } = this;\n    return data ? orNaN(data[this.pointToIndex(point)]) : NaN;\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @param {number} datum\n   * @returns {number}\n   */\n  set(point, datum) {\n    const { data } = this;\n    if (data) {\n      data[this.pointToIndex(point)] = datum;\n    }\n    return datum;\n  }\n\n  /** @param {(tile: OddQHexTile) => void} each */\n  eachTile(each) {\n    each(this);\n  }\n\n  /** @param {(point: OddQOffset, datum: number) => void} each */\n  eachDataPoint(each) {\n    const {\n      oqo: point,\n      origin: { q: loQ, r: loR },\n      width, height, data,\n    } = this;\n    if (data) {\n      const hiQ = loQ + width;\n      const hiR = loR + height;\n      let i = 0;\n      for (point.r = loR; point.r < hiR; point.r++) {\n        for (point.q = loQ; point.q < hiQ; point.q++, i++) {\n          each(point, orNaN(data[i]));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {OddQOffset} tl\n   * @param {OddQOffset} br\n   */\n  expandBoxTo(tl, br) {\n    const {\n      origin: { q: tlq, r: tlr },\n      width, height,\n    } = this;\n    const brq = tlq + width;\n    const brr = tlr + height;\n    if (isNaN(tl.q) || isNaN(tl.r) || isNaN(br.q) || isNaN(br.r)) {\n      tl.q = tlq;\n      tl.r = tlr;\n      br.q = brq;\n      br.r = brr;\n    } else {\n      if (tlq < tl.q) tl.q = tlq;\n      if (tlr < tl.r) tl.r = tlr;\n      if (brq > br.q) br.q = brq;\n      if (brr > br.r) br.r = brr;\n    }\n  }\n\n  /**\n   * @param {OddQOffset} tl\n   * @param {OddQOffset} br\n   * @param {number} mask\n   */\n  expandBoxToIf(tl, br, mask) {\n    const { data, width, origin: { q: oq } } = this;\n    let { origin: { q, r } } = this, i = 0;\n    if (!data) {\n      return;\n    }\n\n    // if any part of the box isn't defined, initialize from the first masked\n    // point\n    if (isNaN(tl.q) || isNaN(tl.r) || isNaN(br.q) || isNaN(br.r)) {\n      while (i < data.length) {\n        if (orNaN(data[i]) & mask) {\n          tl.q = q;\n          br.q = q;\n          tl.r = r;\n          br.r = r;\n          break;\n        }\n        i++;\n        q++;\n        if (q >= oq + width) {\n          q = oq;\n          r++;\n        }\n      }\n    }\n\n    // now just expand to each masked point\n    while (i < data.length) {\n      if (orNaN(data[i]) & mask) {\n        if (q < tl.q) {\n          tl.q = q;\n        } else if (q >= br.q) {\n          br.q = q;\n        }\n        if (r < tl.r) {\n          tl.r = r;\n        } else if (r >= br.r) {\n          br.r = r;\n        }\n      }\n      i++;\n      q++;\n      if (q >= oq + width) {\n        q = oq;\n        r++;\n      }\n    }\n  }\n\n  *dump() {\n    const {\n      origin,\n      data,\n      width,\n    } = this;\n    yield 'Tile @' + origin.toString();\n    if (data) {\n      const row = [];\n      for (let i = 0; i < data.length; i++) {\n        if (i && i % width === 0) {\n          yield row.join(' ');\n          row.splice(0);\n        }\n        row.push(orNaN(data[i]).toString());\n      }\n      yield row.join(' ');\n    }\n  }\n\n}\n\n/** @param {number|undefined} un */\nfunction orNaN(un) {\n  return un === undefined ? NaN : un;\n}\n","// @ts-check\n\nimport { OddQOffset, OddQBox } from './coord.js';\nimport { OddQHexTile } from './hextile.js';\n\n/**\n * @typedef {object} oddQPotent\n * @prop {(oqo: OddQOffset) => void} toOddQOffsetInto\n */\n\n/** @typedef {(tile: OddQHexTile) => void} tileCallback */\n/** @typedef {OddQHexTile|HexTileTreeNode} tileOrNode */\n/** @typedef {tileOrNode|null} tileOrNodeOrNull */\n\nexport class HexTileTree {\n  constructor() {\n    this.minTileArea = 4;\n    this.maxTileArea = 64;\n    this.oqo = new OddQOffset(0, 0);\n\n    /** @type {null|HexTileTreeNode} */\n    this.root = null;\n\n    // TODO Map\n    /** @type {Map<number, OddQHexTile>} */\n    this.tiles = new Map();\n\n    /** @type {OddQHexTile[]} */\n    this.dirtyTiles = [];\n\n    /** @type {tileCallback} */\n    this.tileRemoved = noop;\n\n    /** @type {tileCallback} */\n    this.tileAdded = noop;\n  }\n\n  /**\n   * @param {number} id\n   * @returns {null|OddQHexTile}\n   */\n  getTile(id) {\n    return this.tiles.get(id) || null;\n  }\n\n  /** @param {OddQHexTile} tile */\n  addTile(tile) {\n    this.tiles.set(tile.id, tile);\n    tile.dirty = true;\n    this.dirtyTiles.push(tile);\n    this.tileAdded(tile);\n  }\n\n  /** @param {OddQHexTile[]} tiles */\n  removeTiles(...tiles) {\n    const { dirtyTiles } = this;\n    if (tiles.some(tile => tile.dirty)) {\n      const goneIDs = new Set(tiles.map(({ id }) => id));\n      let j = 0;\n      for (let k = 0; k < dirtyTiles.length; ++k) {\n        const dirtyTile = dirtyTiles[k];\n        if (dirtyTile) {\n          const { id } = dirtyTile;\n          if (!goneIDs.has(id)) {\n            if (j != k) {\n              dirtyTiles[j] = dirtyTile;\n            }\n            ++j;\n          }\n        }\n      }\n      dirtyTiles.length = j;\n    }\n\n    for (const tile of tiles) {\n      this.tileRemoved(tile);\n    }\n\n    for (const { id } of tiles) {\n      this.tiles.delete(id);\n    }\n\n    for (const tile of tiles) {\n      tile.free();\n    }\n  }\n\n  reset() {\n    this.dirtyTiles.length = 0;\n    this.tiles.clear();\n    this.root = null;\n  }\n\n  dump() {\n    const { root } = this;\n    return root ? [...root.dump()].join('\\n') : '';\n  }\n\n  boundingBox() {\n    const { root } = this;\n    return root ? root.boundingBox() : null;\n  }\n\n  /** @param {(tile: OddQHexTile) => void} each */\n  eachTile(each) {\n    const { root } = this;\n    if (root !== null) {\n      root.eachTile(each);\n    }\n  }\n\n  /** @param {(point: OddQOffset, datum: number) => void} each */\n  eachDataPoint(each) {\n    const { root } = this;\n    if (root !== null) {\n      root.eachDataPoint(each, null);\n    }\n  }\n\n  centerPoint() {\n    const { root } = this;\n    return root ? root.centerPoint() : null;\n  }\n\n  /** @returns {HexTileTreeNode} */\n  _ensureRoot() {\n    let { root } = this;\n    if (!root) {\n      const s = Math.ceil(Math.sqrt(this.minTileArea)) * 2;\n      root = HexTileTreeNode.alloc ? HexTileTreeNode.alloc() : new HexTileTreeNode()\n      root.init(this, null, s);\n    }\n    return root;\n  }\n\n  /** @param {oddQPotent} point */\n  _ensureTile(point) {\n    const { oqo } = this;\n    let root = this._ensureRoot();\n    point.toOddQOffsetInto(oqo);\n    while (!root.box.contains(oqo)) {\n      const expanded = root.expand();\n      if (!expanded) {\n        return null;\n      }\n      root = expanded;\n    }\n    if (root !== this.root) {\n      this.root = root;\n    }\n    root.oqo.copyFrom(oqo);\n    return root._getOrCreateTile(); // FIXME implicit oqo pass from copy in last line\n    // FIXME implicit side return in this.oqo\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @param {(datum: number, point: oddQPotent) => number} func\n   * @returns {number}\n   */\n  update(point, func) {\n    const { oqo, dirtyTiles } = this;\n    const tile = this._ensureTile(point); // NOTE: implicit return into shared oqo\n    if (!tile) { return NaN }\n    if (tile instanceof OddQHexTile && !tile.dirty) {\n      tile.dirty = true;\n      dirtyTiles.push(tile);\n    }\n    return tile.update(oqo, func);\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @returns {number}\n   */\n  get(point) {\n    return this._ensureRoot().get(point);\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @param {number} datum\n   * @returns {number}\n   */\n  set(point, datum) {\n    const { oqo, dirtyTiles } = this;\n    const tile = this._ensureTile(point); // NOTE: implicit return into shared oqo\n    if (!tile) { return NaN }\n    if (tile instanceof OddQHexTile && !tile.dirty) {\n      tile.dirty = true;\n      dirtyTiles.push(tile);\n    }\n    return tile.set(oqo, datum);\n  }\n\n}\n\nconst zoomPerm = [\n  3, // 0 --> 3\n  2, // 1 --> 2\n  1, // 2 --> 1\n  0  // 3 --> 0\n];\n\nconst tileOriginOffset = [\n  new OddQOffset(0, 0),\n  new OddQOffset(1, 0),\n  new OddQOffset(0, 1),\n  new OddQOffset(1, 1)\n];\n\nconst nodeOriginOffset = [\n  new OddQOffset(-1, -1),\n  new OddQOffset(1, -1),\n  new OddQOffset(-1, 1),\n  new OddQOffset(1, 1)\n];\n\n/** TODO this exists as a dubious testing surface, refactor it away someday\n *\n * @param {HexTileTree} tree\n * @param {OddQHexTile|HexTileTreeNode|null} tile\n * @param {number} i\n */\nexport function growTile(tree, tile, i) {\n  if (!tile) { return null }\n\n  const originOffset = tile instanceof OddQHexTile ? tileOriginOffset[i] : nodeOriginOffset[i];\n  const zoom = zoomPerm[i];\n  if (originOffset == undefined || zoom == undefined) { return null }\n\n  const tileSize = tile instanceof OddQHexTile ? tile.width : tile.tileSize;\n  const growthOrigin = tile.oqo\n    .copyFrom(originOffset)\n    .scale(tileSize)\n    .add(tile.origin);\n  const growthSize = 2 * (tile instanceof OddQHexTile ? tile.width : tile.size);\n  const tileNode = HexTileTreeNode.alloc ? HexTileTreeNode.alloc() : new HexTileTreeNode();\n  tileNode.init(tree, growthOrigin, growthSize);\n  tileNode._setTile(zoom, tile);\n  return tileNode;\n}\n\n/** @type {HexTileTreeNode[]} */\nconst pool = [];\n\nexport class HexTileTreeNode {\n  static alloc() {\n    if (pool.length > 0) {\n      const node = pool.shift()\n      if (node !== undefined) {\n        return node;\n      }\n    }\n    return new HexTileTreeNode();\n  }\n\n  /** @param {HexTileTreeNode} node */\n  static free(node) {\n    node.reset();\n    pool.push(node);\n  }\n\n  free() {\n    HexTileTreeNode.free(this);\n  }\n\n  constructor() {\n    /** @type {HexTileTree|null} */\n    this.tree = null;\n\n    this.origin = new OddQOffset(0, 0);\n    this.oqo = new OddQOffset(0, 0);\n    this.box = new OddQBox();\n    this.size = 0;\n    this.tileSize = 0;\n    this.concrete = 0;\n\n    /** @type {[tileOrNodeOrNull, tileOrNodeOrNull, tileOrNodeOrNull, tileOrNodeOrNull]} */\n    this.tiles = [null, null, null, null];\n\n    /** @type {tileCallback|null} */\n    this._replaceme = null;\n  }\n\n  /**\n   * @param {HexTileTree} tree\n   * @param {oddQPotent?} origin\n   * @param {number} size\n   * @param {tileCallback} [replaceme]\n   */\n  init(tree, origin, size, replaceme) {\n    this.tree = tree;\n    this.concrete = 0;\n    this._replaceme = replaceme || null;\n    if (origin !== null) {\n      origin.toOddQOffsetInto(this.origin);\n    } else {\n      this.origin.q = this.origin.r = 0;\n    }\n    this._setSize(size);\n    return this;\n  }\n\n  reset() {\n    const { tiles } = this;\n    const [a, b, c, d] = tiles;\n    if (a) {\n      a.free();\n      tiles[0] = null;\n    }\n    if (b) {\n      b.free();\n      tiles[1] = null;\n    }\n    if (c) {\n      c.free();\n      tiles[2] = null;\n    }\n    if (d) {\n      d.free();\n      tiles[3] = null;\n    }\n  }\n\n  /** @param {number} size */\n  _setSize(size) {\n    const { origin: { q, r }, box: { topLeft, bottomRight } } = this;\n    const tileSize = Math.floor(size / 2);\n    this.size = size;\n    this.tileSize = tileSize;\n    topLeft.q = q - tileSize;\n    topLeft.r = r - tileSize;\n    bottomRight.q = q + tileSize;\n    bottomRight.r = r + tileSize;\n  }\n\n  /** @returns {Generator<string>} */\n  *dump() {\n    const { origin, box, tiles } = this;\n    yield `TreeNode @${origin}`;\n    yield `  box: ${box}`;\n    for (let i = 0; i < tiles.length; i++) {\n      const tile = tiles[i];\n      const [first, ...tileparts] = tile ? [...tile.dump()] : ['null'];\n      yield `[${i}]: ${first}`;\n      for (const tilepart of tileparts) {\n        yield `     ${tilepart}`;\n      }\n    }\n  }\n\n  /** @param {(tile: OddQHexTile) => void} each */\n  eachTile(each) {\n    const tile = this._mayCompact();\n    if (tile) {\n      tile.eachTile(each);\n      return;\n    }\n\n    const { tiles: [a, b, c, d] } = this;\n    if (a) a.eachTile(each);\n    if (b) b.eachTile(each);\n    if (c) c.eachTile(each);\n    if (d) d.eachTile(each);\n  }\n\n  expand() {\n    const { tree, tiles } = this;\n    if (!tree) { return null }\n    this._setSize(this.size * 2);\n    for (let i = 0; i < tiles.length; i++) {\n      const tile = tiles[i];\n      const tileNode = growTile(tree, tile, i);\n      if (tileNode) {\n        this._setTile(i, tileNode);\n      }\n    }\n    return this;\n  }\n\n  boundingBox() {\n    return this.box;\n  }\n\n  /**\n   * @param {(point: OddQOffset, datum: number) => void} each\n   * @param {null|number} [fill]\n   */\n  eachDataPoint(each, fill = null) {\n    const tile = this._mayCompact();\n    if (tile) {\n      tile.eachDataPoint(each);\n      return;\n    }\n\n    const {\n      tileSize,\n      origin: { q: oq, r: or },\n      oqo: point,\n      tiles: [a, b, c, d],\n    } = this\n\n    if (a) a.eachDataPoint(each, fill); else doFill(0);\n    if (b) b.eachDataPoint(each, fill); else doFill(1);\n    if (c) c.eachDataPoint(each, fill); else doFill(2);\n    if (d) d.eachDataPoint(each, fill); else doFill(3);\n\n    /** @param {number} i */\n    function doFill(i) {\n      if (typeof fill !== 'number') {\n        return;\n      }\n      const tileCol = i & 1;\n      const tileRow = i >> 1;\n      const loQ = oq + (tileCol ? 0 : -tileSize);\n      const loR = or + (tileRow ? 0 : -tileSize);\n      const hiQ = loQ + tileSize;\n      const hiR = loR + tileSize;\n      point.q = loQ, point.r = loR;\n      for (point.r = loR; point.r < hiR; point.r++) {\n        for (point.q = loQ; point.q < hiQ; point.q++) {\n          each(point, fill);\n        }\n      }\n    }\n  }\n\n  _mayCompact() {\n    if (!this.tree || !this._replaceme) {\n      return null;\n    }\n\n    if (this.concrete != 4) {\n      return null;\n    }\n\n    const tile = this.compact();\n    if (tile === null) {\n      // setting concrete to 5 caches the negative result of \"won't compact\" so\n      // that we don't try again in the future\n      this.concrete = 5;\n      return null;\n    }\n\n    /** @type {OddQHexTile[]} */\n    const subTiles = [];\n    for (const tile of this.tiles) {\n      if (tile && tile instanceof OddQHexTile) {\n        subTiles.push(tile);\n      }\n    }\n\n    this._replaceme(tile);\n\n    this.tree.removeTiles(...subTiles);\n\n    this.tree.addTile(tile);\n    return tile;\n  }\n\n  compact() {\n    if (!this.tree) { return null }\n    const { size, tree: { maxTileArea } } = this;\n    if (size * size > maxTileArea) {\n      return null;\n    }\n\n    // TODO should be able to do region copies from each subTile into newTile,\n    // rather than all the overhead of each => set\n\n    const { box: { topLeft }, tiles } = this;\n    const newTile = OddQHexTile.alloc ? OddQHexTile.alloc() : new OddQHexTile();\n    newTile.init(topLeft, size, size);\n    for (const subTile of tiles) {\n      if (subTile) subTile.eachDataPoint(\n        (point, datum) => newTile.set(point, datum),\n        null);\n    }\n    return newTile;\n  }\n\n  centerPoint() {\n    return this.origin;\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @param {(datum: number, point: oddQPotent) => number} func\n   * @returns {number}\n   */\n  update(point, func) {\n    const { oqo, box, tree } = this;\n    if (!tree) { return NaN }\n    const { dirtyTiles } = tree;\n    point.toOddQOffsetInto(oqo);\n    if (!box.contains(oqo)) {\n      throw new Error('update out of bounds');\n    }\n    const tile = this._mayCompact() || this._getOrCreateTile(); // FIXME implicit oqo pass\n    if (!tile) { return NaN }\n    if (tile instanceof OddQHexTile && !tile.dirty) {\n      tile.dirty = true;\n      dirtyTiles.push(tile);\n    }\n    return tile.update(oqo, func);\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @returns {number}\n   */\n  get(point) {\n    const { oqo, box } = this;\n    point.toOddQOffsetInto(oqo);\n    if (!box.contains(oqo)) {\n      return NaN;\n    }\n    const tile = this._getTile(); // FIXME implicit oqo pass\n    if (tile) {\n      return tile.get(oqo);\n    }\n    return 0;\n  }\n\n  /**\n   * @param {oddQPotent} point\n   * @param {number} datum\n   * @returns {number}\n   */\n  set(point, datum) {\n    const { oqo, box, tree } = this;\n    if (!tree) { return NaN }\n    const { dirtyTiles } = tree;\n    point.toOddQOffsetInto(oqo);\n    if (!box.contains(oqo)) {\n      throw new Error('set out of bounds');\n    }\n\n    const tile = this._mayCompact() || this._getOrCreateTile(); // FIXME implicit oqo pass\n    if (!tile) { return NaN }\n    if (tile instanceof OddQHexTile && !tile.dirty) {\n      tile.dirty = true;\n      dirtyTiles.push(tile);\n    }\n    return tile.set(this.oqo, datum);\n  }\n\n  _index() {\n    // FIXME implicit oqo arg\n    const { oqo: { q, r }, origin: { q: oq, r: or } } = this;\n\n    // TODO: bit hack: negated sign-bit of subtraction would make this branchless\n    const tileCol = q < oq ? 0 : 1;\n    const tileRow = r < or ? 0 : 1;\n    return tileRow * 2 + tileCol;\n  }\n\n  _getTile() {\n    const i = this._index(); // FIXME implicit operation on oqo passed thru\n    return this.tiles[i];\n  }\n\n  _getOrCreateTile() {\n    const { tree, tiles, tileSize } = this;\n    if (!tree) { return null }\n    const i = this._index(); // FIXME implicit operation on oqo passed thru\n    const tile = tiles[i];\n    if (tile) {\n      return tile;\n    }\n    if (tileSize * tileSize <= tree.minTileArea) {\n      return this._allocTile(i);\n    }\n    return this._allocNode(i);\n  }\n\n  /** @param {number} i */\n  _allocTile(i) {\n\n    // FIXME implicit oqo arg\n    const { tree, oqo: { q, r }, tileSize } = this;\n    if (!tree) { return null }\n    const origin = this.origin.copy();\n    if (q < origin.q) origin.q -= tileSize;\n    if (r < origin.r) origin.r -= tileSize;\n\n    const tile = OddQHexTile.alloc ? OddQHexTile.alloc() : new OddQHexTile();\n    tile.init(origin, tileSize, tileSize);\n    this._setTile(i, tile);\n    tree.addTile(tile);\n    return tile;\n  }\n\n  /** @param {number} i */\n  _allocNode(i) {\n\n    // FIXME implicit oqo arg\n    const { tree, oqo: { q, r }, tileSize } = this;\n    if (!tree) { return null }\n    const origin = this.origin.copy();\n    origin.q += tileSize / (q < origin.q ? -2 : 2);\n    origin.r += tileSize / (r < origin.r ? -2 : 2);\n\n    const node = HexTileTreeNode.alloc ? HexTileTreeNode.alloc() : new HexTileTreeNode();\n    node.init(tree, origin, tileSize);\n    this._setTile(i, node);\n    return node;\n  }\n\n  /**\n   * @param {number} i\n   * @param {tileOrNode} tile\n   */\n  _setTile(i, tile) {\n    const prior = this.tiles[i];\n    if (prior && prior instanceof HexTileTreeNode) {\n      prior._replaceme = null;\n    }\n    this.tiles[i] = tile;\n    if (tile instanceof OddQHexTile) {\n      this.concrete++;\n    } else if (tile instanceof HexTileTreeNode) {\n      tile._replaceme = tile => this._setTile(i, tile);\n    }\n  }\n\n}\n\nfunction noop() {\n}\n","// @ts-check\n\nimport { CubePoint, OddQOffset } from './coord.js';\nimport { HexTileTree } from './hextiletree.js';\n\nconst REDRAW_TIMING_WINDOW = 5000;\n\n// TODO refactor ent to be system oriented, pushing array ownership out of\n// World into a passed in EntSystem interface\n\n/** @typedef {object} Ent\n * @prop {number} index\n * @prop {number} numColors\n * @prop {number} numStates\n * @prop {OddQOffset} pos\n * @prop {number} dir\n * @prop {number} state\n * @prop {() => void} reset\n * @prop {(world: World) => void} step\n */\n\n/** @typedef {object} View\n * @prop {() => void} step - TODO why are view stepped?\n * @prop {() => void} reset\n * @prop {boolean} needsRedraw -- TODO push this concern down into view?\n * @prop {() => void} redraw\n * @prop {(i: number) => void} addEnt\n * @prop {(i: number) => void} updateEnt\n * @prop {(i: number) => void} removeEnt\n * @prop {() => void} updateEnts\n */\n\n// TODO view per-ent concerns may be better to push down into each view\n// entirely; pass EntSystem to each view?\n\nexport class World {\n\n  static MaxColor = 0xff\n  static MaxState = 0xff\n  static MaxTurn = 0xffff\n\n  static MaskResultState = 0xff000000\n  static MaskResultColor = 0x00ff0000\n  static MaskResultTurn = 0x0000ffff\n\n  static ColorShift = 8\n  static TurnShift = 16\n\n  static FlagVisited = 0x0100\n  static MaskColor = 0x00ff\n  static MaskFlags = 0xff00\n\n  constructor() {\n    this.numColors = 0;\n    this.numStates = 0;\n    this.stepCount = 0;\n    this.tile = new HexTileTree();\n\n    /** @type {Ent[]} */\n    this.ents = [];\n\n    /** @type {View[]} */\n    this.views = [];\n\n    /** @type {number[]} */\n    this.redrawTiming = [];\n    this.now = () => performance.now();\n\n    this.tmpCP = new CubePoint();\n  }\n\n  /** @param {number} i */\n  getEntPos(i) {\n    // TODO push this method out into EntSystem implementations\n    const ent = this.ents[i];\n    return ent ? ent.pos : new OddQOffset(NaN, NaN);\n  }\n\n  /** @param {number} i */\n  getEntDir(i) {\n    // TODO push this method out into EntSystem implementations\n    const ent = this.ents[i];\n    return ent ? ent.dir : NaN;\n  }\n\n  reset() {\n    const { ents, tile, views } = this;\n\n    // TODO push out into EntSystem.reset()\n    for (const ent of ents) {\n      ent.reset();\n    }\n\n    tile.reset();\n    this.stepCount = 0;\n\n    for (const view of views) {\n      view.reset();\n    }\n\n    // TODO push out into EntSystem.occupiedPositions()\n    const occupiedPositions = ents.map(({ pos }) => pos);\n    for (const pos of occupiedPositions) {\n      tile.update(pos, datum => World.FlagVisited | datum);\n    }\n\n  }\n\n  /**\n   * @param {number} i\n   * @param {(dir: number, state: number, datum: number) => {dir: number, state: number, datum: number}} fn\n   */\n  updateEnt(i, fn) {\n    // TODO refactor into unified EntSystem.step(tile);\n    //      currently this is called by Turmite.prototype.step() ala Ent.step()\n\n    const { ents, tile, tmpCP } = this;\n    const ent = ents[i];\n    if (!ent) { return }\n    const { pos, dir, state } = ent;\n    tile.update(pos, datum => {\n      const { dir: newDir, state: newState, datum: newDatum } = fn(dir, state, datum);\n      const basis = CubePoint.basis[newDir];\n      if (basis) {\n        pos.toCubeInto(tmpCP)\n          .add(basis)\n          .toOddQOffsetInto(pos);\n      }\n      ent.dir = newDir;\n      ent.state = newState;\n      return newDatum;\n    });\n    tile.update(ent.pos, datum => World.FlagVisited | datum);\n  }\n\n  step() {\n    this._step();\n    this.redraw();\n  }\n\n  /** @param {number} n */\n  stepn(n) {\n    for (let i = 0; i < n; i++) {\n      this._step();\n    }\n    this.stepCount += n;\n    return this.redraw();\n  }\n\n  _step() {\n    // TODO becomes EntSystem.step()\n    for (const ent of this.ents) {\n      ent.step(this);\n    }\n    // TODO why are view stepped? that sounds like a (re)drawing concern?\n    for (const view of this.views) {\n      view.step();\n    }\n    this.stepCount++;\n  }\n\n  redraw() {\n    let didredraw = false;\n\n    const t0 = this.now();\n    for (const view of this.views) {\n      if (view.needsRedraw) {\n        view.redraw();\n        didredraw = true;\n      }\n    }\n    const t1 = this.now();\n\n    // TODO encapulate similarly to Sample... TimingSample?\n    if (didredraw) {\n      const { redrawTiming } = this;\n      while (\n        redrawTiming[0] !== undefined &&\n        t0 - redrawTiming[0] > REDRAW_TIMING_WINDOW\n      ) {\n        redrawTiming.shift();\n        redrawTiming.shift();\n      }\n      redrawTiming.push(t0, t1);\n    }\n\n    return didredraw;\n  }\n\n  redrawTimingStats() {\n    const { redrawTiming } = this;\n    if (redrawTiming.length < 4) {\n      return null;\n    }\n\n    let n = 0, m1 = 0, m2 = 0;\n\n    let i = 0;\n    while (i < redrawTiming.length) {\n      // NOTE: the ||NaN is mainly for undefined proof, but 0 is also not a\n      // reasonable number in redrawTiming, so annihilating any maths circa a\n      // spurious 0 is likely a Good Idea ™️ ... or is at least more likely to\n      // get noticed sooner ;-)\n      const t0 = redrawTiming[i++] || NaN;\n      const t1 = redrawTiming[i++] || NaN;\n      const dur = t1 - t0;\n      const delta = dur - m1;\n      n++\n      m1 += delta / n;\n      m2 += delta * delta;\n    }\n\n    m2 /= n - 1;\n    return { n, m1, m2 };\n  }\n\n  /** @param {Ent} ent */\n  removeEnt(ent) {\n    // TODO push out into EntSystem internal concerns;\n    //      does not need to be on the World : EntSystem surface\n    const { index } = ent;\n    const { ents, views } = this;\n    if (ents[index] !== ent) {\n      throw new Error('removeEnt mismatch');\n    }\n\n    let i = index;\n    for (let j = i++; j < ents.length; j++) {\n      const ent = ents[j];\n      if (ent) {\n        ents[i] = ent;\n        ent.index = i;\n        i++;\n      }\n    }\n    ents.length = i;\n\n    for (let view of views) {\n      view.removeEnt(i);\n    }\n  }\n\n  /** @param {Ent[]} newEnts */\n  setEnts(newEnts) {\n    const { ents, tile, views } = this;\n    const priorEntsLength = ents.length;\n\n    ents.length = 0;\n    for (const ent of newEnts) {\n      ent.index = ents.length;\n      ents.push(ent);\n    }\n\n    // TODO EntSystem.occupiedPositions()\n    const occupiedPositions = newEnts.map(({ pos }) => pos);\n    for (const pos of occupiedPositions) {\n      tile.update(pos, datum => World.FlagVisited | datum);\n    }\n\n    // TODO EntSystem.numColors()\n    this.numColors = Math.max.apply(null, ents.map(({ numColors }) => numColors));\n    this.numStates = Math.max.apply(null, ents.map(({ numStates }) => numStates));\n\n    // TODO why can't this just be for view of views view.udpateEnts()\n    let i = 0;\n    for (; i < priorEntsLength; ++i) {\n      for (const view of views) {\n        view.updateEnt(i);\n      }\n    }\n    for (; i < newEnts.length; ++i) {\n      for (const view of views) {\n        view.addEnt(i);\n      }\n    }\n    for (; i < priorEntsLength; ++i) {\n      for (const view of views) {\n        view.removeEnt(i);\n      }\n    }\n  }\n\n  /** @param {View} view */\n  addView(view) {\n    this.views.push(view);\n    view.updateEnts(); // 🤦 and yet we had to do all that update/add/remove per-ent dance above?🍐wut\n    return view;\n  }\n\n}\n","// @ts-check\n\nimport * as rezult from './rezult.js';\n\nexport default class GLSLShader {\n\n  /**\n   * @param {string} name\n   * @param {string} type\n   * @param {string} source\n   * @param {GLSLShader} [nextShader]\n   */\n  constructor(name, type, source, nextShader) {\n    this.name = name;\n    this.type = type;\n    this.source = source;\n    this.nextShader = nextShader;\n  }\n\n  /** @param {GLSLShader} nextShader */\n  linkWith(nextShader) {\n    const { name, type, source, nextShader: myNextShader } = this;\n    if (myNextShader) {\n      nextShader = myNextShader.linkWith(nextShader);\n    }\n    return new GLSLShader(name, type, source, nextShader);\n  }\n\n  /** @param {WebGLRenderingContext} gl */\n  compile(gl) {\n    const { name, type, source } = this;\n\n    const typeRes = glShaderType(gl, type);\n    if (typeRes.err) {\n      return typeRes;\n    }\n\n    const shader = gl.createShader(typeRes.value);\n    if (!shader) {\n      return rezult.error(new Error(`unable to create ${type} shader`));\n    }\n\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      const log = gl.getShaderInfoLog(shader) || '';\n      const mess = annotateCompileError(source, log);\n      return rezult.error(new Error(\n        `${name} ${type} shader compile error: ${mess}`));\n    }\n\n    return rezult.just(shader);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} gl\n   * @returns {rezult.Result<WebGLProgram>}\n   */\n  load(gl) {\n    const prog = gl.createProgram();\n    if (!prog) {\n      return rezult.error(new Error('unable to create gl program'));\n    }\n\n    for (let shader = /** @type {GLSLShader|undefined} */ (this); shader; shader = shader.nextShader) {\n      const res = shader.compile(gl);\n      if (res.err) {\n        return res;\n      }\n      gl.attachShader(prog, res.value);\n    }\n\n    gl.linkProgram(prog);\n    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n      const log = gl.getProgramInfoLog(prog);\n      return rezult.error(new Error(`shader program link error: ${log}`));\n    }\n\n    return rezult.just(prog);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl\n * @param {string} type\n */\nfunction glShaderType(gl, type) {\n  switch (type) {\n    case 'frag':\n      return rezult.just(gl.FRAGMENT_SHADER);\n    case 'vert':\n      return rezult.just(gl.VERTEX_SHADER);\n    default:\n      return rezult.error(new Error('invalid glsl shader type ' + JSON.stringify(type)));\n  }\n}\n\n/**\n * @param {string} src\n * @param {string} mess\n */\nfunction annotateCompileError(src, mess) {\n  var match = /^ERROR: \\d+:(\\d+):/.exec(mess);\n  if (!match) {\n    return mess;\n  }\n  const lineNo = parseInt(match[1] || '');\n  const contextCount = 3;\n\n  const lines = src.split(/\\n/);\n  const numLines = lines.length;\n  const w = numLines.toString().length;\n\n  return [...annotateLine(\n    numberLines(w, lines),\n    lineNo, contextCount,\n    `${' '.repeat(w)} ^-- ${mess}`\n  )].join('\\n');\n}\n\n/**\n * @param {number} w\n * @param {Iterable<string>} lines\n */\nfunction* numberLines(w, lines) {\n  let n = 0;\n  for (const line of lines) {\n    n++;\n    yield `${n.toString().padStart(w)}: ${line}`;\n  }\n}\n\n/**\n * @param {Iterable<string>} lines\n * @param {number} lineNo\n * @param {number} contextCount\n * @param {string} mess\n */\nfunction* annotateLine(lines, lineNo, contextCount, mess) {\n  let n = 0;\n  for (const line of lines) {\n    n++;\n    if (Math.abs(lineNo - n) <= contextCount) {\n      yield line;\n    }\n    if (n === lineNo) {\n      yield mess;\n    }\n  }\n}\n","// @generated from id:8fe5d2a30398cabcc7ed4fe8d8701663f454c3accc0674ba6aee737df82bcc30\n\n// @ts-check\n\nimport GLSLShader from '././glsl-shader.js';\n\nexport default new GLSLShader(\"oddq_point\", \"vert\", \"uniform mat4 uPMatrix;uniform vec2 uVP;uniform float uRadius;attribute vec2 vert;attribute vec2 ang;attribute lowp float color;const vec2 a=vec2(1.5,sqrt(3.0));varying lowp float vertColor;varying mediump vec2 varAng;void main(void){gl_PointSize=uVP.y*abs(uPMatrix[1][1])*uRadius;gl_Position=uPMatrix*vec4(vec2(vert.x,vert.y+mod(vert.x,2.0)/2.0)*a,0.0,1.0);vertColor=color+1.0/512.0;varAng=ang;}\");\n","// @generated from id:e9953cec26100334f8c622af64aa4e105217621f14ded4a5172b08f00a1b60fc\n\n// @ts-check\n\nimport GLSLShader from '././glsl-shader.js';\n\nexport default new GLSLShader(\"hex\", \"frag\", \"varying lowp float vertColor;varying mediump vec2 varAng;const mediump float a=3.141592653589793;const mediump float b=2.0*a;const mediump vec2 c=vec2(0.5,0.5);const mediump vec2 d=vec2(1.0,0.0)/2.0;const mediump vec2 e=vec2(0.5,sqrt(3.0)/2.0)/2.0;const mediump float f=(e.y-d.y)/(e.x-d.x);const mediump float g=e.y-f*e.x;uniform sampler2D uSampler;void main(void){mediump vec2 h=gl_PointCoord-c;if(varAng.x!=varAng.y){mediump float i=mod(atan(h.y,h.x),b);if(varAng.x<varAng.y){if(i<varAng.x||i>varAng.y){discard;}}else{if(i>=varAng.y&&i<=varAng.x){discard;}}}h=abs(h);if(h.y>e.y||h.y>f*h.x+g){discard;}gl_FragColor=texture2D(uSampler,vec2(vertColor,0));}\");\n","// @ts-check\n\nimport { mat4 } from 'gl-matrix';\n\nimport { OddQOffset } from './coord.js';\nimport { GLProgram } from './glprogram.js';\nimport { GLPalette } from './glpalette.js';\nimport * as rezult from './rezult.js';\nimport {\n  GLBuffer,\n  LazyGLBuffer,\n  TileGLBuffer,\n} from './tileglbuffer.js';\nimport { World } from './world.js';\n\n// TODO how to get these resolved for type checking?\n// @ts-ignore\nimport oddqPointShader from './oddq_point.js';\n// @ts-ignore\nimport hexFragShader from './hex.js';\n\n/** @typedef {import('./coord.js').oddQToable} oddQToable */\n\n/** @typedef {import('./colorgen.js').ColorGenMaker} ColorGenMaker */\n/** @typedef {import('./colorgen.js').ColorGen} ColorGen */\n/** @typedef {import('./hextile.js').OddQHexTile} OddQHexTile */\n\n// TODO:\n// - in redraw lazily only draw dirty tiles, expand permitting\n// - switch to uint32 elements array if supported by extension\n// - switch to uint32 for q,r, use a highp in the shader\n\nconst tau = 2 * Math.PI;\nconst hexAngStep = tau / 6;\nconst float2 = 2 * Float32Array.BYTES_PER_ELEMENT;\n\nexport class ViewGL {\n\n  /**\n   * @param {World} world\n   * @param {HTMLCanvasElement} $canvas\n   */\n  constructor(world, $canvas) {\n    // TODO can we get away with not getting/retaining a world reference, and\n    // just do with what get passed in through the world -> view surface?\n    // i.e. move from `world -> view(world) + view -> world` to `world -(components)> view`\n\n    this.world = world;\n    this.$canvas = $canvas;\n\n    this.topLeftQ = new OddQOffset();\n    this.bottomRightQ = new OddQOffset();\n\n    // max uint16 value for elements:\n    // TODO: may be able to use uint32 extension\n    // TODO: platform may define max in that case? (i.e. it would seem unlikely\n    // that we can actually use a full 4Gi vert attribute, let alone that we\n    // really don't want to allocate the 224GiB vert + color arrays that it\n    // would imply\n    this.maxElement = 0xffff;\n\n    this.gl = this.$canvas.getContext('webgl') || null;\n    if (!this.gl) {\n      throw new Error('no webgl support');\n    }\n\n    this.perspectiveMatrix = mat4.identity(new Float32Array(16));\n\n    // TODO refactor GLProgram to just take a variadic list of shaders, and own\n    // the linking, rather than the shader linked-list deal it is currently\n\n    // TODO refactor GLSLShader so that each shader carries data about its\n    // uniforms and attributes; provide that data by analyzing source in the\n    // loader\n\n    // TODO @type only needed because import is not resolvable by typescript above\n    const shader = oddqPointShader.linkWith(hexFragShader);\n    const prog = rezult.toValue(shader.load(this.gl));\n\n    this.hexShader = new GLProgram(this.gl,\n      prog,\n      ['uPMatrix', 'uVP', 'uRadius'],\n      ['vert', 'ang', 'color']\n    );\n    this.uSampler = this.gl.getUniformLocation(this.hexShader.prog, 'uSampler'); // TODO: GLProgram borg\n    if (!this.uSampler) {\n      throw new Error('missing uSampler uniform');\n    }\n\n    this.tileWriter = new TileWriter(this.maxElement + 1);\n    // TODO tileBufferer should only need access to the tile storage system, not the entire world\n    this.tileBufferer = new TileBufferer(this.gl, this.world, this.tileWriter);\n    this.entBuffer = new EntGLBuffer(this.gl);\n    this.maxCellsPerTile = Math.floor((this.maxElement + 1) / this.tileWriter.cellSize);\n\n    this.cellPallete = new GLPalette(this.gl, { unit: 0 });\n    this.bodyPallete = new GLPalette(this.gl, { unit: 1 });\n    this.headPallete = new GLPalette(this.gl, { unit: 2 });\n\n    /** @type {ColorGen|null} */\n    this.antCellColorGen = null;\n    /** @type {ColorGen|null} */\n    this.emptyCellColorGen = null;\n    /** @type {ColorGen|null} */\n    this.bodyColorGen = null;\n    /** @type {ColorGen|null} */\n    this.headColorGen = null;\n\n    this.needsRedraw = false;\n\n    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    this.hexShader.use();\n\n    this.gl.uniform1f(this.hexShader.uniform.uRadius, 1);\n\n    this.updateSize(); // XXX: drop?\n  }\n\n  reset() {\n    const {\n      tileBufferer,\n      topLeftQ, bottomRightQ,\n      world: { tile },\n    } = this;\n    tileBufferer.reset();\n    topLeftQ.q = 0, topLeftQ.r = 0;\n    bottomRightQ.q = 0, bottomRightQ.r = 0;\n    tile.eachTile(tileBufferer.drawUnvisited\n      ? tile => tile.expandBoxTo(topLeftQ, bottomRightQ)\n      : tile => tile.expandBoxToIf(topLeftQ, bottomRightQ, World.FlagVisited));\n    this.updateSize();\n  }\n\n  /** @param {oddQToable} pointArg */\n  expandTo(pointArg) {\n    const { topLeftQ, bottomRightQ } = this;\n    const { q, r } = pointArg.toOddQOffset();\n    let expanded = false;\n\n    if (q < topLeftQ.q) {\n      topLeftQ.q = q;\n      expanded = true;\n    } else if (q >= bottomRightQ.q) {\n      bottomRightQ.q = q;\n      expanded = true;\n    }\n\n    if (r < topLeftQ.r) {\n      topLeftQ.r = r;\n      expanded = true;\n    } else if (r >= bottomRightQ.r) {\n      bottomRightQ.r = r;\n      expanded = true;\n    }\n\n    return expanded;\n  }\n\n  updateSize() {\n    const {\n      gl,\n      hexShader: {\n        uniform: { uVP, uPMatrix },\n      },\n      perspectiveMatrix,\n      $canvas: { width, height },\n      tileWriter: {\n        cellHalfWidth: rx,\n        cellHalfHeight: ry,\n      },\n      topLeftQ, bottomRightQ,\n    } = this;\n\n    gl.viewport(0, 0, width, height);\n    gl.uniform2f(uVP, width, height);\n\n    let { x: topX, y: topY } = topLeftQ.toScreen();\n    let { x: botX, y: botY } = bottomRightQ.toScreen();\n    topX -= rx, topY -= ry;\n    botX += rx, botY += ry;\n\n    // TODO: sometimes over tweaks, but only noticable at small scale\n    const oddEnough = (bottomRightQ.q - topLeftQ.q) > 0;\n    if (topLeftQ.q & 1) {\n      topY -= ry;\n    }\n    if (bottomRightQ.q & 1 || oddEnough) {\n      botY += ry;\n    }\n\n    // fixAspectRatio\n    const aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    const gridWidth = botX - topX;\n    const gridHeight = botY - topY;\n    const ratio = gridWidth / gridHeight;\n    if (ratio < aspectRatio) {\n      const dx = gridHeight * aspectRatio / 2 - gridWidth / 2;\n      topX -= dx, botX += dx;\n    } else if (ratio > aspectRatio) {\n      const dy = gridWidth / aspectRatio / 2 - gridHeight / 2;\n      topY -= dy, botY += dy;\n    }\n\n    mat4.ortho(perspectiveMatrix, topX, botX, botY, topY, -1, 1);\n    gl.uniformMatrix4fv(uPMatrix, false, perspectiveMatrix);\n  }\n\n  /** @param {boolean} should */\n  setDrawTrace(should) {\n    this.drawTrace = should;\n    this.updateColors();\n  }\n\n  /**\n   * @param {number} width\n   * @param {number} height\n   */\n  resize(width, height) {\n    const { $canvas } = this;\n    $canvas.width = width;\n    $canvas.height = height;\n    this.updateSize();\n    this.redraw();\n  }\n\n  redraw() {\n    const { gl, hexShader } = this;\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    hexShader.enable();\n    this.drawTiles();\n    this.drawEntities();\n    hexShader.disable();\n\n    gl.finish();\n    this.needsRedraw = false;\n  }\n\n  drawTiles() {\n    const {\n      gl,\n      hexShader: {\n        attr: {\n          ang: angAttr,\n          vert: vertAttr,\n          color: colorAttr,\n        },\n        uniform: { uRadius },\n      },\n      uSampler,\n      cellPallete,\n      tileBufferer,\n    } = this;\n\n    // flush changed tile data to buffers\n    tileBufferer.flush();\n\n    gl.uniform1f(uRadius, 1.0);\n\n    // tiles are full hexes without an ang attribute\n    gl.disableVertexAttribArray(angAttr);\n\n    cellPallete.use(uSampler);\n\n    // draw all tiles\n    for (const { index, verts, colors, elements, usedElements } of tileBufferer.tileBuffers) {\n      if (index.length) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, verts.buf);\n        gl.vertexAttribPointer(vertAttr, verts.width, gl.FLOAT, false, 0, 0);\n        gl.bindBuffer(gl.ARRAY_BUFFER, colors.buf);\n        gl.vertexAttribPointer(colorAttr, colors.width, gl.UNSIGNED_BYTE, true, 0, 0);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elements.buf);\n        gl.drawElements(gl.POINTS, usedElements, gl.UNSIGNED_SHORT, 0);\n      }\n    }\n  }\n\n  drawEntities() {\n    const {\n      gl,\n      hexShader: {\n        attr: {\n          ang: angAttr,\n          vert: vertAttr,\n          color: colorAttr,\n        },\n        uniform: { uRadius },\n      },\n      uSampler,\n      bodyPallete, headPallete,\n      entBuffer,\n      world: { ents },\n    } = this;\n\n    if (!ents.length) {\n      return;\n    }\n\n    // extract world entity data\n    const poss = ents.map(({ pos }) => pos);\n    const dirs = ents.map(({ dir }) => dir);\n    entBuffer.ensureLen(ents.length);\n\n    // head and body are partial hexes with an ang attribute\n    gl.enableVertexAttribArray(angAttr);\n\n    // lay down entity color palette indices\n    setNumbers(entBuffer.colors, function*() {\n      // TODO ent color scheme beyond monotonic\n      for (let i = 0; i < poss.length; i++) {\n        yield i;\n      }\n    }());\n\n    // lay down entity positions and body arcs\n    setNumbers(entBuffer.verts, function*() {\n      for (const [{ q, r }, dir] of zip(poss, dirs)) {\n        yield q; yield r;\n        const ang = dir * hexAngStep;\n        yield ang + hexAngStep; yield ang;\n      }\n    }());\n\n    // draw entity bodies\n    bodyPallete.use(uSampler);\n    gl.uniform1f(uRadius, 0.5);\n    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.bodyVertsBuf);\n    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.verts, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertAttr, 2, gl.FLOAT, false, float2, 0);\n    gl.vertexAttribPointer(angAttr, 2, gl.FLOAT, false, float2, float2);\n    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.bodyColorsBuf);\n    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.colors, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(colorAttr, 1, gl.UNSIGNED_BYTE, true, 0, 0);\n    gl.drawArrays(gl.POINTS, 0, entBuffer.len);\n\n    // lay down entity head co-arcs\n    setStridedNumbers(entBuffer.verts, 2, 4, function*() {\n      for (const dir of dirs) {\n        const ang = dir * hexAngStep;\n        yield ang; yield ang + hexAngStep;\n      }\n    }());\n\n    // draw entity heads\n    headPallete.use(uSampler);\n    gl.uniform1f(uRadius, 0.75);\n    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.headVertsBuf);\n    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.verts, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vertAttr, 2, gl.FLOAT, false, float2, 0);\n    gl.vertexAttribPointer(angAttr, 2, gl.FLOAT, false, float2, float2);\n    gl.bindBuffer(gl.ARRAY_BUFFER, entBuffer.headColorsBuf);\n    gl.bufferData(gl.ARRAY_BUFFER, entBuffer.colors, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(colorAttr, 1, gl.UNSIGNED_BYTE, true, 0, 0);\n    gl.drawArrays(gl.POINTS, 0, entBuffer.len);\n  }\n\n  // TODO these are terrible legacy api callbacks for World, burn it down...\n  // these methods used to do something different in prior iteration of the\n  // view, but are all now redundant 💀\n  addEnt() { this.updateColors(); }\n  updateEnt() { this.updateColors(); }\n  removeEnt() { this.updateColors(); }\n  updateEnts() { this.updateColors(); }\n\n  /** @param {ColorGenMaker} colorGenMaker */\n  setColorGen(colorGenMaker) {\n    const { makeColorGen } = colorGenMaker;\n    this.emptyCellColorGen = extendColorGen(makeColorGen(0), World.MaxColor);\n    this.antCellColorGen = extendColorGen(makeColorGen(1), World.MaxColor);\n    this.bodyColorGen = makeColorGen(2);\n    this.headColorGen = makeColorGen(3);\n    this.updateColors();\n  }\n\n  updateColors() {\n    const {\n      drawTrace,\n      world: { ents, numColors },\n      cellPallete, emptyCellColorGen, antCellColorGen,\n      bodyPallete, bodyColorGen,\n      headPallete, headColorGen,\n    } = this;\n    const cellGen = drawTrace ? emptyCellColorGen : antCellColorGen;\n    if (cellGen) {\n      cellPallete.setColorsRGB(cellGen(numColors));\n    }\n    if (bodyColorGen) {\n      bodyPallete.setColorsRGB(bodyColorGen(ents.length));\n    }\n    if (headColorGen) {\n      headPallete.setColorsRGB(headColorGen(ents.length));\n    }\n  }\n\n  get drawUnvisited() {\n    return this.tileBufferer.drawUnvisited;\n  }\n  set drawUnvisited(drawUnvisited) {\n    this.tileBufferer.drawUnvisited = drawUnvisited;\n  }\n\n  step() {\n    const { world } = this;\n    let expanded = false;\n    for (let i = 0; i < world.ents.length; i++) {\n      expanded = this.expandTo(world.getEntPos(i)) || expanded;\n    }\n    if (expanded) {\n      this.updateSize();\n    }\n    this.needsRedraw = true;\n  }\n}\n\nclass EntGLBuffer {\n  /** @param {WebGLRenderingContext} gl */\n  constructor(gl) {\n    this.gl = gl;\n    this.len = 0;\n    this.cap = 0;\n\n    /** @type {Float32Array|null} */\n    this.verts = null;\n    /** @type {Uint8Array|null} */\n    this.colors = null;\n\n    /** @type {WebGLBuffer|null} */\n    this.bodyVertsBuf = null;\n    /** @type {WebGLBuffer|null} */\n    this.bodyColorsBuf = null;\n\n    /** @type {WebGLBuffer|null} */\n    this.headVertsBuf = null;\n    /** @type {WebGLBuffer|null} */\n    this.headColorsBuf = null;\n  }\n\n  free() {\n    const { gl } = this;\n    this.verts = null;\n    this.colors = null;\n    gl.deleteBuffer(this.bodyVertsBuf);\n    gl.deleteBuffer(this.bodyColorsBuf);\n    gl.deleteBuffer(this.headVertsBuf);\n    gl.deleteBuffer(this.headColorsBuf);\n  }\n\n  /** @param {number} cap */\n  alloc(cap) {\n    this.cap = cap;\n    this.verts = new Float32Array(this.cap * 4);\n    this.colors = new Uint8Array(this.cap * 1);\n    this.bodyVertsBuf = this.gl.createBuffer();\n    this.bodyColorsBuf = this.gl.createBuffer();\n    this.headVertsBuf = this.gl.createBuffer();\n    this.headColorsBuf = this.gl.createBuffer();\n  }\n\n  /** @param {number} len */\n  ensureLen(len) {\n    if (len > this.cap) {\n      if (this.cap > 0) {\n        this.free();\n      }\n      this.alloc(len < 1024\n        ? 2 * len\n        : len + Math.floor(len / 4));\n    }\n    this.len = len;\n  }\n}\n\nclass TileWriter {\n  /** @param {number} bufferSize */\n  constructor(bufferSize) {\n    this.bufferSize = bufferSize;\n    this.vertSize = 2;\n    this.colorSize = 1;\n    this.cellSize = 1;\n    this.maxCells = Math.floor(this.bufferSize / this.cellSize);\n    if (this.maxCells < 1) {\n      throw new Error(\"can't fit any tiles in that bufferSize\");\n    }\n    this.elementsSize = this.cellSize * this.maxCells + 2 * (this.maxCells - 1);\n    this.colors = null;\n\n    // Flat-topped vertices indexed by 2 * Math.PI * i / 6:\n    //     2 1\n    //   3     0\n    //     4 5\n    this.cellWidth = Math.cos(0) - Math.cos(Math.PI);\n    this.cellHeight =\n      Math.sin(2 * Math.PI / 6) -\n      Math.sin(2 * Math.PI * 5 / 6);\n    this.cellHalfWidth = this.cellWidth / 2;\n    this.cellHalfHeight = this.cellHeight / 2;\n  }\n\n  /**\n   * @param {number} id\n   * @param {WebGLRenderingContext} gl\n   */\n  newTileBuffer(id, gl) {\n    const { elementsSize, bufferSize, vertSize, colorSize } = this;\n    return new TileGLBuffer(id,\n      new GLBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, 1, new Uint16Array(elementsSize)),\n      new LazyGLBuffer(gl, gl.ARRAY_BUFFER, vertSize, new Float32Array(bufferSize * vertSize)),\n      new LazyGLBuffer(gl, gl.ARRAY_BUFFER, colorSize, new Uint8Array(bufferSize * colorSize)),\n    );\n  }\n\n  /**\n   * @param {OddQHexTile} tile\n   * @param {TileGLBuffer} tileBuffer\n   * @param {number} start\n   */\n  writeTileVerts({ data, origin, width, height }, { verts }, start) {\n    if (!data) { return }\n    setNumbers(verts.data.subarray(start * this.vertSize), function*() {\n      const { q: loQ, r: loR } = origin;\n      const hiQ = loQ + width;\n      const hiR = loR + height;\n      for (let r = loR; r < hiR; r++) {\n        for (let q = loQ; q < hiQ; q++) {\n          yield q;\n          yield r;\n        }\n      }\n    }());\n    const end = start + width * height;\n    verts.invalidate(start, end);\n    return end;\n  }\n\n  /**\n   * @param {OddQHexTile} tile\n   * @param {TileGLBuffer} tileBuffer\n   * @param {number} start\n   */\n  writeTileColors({ data }, { colors }, start) {\n    if (!data) { return }\n    setNumbers(colors.data.subarray(start * this.colorSize), function*() {\n      for (const datum of data) {\n        yield datum & World.MaskColor;\n      }\n    }());\n    const end = start + data.length;\n    colors.invalidate(start, end);\n    return end;\n  }\n}\n\nclass TileBufferer {\n  /**\n   * @param {WebGLRenderingContext} gl\n   * @param {World} world\n   * @param {TileWriter} tileWriter\n   */\n  constructor(gl, world, tileWriter) {\n    this.gl = gl;\n    this.world = world;\n    this.tileWriter = tileWriter;\n    this.drawUnvisited = false;\n\n    /** @type {TileGLBuffer[]} */\n    this.tileBuffers = [];\n\n    /** @type {Map<number, number>} */\n    this.bufferForTileId = new Map();\n\n    /** @type {Set<number>} */\n    this.dirtyTileBuffers = new Set();\n\n    // TODO this is a singular callback... that'll never work for more than one view...\n    this.world.tile.tileRemoved = tile => this.onWorldTileRemoved(tile);\n  }\n\n  reset() {\n    const {\n      bufferForTileId,\n      dirtyTileBuffers,\n      tileBuffers,\n    } = this;\n    bufferForTileId.clear();\n    dirtyTileBuffers.clear();\n    for (const tileBuffer of tileBuffers) {\n      tileBuffer.reset();\n    }\n  }\n\n  /** @param {OddQHexTile} tile */\n  onWorldTileRemoved(tile) {\n    const {\n      bufferForTileId,\n      tileBuffers,\n    } = this;\n    const bufferId = bufferForTileId.get(tile.id);\n    if (bufferId !== undefined) {\n      const tileBuffer = tileBuffers[bufferId];\n      if (!tileBuffer) {\n        throw new Error('got tileRemoved for an unknown tile');\n      }\n      tileBuffer.removeTile(tile.id);\n      bufferForTileId.delete(tile.id);\n    }\n  }\n\n  flush() {\n    const {\n      world: { tile: { dirtyTiles } },\n      dirtyTileBuffers,\n      tileBuffers,\n    } = this;\n    for (const tile of dirtyTiles) {\n      this.flushTile(tile);\n    }\n    dirtyTiles.length = 0;\n\n    for (const id of dirtyTileBuffers) {\n      const tileBuffer = tileBuffers[id];\n      this.flushTileBuffer(tileBuffer);\n    }\n    dirtyTileBuffers.clear();\n  }\n\n  /** @param {OddQHexTile} tile */\n  flushTile(tile) {\n    const {\n      dirtyTileBuffers,\n      tileWriter,\n    } = this;\n    const { tileBuffer, offset } = this.bufferFor(tile);\n    tileWriter.writeTileVerts(tile, tileBuffer, offset);\n    tileWriter.writeTileColors(tile, tileBuffer, offset);\n    dirtyTileBuffers.add(tileBuffer.id);\n    tile.dirty = false;\n  }\n\n  /**\n   * @param {OddQHexTile} tile\n   * @returns {{tileBuffer: TileGLBuffer, offset: number}}\n   */\n  bufferFor(tile) {\n    if (!tile.data) {\n      throw new Error('unallocated tile will not be assigned a buffer');\n    }\n\n    const {\n      gl,\n      bufferForTileId,\n      tileWriter,\n      tileBuffers,\n    } = this;\n\n    const bufferId = bufferForTileId.get(tile.id);\n    if (bufferId !== undefined) {\n      const tileBuffer = tileBuffers[bufferId];\n      const offset = tileBuffer.tileOffset(tile.id);\n      if (offset < 0) {\n        throw new Error('dissociated tileBuffer.tiles -> tile');\n      }\n      return { tileBuffer, offset };\n    }\n\n    for (const tileBuffer of tileBuffers) {\n      const offset = tileBuffer.addTile(tile.id, tile.data.length * tileWriter.cellSize);\n      if (offset >= 0) {\n        bufferForTileId.set(tile.id, tileBuffer.id);\n        return { tileBuffer, offset };\n      }\n    }\n\n    const tileBuffer = tileWriter.newTileBuffer(tileBuffers.length, gl);\n    tileBuffers.push(tileBuffer);\n    const offset = tileBuffer.addTile(tile.id, tile.data.length * tileWriter.cellSize);\n    if (offset < 0) {\n      throw new Error('unable to add tile to new tileBuffer');\n    }\n    bufferForTileId.set(tile.id, tileBuffer.id);\n    return { tileBuffer, offset };\n  }\n\n  /** @param {TileGLBuffer} tileBuffer */\n  flushTileBuffer(tileBuffer) {\n    const { world, drawUnvisited } = this;\n    tileBuffer.usedElements = 0;\n    for (const tileId of tileBuffer.tileRanges.keys()) {\n      const tile = world.tile.getTile(tileId);\n      if (!tile) {\n        throw new Error(`tile #${tileId} missing in buffer #${tileBuffer.id}`);\n      }\n      if (!tile.data) {\n        throw new Error(`tile #${tileId} has no data for buffer #${tileBuffer.id}`);\n      }\n      let offset = tileBuffer.tileOffset(tile.id);\n      for (const datum of tile.data) {\n        if (drawUnvisited || datum & World.FlagVisited) {\n          tileBuffer.addElement(offset);\n        }\n        offset++;\n      }\n    }\n    tileBuffer.flush();\n  }\n}\n\n/**\n * @param {ColorGen} gen\n * @param {number} n\n * @returns {ColorGen}\n */\nfunction extendColorGen(gen, n) {\n  return function*(m) {\n    const ar = [...gen(m)];\n    m = ar.length;\n    if (!m) return;\n    yield* ar;\n    for (let i = ar.length; i < n; i++) {\n      yield ar[i % ar.length];\n    }\n  };\n}\n\n/** @template A, B\n * @param {ArrayLike<A>} a\n * @param {ArrayLike<B>} b\n */\nfunction* zip(a, b) {\n  for (let i = 0; i < a.length && i < b.length; i++) {\n    yield /** @type {[A, B]} */([a[i], b[i]]);\n  }\n}\n\n/**\n * @param {{readonly length: number, [index: number]: number}|null} ar\n * @param {Iterable<number>} ns\n */\nfunction setNumbers(ar, ns) {\n  const length = ar?.length;\n  if (!length) {\n    return;\n  }\n  let i = 0;\n  for (const n of ns) {\n    ar[i] = n;\n    if (++i >= length) { return; }\n  }\n}\n\n/**\n * @param {{readonly length: number, [index: number]: number}|null} ar\n * @param {number} offset\n * @param {number} stride\n * @param {Iterable<number>} ns\n */\nfunction setStridedNumbers(ar, offset, stride, ns) {\n  const length = ar?.length;\n  if (!length) {\n    return;\n  }\n  let i = offset;\n  for (const n of ns) {\n    ar[i] = n;\n    if (++i >= length) { return; }\n    if (i % stride == 0) {\n      i += offset;\n    }\n  }\n}\n","// @ts-check\n\nimport colorGen from './colorgen.js';\nimport { mayQuery, mustQuery } from './domkit.js';\nimport makeHash from './hashbind.js';\nimport {\n  runPrompt,\n  loop as promptIOLoop,\n} from './prompt.js';\nimport * as rezult from './rezult.js';\nimport { Sample } from './sample.js';\nimport {\n  Turmite,\n  ruleActions as turmiteRuleActions,\n  ruleHelp as turmiteRuleHelp,\n} from './turmite/index.js';\nimport { ViewGL } from './view_gl.js';\nimport { World } from './world.js';\n\n/** @typedef {import('./world.js').Ent} Ent */\n\nconst FPSInterval = 3 * 1000;\nconst NumTimingSamples = FPSInterval / 1000 * 60;\nconst MinFPS = 20;\n\nexport default class Hexant {\n\n  /**\n   * @param {object} options\n   * @param {HTMLElement} options.$body\n   * @param {HTMLCanvasElement} [options.$view]\n   * @param {HTMLElement} [options.$fpsOverlay]\n   * @param {HTMLElement} [options.$step]\n   * @param {HTMLElement} [options.$fps]\n   * @param {HTMLElement} [options.$sps]\n   * @param {HTMLElement} [options.$redrawTiming]\n   */\n  constructor({\n    $body,\n    $view = mustQuery($body, '#view', HTMLCanvasElement),\n    $fpsOverlay = mustQuery($body, '#fpsOverlay', HTMLElement),\n    $step = mustQuery($body, '#step', HTMLElement),\n    $fps = mustQuery($body, '#fps', HTMLElement),\n    $sps = mustQuery($body, '#sps', HTMLElement),\n    $redrawTiming = mustQuery($body, '#redrawTiming', HTMLElement),\n  }) {\n    const window = $body.ownerDocument.defaultView;\n    if (!window) {\n      throw new Error('$body has no defaultView');\n    }\n\n    this.$body = $body;\n\n    function makePrompt() {\n      let $prompt = mayQuery($body, '#prompt', HTMLElement);\n      if ($prompt) $body.removeChild($prompt);\n      $prompt = $body.appendChild($body.ownerDocument.createElement('div'));\n      $prompt.id = 'prompt';\n      $prompt.classList.add('prompt');\n      return $prompt;\n    }\n\n    this.$fpsOverlay = $fpsOverlay;\n    this.$step = $step;\n    this.$fps = $fps;\n    this.$sps = $sps;\n    this.$redrawTiming = $redrawTiming;\n\n    this.window = window;\n    this.lastStepTime = null;\n    this.goalStepRate = 0;\n    this.stepRate = 0;\n    this.locked = false;\n    this.paused = true;\n    this.showFPS = false;\n\n    /** @type {number[]} */\n    this.animTimes = [];\n\n    /** @type {number[]} */\n    this.stepTimes = [];\n\n    this.animTiming = new Sample(NumTimingSamples);\n\n    this.titleBase = this.window.document.title;\n\n    this.world = new World();\n\n    this.view = new ViewGL(this.world, $view);\n    this.world.addView(this.view);\n    this.world.tile.maxTileArea = this.view.maxCellsPerTile;\n\n    const {\n      bind: bindHash,\n      load: loadHash,\n      ...hash\n    } = makeHash(window);\n\n    bindHash('colors', {\n      parse: colorGen,\n      defaultValue: rezult.toValue(colorGen('light')),\n      listener: gen => {\n        this.view.setColorGen(gen);\n        this.view.redraw();\n      },\n    });\n\n    bindHash('rule', {\n      parse: str => Turmite.from(str, World),\n      defaultValue: rezult.toValue(Turmite.from('ant(L R)', World)),\n      listener: ent => this.setEnts(ent ? [ent] : []),\n    });\n\n    bindHash('showFPS', {\n      defaultValue: false,\n      listener: showFPS => {\n        this.showFPS = showFPS;\n        this.$fpsOverlay.style.display = this.showFPS ? '' : 'none';\n      },\n    });\n\n    bindHash('stepRate', {\n      parse: rezult.lift(parseInt),\n      defaultValue: 4,\n      listener: rate => this.setStepRate(rate),\n    });\n\n    bindHash('drawUnvisited', {\n      defaultValue: false,\n      listener: drawUnvisited => this.view.drawUnvisited = drawUnvisited,\n    });\n\n    bindHash('drawTrace', {\n      defaultValue: false,\n      listener: drawTrace => {\n        this.view.setDrawTrace(drawTrace);\n        this.view.redraw();\n      },\n    });\n\n    loadHash();\n\n    this.hash = hash;\n\n    /**\n     * @typedef {object} ActionProps\n     * @prop {string[]} keys\n     * @prop {string} name\n     * @prop {string} desc\n     */\n\n    /** @template T @typedef {import('./prompt.js').Interactor<T>} Interactor */\n    /** @template T @typedef {import('./prompt.js').Looper<T>} Looper */\n\n    /**\n     * @typedef {ActionProps & (\n     * | {then: () => void}\n     * | {prompt: Interactor<unknown>}\n     * | {loop: Looper<void>}\n     * )} Action\n     */\n\n    /** @type {Action[]} */\n    const actions = [\n\n      {\n        name: 'help',\n        desc: 'show this help screen',\n        keys: ['?', 'h', 'button2'],\n        loop: function*() {\n          yield { title: 'Actions' };\n          yield {\n            help: function*() {\n              // yield `| Name | Key | Description |`;\n              // yield `|------|-----|-------------|`;\n              for (const { name, keys: [key], desc } of actions) {\n                // yield `| ${name} | \\`${key}\\` | ${desc} |`;\n                yield `${name} ( key: \\`${key}\\` )`;\n                // TODO display other keys\n                yield `: ${desc}`;\n                yield ``;\n              }\n            }()\n          }\n        },\n      },\n\n      {\n        name: 'play',\n        desc: 'play / pause the simulation',\n        keys: ['Space', 'button0'],\n        then: () => { this.playpause() },\n      },\n\n      {\n        name: 'step',\n        desc: 'single step when paused, pause if playing',\n        keys: ['.', 'button1'],\n        then: () => this.stepit(),\n      },\n\n      {\n        name: 'reset',\n        keys: ['*'],\n        desc: 'reset the simulation to initial state',\n        then: () => this.reboot(),\n      },\n\n      {\n        name: 'rule',\n        keys: ['/'],\n        desc: 'edit the simulated ant ruleset',\n        prompt: this.rulePrompt(),\n      },\n\n      {\n        name: 'colorscheme',\n        keys: ['c'],\n        desc: 'edit the color scheme used for tiles and ants',\n        prompt: this.colorPrompt(),\n      },\n\n      {\n        name: 'speed up',\n        desc: 'double simulation speed',\n        keys: ['+'],\n        then: () => this.hash.set('stepRate', this.stepRate * 2),\n      },\n\n      {\n        name: 'slow down',\n        desc: 'halve simulation speed',\n        keys: ['-'],\n        then: () => this.hash.set('stepRate', Math.max(1, Math.floor(this.stepRate / 2))),\n      },\n\n      {\n        name: 'FPS',\n        desc: 'show/hide runtime statistic overlay',\n        keys: ['f'],\n        then: () => this.hash.set('showFPS', !this.showFPS),\n      },\n\n      {\n        name: 'unvisited cells',\n        desc: 'toggle whether all visible cells are drawn instead of just visted cells ones',\n        keys: ['u'],\n        then: () => this.hash.set('drawUnvisited', !this.view.drawUnvisited),\n        // TODO trigger an immediate redraw\n      },\n\n      // TODO this used to work\n      // {\n      //   name: 'trace cells',\n      //   desc: 'toggle whether to draw traces of recently visited cells',\n      //   keys: ['t'],\n      //   then: () => this.hash.set('drawTrace', !this.view.drawTrace),\n      // },\n\n      // TODO doesn't work correctly, just replace with an action that directly\n      // generates and offer for copy such url, rather than change encoding\n      // scheme\n      //\n      // {\n      //   name: 'toggle base64 #fragment',\n      //   desc: 'change url encoding scheme to output a more easily shareable base64 form',\n      //   keys: ['b'],\n      //   then: () => this.hash.encoding = this.hash.encoding == 'b64:' ? '' : 'b64:',\n      // },\n\n      {\n        name: 'fullscreen',\n        desc: 'enter/exit fullscreen mode',\n        keys: ['Enter'],\n        then() {\n          const { ownerDocument: document } = $body;\n          if (!document.fullscreenElement) {\n            $body.requestFullscreen();\n          } else if (document.exitFullscreen) {\n            document.exitFullscreen();\n          }\n        },\n      },\n\n    ];\n\n    // TODO shifted keys are a bit awkward right now\n    /** @type {Map<string, (key: string) => void>} */\n    this.keymap = new Map(actions.flatMap(action => {\n      const then = 'then' in action ? action.then : (prompt =>\n        () => runPrompt(makePrompt, prompt)\n      )('prompt' in action ? action.prompt : promptIOLoop(action.loop));\n      return action.keys.map(key => [key, () => then()])\n    }));\n    this.keymap.set('Escape', () => {\n      let $prompt = mayQuery($body, '#prompt', HTMLElement);\n      if ($prompt) $body.removeChild($prompt);\n    });\n    // this.keymap.set('', k => console.log('?', k)) // to log unhandled events\n\n    this.window.addEventListener('keydown', this);\n    this.window.addEventListener('keyup', this);\n    this.window.addEventListener('mouseup', this);\n\n    let autoplay = false;\n    let autorefresh = 0;\n    if (this.hash.get('fullauto')) {\n      autoplay = true;\n      autorefresh = 24 * 60 * 60;\n    } else {\n      autoplay = this.hash.get('autoplay');\n      autorefresh = parseInt(this.hash.get('autorefresh'), 10);\n    }\n\n    if (!isNaN(autorefresh) && autorefresh) {\n      this.window.setTimeout(\n        () => this.window.location.reload(),\n        autorefresh * 1000);\n    }\n\n    if (autoplay) this.play();\n  }\n\n  reboot() {\n    this.pause();\n    this.setEnts([this.hash.get('rule')]);\n  }\n\n  /** @param {Ent[]} ents */\n  setEnts(ents) {\n    const title = ents.map(ent => `${ent}`).join(', ');\n    this.world.setEnts(ents);\n    this.world.reset();\n    this.view.$canvas.width = this.view.$canvas.width;\n    this.view.redraw();\n    this.window.document.title = this.titleBase + ': ' + title;\n  }\n\n  /** @param {Event} e */\n  handleEvent(e) {\n\n    /** @param {string} key */\n    const dispatch = key => {\n      let fn =\n        this.keymap.get(`${key}`)\n        || this.keymap.get(`${key.toLowerCase()}`)\n        || this.keymap.get('');\n      if (fn) {\n        e.preventDefault();\n        fn(key);\n      }\n    };\n\n    const { type } = e;\n    let $prompt = mayQuery(this.$body, '#prompt', HTMLElement);\n\n    const { target } = e;\n    if (!(\n      target === $prompt ||\n      target === this.view.$canvas ||\n      target === this.window.document.documentElement ||\n      target === this.window.document.body\n    )) return;\n\n    switch (type) {\n      case 'mouseup':\n        if (e instanceof MouseEvent) {\n          dispatch(keycode(e, { button: e.button }));\n        }\n        break;\n\n      case 'keydown':\n        if (e instanceof KeyboardEvent) {\n          switch (e.key) {\n            case 'Escape':\n              e.preventDefault();\n              break;\n          }\n        }\n        break;\n\n      case 'keyup':\n        if (e instanceof KeyboardEvent) {\n          dispatch(keycode(e, { key: e.key }));\n        }\n    }\n  }\n\n  rulePrompt() {\n    const { hash } = this;\n    const hashName = 'rule';\n    return promptIOLoop(function*(inputs) {\n      let value = hash.getStr(hashName);\n\n      for (const input of inputs) {\n        if ('value' in input) {\n          ({ value } = input);\n          const { res: { err }, str: revalue } = hash.set(hashName, value);\n          if (!err) { return true }\n          if (revalue) value = revalue;\n          yield { error: err.message };\n        }\n      }\n\n      for (const { name, then } of turmiteRuleActions(value)) {\n        for (const input of inputs) {\n          if ('command' in input) {\n            const { command } = input;\n            if (command === name) {\n              let ok = false;\n              try {\n                value = then(value);\n                ok = true;\n              } catch (e) {\n                yield { error: `${e}` }\n              }\n              if (ok) {\n                const { res: { err }, str: revalue } = hash.set(hashName, value);\n                if (revalue) value = revalue;\n                if (err) yield { error: err.message };\n              }\n            }\n          }\n        }\n      }\n\n      for (const { name, label } of turmiteRuleActions(value)) {\n        yield { command: name, label: label || name };\n      }\n\n      yield { title: 'Rule' };\n      yield { value };\n      yield { help: turmiteRuleHelp(value) };\n\n      return undefined;\n    });\n  }\n\n  colorPrompt() {\n    const { hash } = this;\n    const hashName = 'colors';\n    return promptIOLoop(\n      function*(inputs) {\n        for (const input of inputs) {\n          if ('value' in input) {\n            const { value } = input;\n            const { res: { err }, str: revalue } = hash.set(hashName, value);\n            if (!err) { return true }\n            yield { error: err.message };\n            yield { value: revalue || value };\n            yield { title: 'Colors' };\n          }\n        }\n        return undefined;\n      },\n\n      function*() {\n        const value = hash.getStr(hashName);\n        yield { value };\n        yield { title: 'Colors' };\n        return undefined;\n      });\n  }\n\n  /** @param {number} time */\n  calcSteps(time) {\n    if (!this.lastStepTime) {\n      this.lastStepTime = time;\n      return 0;\n    }\n\n    const sinceLast = time - this.lastStepTime;\n    if (sinceLast > 0) {\n      this.animTiming.collect(sinceLast);\n    }\n    this.throttle();\n    return Math.round(sinceLast / 1000 * this.stepRate);\n  }\n\n  /** @param {number} time */\n  stepWorld(time) {\n    if (this.locked) { return; }\n    const steps = this.calcSteps(time);\n    if (steps < 1) {\n      return;\n    }\n    if (steps == 1) {\n      this.world.step();\n    } else {\n      this.world.stepn(steps);\n    }\n    this.stepTimes.push(time, steps);\n    this.lastStepTime = time;\n  }\n\n  /** @param {number} time */\n  updateFPS(time) {\n    this.animTimes.push(time);\n    while (time - this.animTimes[0] > FPSInterval) {\n      this.animTimes.shift();\n    }\n    while (time - this.stepTimes[0] > FPSInterval) {\n      this.stepTimes.shift();\n    }\n    if (!this.showFPS) return;\n    this.$step.innerText = '#' + this.world.stepCount;\n    this.$fps.innerText = this.computeFPS().toFixed(0) + 'fps';\n    this.$sps.innerText = toSI(this.computeSPS()) + 'sps';\n    var stats = this.world.redrawTimingStats();\n    if (stats) {\n      this.$redrawTiming.innerText =\n        'µ=' + toSI(stats.m1 / 1e3) + 's ' +\n        '𝜎=' + toSI(Math.sqrt(stats.m2 / 1e3)) + 's';\n    } else {\n      this.$redrawTiming.innerText = '';\n    }\n  }\n\n  throttle() {\n    if (!this.animTiming.complete()) {\n      return;\n    }\n\n    if (this.animTiming.sinceWeightedMark() <= 3) {\n      return;\n    }\n\n    if (this.stepRate > 1) {\n      const fps = this.computeFPS();\n      if (fps < MinFPS) {\n        this.animTiming.weightedMark(2);\n        this.stepRate /= 2;\n        return;\n      }\n    }\n\n    var as = this.animTiming.classifyAnomalies();\n    var i = as.length - 1;\n    if (\n      this.stepRate > 1 &&\n      as[i] > 0.5 && as[i - 1] > 0.5 && as[i - 2] > 0.5\n    ) {\n      this.stepRate /= 2;\n      this.animTiming.weightedMark(2);\n    } else if (\n      this.stepRate < this.goalStepRate &&\n      as[i] <= 0 && as[i - 1] <= 0 && as[i - 2] <= 0\n    ) {\n      this.stepRate *= 2;\n      this.animTiming.weightedMark(0.5);\n    }\n\n  }\n\n  computeFPS() {\n    return this.animTimes.length / FPSInterval * 1000;\n  }\n\n  computeSPS() {\n    let totalSteps = 0;\n    for (var i = 1; i < this.stepTimes.length; i += 2) {\n      totalSteps += this.stepTimes[i];\n    }\n    return totalSteps / FPSInterval * 1000;\n  }\n\n  async play() {\n    if (this.locked) { return; }\n    this.paused = false;\n    this.animTimes.length = 0;\n    this.stepTimes.length = 0;\n    this.animTiming.reset();\n    this.$fps.innerText = '';\n    this.$sps.innerText = '';\n    this.$redrawTiming.innerText = '';\n    this.lastStepTime = null;\n\n    while (!this.paused) {\n      const time = await nextFrame(this.window);\n      /* eslint-disable no-try-catch */\n      try {\n        this.stepWorld(time);\n        this.updateFPS(time);\n      } catch (err) {\n        this.pause();\n        this.locked = true;\n        logError(err, 'Hexant playtime',\n          ['config', Object.fromEntries(this.hash.stringEntries())],\n          ['step', this.world.stepCount],\n          ['fps', this.computeFPS()],\n          ['sps', this.computeSPS()],\n          ['redrawTiming', this.world.redrawTimingStats()],\n        );\n      }\n    }\n  }\n\n  pause() {\n    this.paused = true;\n    this.$fps.innerText = '<' + this.$fps.innerText + '>';\n    this.$sps.innerText = '<' + this.$sps.innerText + '>';\n    this.$redrawTiming.innerText = '<' + this.$redrawTiming.innerText + '>';\n    this.lastStepTime = null;\n  }\n\n  playpause() {\n    if (this.paused) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  }\n\n  stepit() {\n    if (!this.paused) {\n      this.pause();\n    } else if (!this.locked) {\n      this.world.step();\n    }\n  }\n\n  /** @param {number} rate */\n  setStepRate(rate) {\n    if (this.stepRate === this.goalStepRate) {\n      this.stepRate = rate;\n    }\n    this.goalStepRate = rate;\n  }\n\n  /**\n   * @param {number} width\n   * @param {number} height\n   */\n  resize(width, height) {\n    this.view.resize(width, height);\n  }\n\n}\n\nconst nsiSuffix = ['', 'm', 'µ', 'n'];\nconst siSuffix = ['K', 'M', 'G', 'T', 'E'];\n\n/** @param {number} n */\nfunction toSI(n) {\n  if (n < 1) {\n    let nsi = 0;\n    while (nsi < nsiSuffix.length && n < 1) {\n      nsi++;\n      n *= 1e3;\n    }\n    return n.toPrecision(3) + nsiSuffix[nsi];\n  }\n  if (n < 1e3) {\n    return n.toFixed(0);\n  }\n  n /= 1e3;\n  let si = 0;\n  while (si < siSuffix.length && n > 1e3) {\n    si++;\n    n /= 1e3;\n  }\n  return n.toPrecision(3) + siSuffix[si];\n}\n\n/**\n * @param {Window} [window]\n * @returns {Promise<number>}\n */\nfunction nextFrame(window = global.window) {\n  return new Promise(\n    resolve => window.requestAnimationFrame(resolve)\n  );\n}\n\n/** @typedef {object} ModifierKeyEvent\n * @prop {boolean} metaKey\n * @prop {boolean} altKey\n * @prop {boolean} ctrlKey\n * @prop {boolean} shiftKey\n */\n\n/**\n * @param {ModifierKeyEvent} e\n * @param {{key:string}|{button:number}} kb\n */\nfunction keycode({ metaKey, altKey, ctrlKey }, kb) {\n  return [...function*() {\n    let key = '';\n\n    if (metaKey) yield `M`;\n    if (altKey) yield `A`;\n    if (ctrlKey) yield `C`;\n    // if (shiftKey)  yield `S`; // NOTE ignoring shift for now\n    if ('key' in kb) {\n      ({ key } = kb);\n      switch (key) {\n        case ' ':\n          yield 'Space';\n          break;\n\n        default:\n          yield key;\n      }\n    } else yield `button${kb.button}`;\n  }()].join('-');\n}\n\n/**\n * @param {any} err\n * @param {string} desc\n * @param {[key: string, data: any][]} details\n */\nfunction logError(err, desc, ...details) {\n  console.group(`${desc} error`);\n  console.error(err);\n  for (const [key, data] of details) {\n    console.log(key, JSON.stringify(data));\n  }\n  console.groupEnd();\n}\n","// @ts-check\n\nimport Hexant from './src/hexant.js';\n\nconst hexant = new Hexant({\n  $body: document.querySelector('#main'),\n});\n\nfunction updateSize() {\n  const {\n    innerWidth, innerHeight,\n    document: {\n      documentElement: { clientWidth, clientHeight },\n    },\n  } = window;\n  const width = Math.max(clientWidth, innerWidth || 0);\n  const height = Math.max(clientHeight, innerHeight || 0);\n  hexant.resize(width, height);\n}\n\nwindow.addEventListener('resize', () => updateSize());\nupdateSize();\n"],"names":["hsluv","Geometry","intersectLineLine","a","b","x","intercept","slope","y","distanceFromOrigin","point","Math","sqrt","pow","distanceLineFromOrigin","line","abs","perpendicularThroughPoint","angleFromOrigin","atan2","normalizeAngle","angle","m","PI","lengthOfRayUntilIntersect","theta","sin","cos","Hsluv","getBounds","L","result","sub1","sub2","epsilon","kappa","_g","c","m1","m2","m3","_g1","t","top1","top2","bottom","push","maxSafeChromaForL","bounds","min","Infinity","length","bound","maxChromaForLH","H","hrad","dotProduct","sum","i","fromLinear","toLinear","xyzToRgb","tuple","rgbToXyz","rgbl","minv","yToL","Y","refY","lToY","xyzToLuv","X","divider","varU","varV","NaN","refU","refV","luvToXyz","U","V","luvToLch","C","lchToLuv","Hrad","hsluvToLch","S","lchToHsluv","hpluvToLch","lchToHpluv","rgbToHex","h","chan","round","digit2","digit1","hexChars","charAt","hexToRgb","hex","toLowerCase","ret","n","indexOf","lchToRgb","rgbToLch","hsluvToRgb","rgbToHsluv","hpluvToRgb","rgbToHpluv","hsluvToHex","hpluvToHex","hexToHsluv","s","hexToHpluv","hsluv_1","toValue","err","value","just","error","catchErr","body","Error","bind","res","next","gens","Map","parse","str","match","exec","rezult.error","name","gen","get","choices","Object","keys","sort","join","JSON","stringify","args","split","rezult.just","parseInt","undefined","mustQuery","el","selector","type","querySelector","mayQuery","makeHash","window","codecs","defaultEncoding","encoders","decoders","keyEncoders","keyDecoders","encode","keyvals","encoded","firstKey","firstEnc","key","enc","decode","orig","sanity","decoder","startsWith","slice","addCodec","encodeKeys","decodeKeys","set","encs","rem","makeCodecSuite","parts","val","part","encodeURIComponent","decodeURIComponent","btoa","atob","cache","values","defaults","parsers","stringers","listeners","last","loaded","load","hash","location","resave","seen","Set","toNotify","add","loadBinding","entries","has","delete","valueToString","notifyBinding","loadValues","save","parser","parseValue","saveBinding","fn","addEventListener","reload","encoding","stringer","listener","defaultValue","rezult.toValue","getStr","prior","defaultString","r","parseBindingValue","Symbol","iterator","stringEntries","async","runPrompt","makeEl","tor","$el","$body","handleEvents","callback","makeHeader","$header","HTMLHeadingElement","insertBefore","ownerDocument","createElement","firstElementChild","makeText","$text","HTMLTextAreaElement","appendChild","id","makeHelp","$help","HTMLElement","classList","makeError","$error","makeButton","label","title","$btn","HTMLButtonElement","innerText","resetOutputElements","style","display","rows","resizeTextRows","lines","lastEnter","handleEvent","e","target","command","dataset","preventDefault","KeyboardEvent","ctrlKey","canceled","Date","now","replace","_canceled","event","inputs","done","outputs","activeButtons","WeakSet","output","select","focus","help","terminate","coalesce","assertNever","querySelectorAll","removeChild","Promise","resolve","removeEventListener","lastChild","prompt","parentNode","strs","sep","out","end","endsWith","loop","loopers","looper","first","firstLooper","collectIt","it","impossible","mess","hue","sat","toString","makeColorGen","intensity","ncolors","step","l","light","satDelta","lightDelta","mySat","myLight","Sample","constructor","this","data","lastMark","markWeight","mark","weightedMark","weight","sinceWeightedMark","sinceMark","reset","complete","collect","datum","shift","classifyAnomalies","q","quantileSelector","q25","q50","q75","iqr","map","tol","lo","hi","floor","ceil","ScreenPoint","copy","copyFrom","other","toScreenInto","screenPoint","toScreen","scale","mulBy","addTo","sub","CubePoint","z","toCubeInto","toCube","toOddQOffset","OddQOffset","toOddQOffsetInto","oqo","static","cubePoint","OddQBox","topLeft","bottomRight","screenCount","screenCountInto","W","contains","pointArg","expandTo","expanded","Turn","RelForward","RelBackward","RelLeft","RelRight","RelDoubleLeft","RelDoubleRight","AbsNorthWest","AbsNorth","AbsNorthEast","AbsSouthEast","AbsSouth","AbsSouthWest","turnDirs","turn","dir","RelTurnDelta","AbsTurnDir","root","factory","module","exports","nearley","Rule","symbols","postprocess","highestId","State","rule","dot","reference","wantedBy","isComplete","Column","grammar","index","states","wants","scannable","completed","Grammar","rules","start","byName","forEach","hasOwnProperty","StreamLexer","Parser","options","fromCompiled","keepHistory","lexer","lexerState","column","table","predict","process","current","getSymbolShortDisplay","symbol","literal","RegExp","test","String","prototype","withCursorAt","symbolSequence","nextState","child","state","left","right","build","children","node","reverse","finish","fail","nextColumn","w","exp","nulls","Lexer","ParserStart","ParserRules","g","buffer","lastLineBreak","col","ch","formatError","token","message","max","lastLineDigits","pad","Array","feed","chunk","reportLexerError","offset","text","expect","isToken","reportError","results","lexerError","tokenDisplay","lexerMessage","reportErrorCommon","lastColumnIndex","lastColumn","expectantStates","filter","nextSymbol","displayStateStack","buildFirstStateStack","stateStack","symbolDisplay","getSymbolDisplay","lastDisplay","sameDisplayCount","j","getSymbolLongDisplay","visited","prevState","childVisited","concat","childResult","restore","splice","rewind","considerations","head","_","tail","d","_0","_1","comment","_2","_3","ant","when","then","color","mode","names","arg1","op","arg2","turns","count","rest","item","num","base","grammarRules","isNodeType","number","assign","member","expr","thenVal","thenSet","isAnyExpr","isAnyValue","rezult.catchErr","asTypedNode","from","countsyms","consume","cur","curCount","sym","isNaN","RLEBuilder","TurnSyms","opPrec","toSpecString","nodes","outerPrec","entry","prec","rleFrom","or","antRule","antTurns","whenState","thenState","matchType","transformed","xforms","oldType","newNode","transform","xform","each","any","rep","isEntryNode","notNull","spec","descend","compileBuilder","format","scope","stack","pop","define","uname","block","foot","cont","zero","chain","wrap","makeScope","compileContent","argNames","arg","amend","compileArrowFn","compileDefinitions","compileRuleBuilder","func","lastSpace","lastIndexOf","compileFunction","multiLineQuoted","numColors","analyze.transform","countNumColors","compileSpecComment","params","trimStart","compileAssign","compileRule","analyze.antRule","compileValue","assigns","xrule","analyze.transformed","analyze.matchType","toUpperCase","compileRuleBody","whenColor","thenColor","thenTurn","thens","mask","decl","isEmpty","every","whens","cap","init","maskParts","reduce","compileWhenMatch","priorKey","keyExpr","syms","freeSymbols","free","matchExpr","invOp","genStack","leftHasSym","usedSymbols","rightHasSym","solve","reduceParts","unshift","compileCode","funcRes","rezult.bind","endLines","code","Function","codeErr","valRes","constants.Turn","padStart","turnStr","val1","val2","exprStr","baseVal","used","prefix","allSpace","trim","nl","ruleActions","parseRaw","action","some","actions","ruleHelp","turmite","Turmite","MaxColor","MaxState","MaxTurn","MaskResultState","MaskResultColor","MaskResultTurn","ColorShift","TurnShift","ColorByteWidth","StateByteWidth","TurnByteWidth","ResultByteWidth","ResultStateShift","ResultColorShift","ResultTurnShift","KeyByteWidth","KeyStateMask","KeyColorMask","KeyColorShift","KeyStateShift","TestSpec","ent","parseErr","fill","built","buildErr","numStates","specString","Uint32Array","pos","world","updateEnt","flags","newDirs","constants.turnDirs","ARRAY_TYPE","Float32Array","hypot","arguments","ortho","top","near","far","lr","bt","nf","create","glMatrix.ARRAY_TYPE","fromValues","vec","vec3.create","vec3.fromValues","GLProgram","gl","prog","uniformNames","attrNames","uniform","attr","loc","getUniformLocation","getAttribLocation","use","useProgram","enable","attrLoc","enableVertexAttribArray","disable","disableVertexAttribArray","GLPalette","unit","formatArg","colors","extSRGB","getExtension","SRGB_EXT","console","warn","RGB","Uint8Array","tex","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","setColorsRGB","uSampler","uniform1i","rgbColors","ar","ns","setNumbers","texImage2D","UNSIGNED_BYTE","TileGLBuffer","elements","verts","tileRanges","usedElements","capacity","clear","addElement","flush","shipElements","ship","addTile","bestIndex","bestOffset","best","freeIndex","freeOffset","freeLength","tileId","tileLength","waste","placeTile","k","spare","remain","scavengeTombstone","removeTile","tileOffset","range","GLBuffer","width","buf","createBuffer","bindBuffer","bufferData","STATIC_DRAW","begin","bufferSubData","BYTES_PER_ELEMENT","subarray","LazyGLBuffer","super","inval","invalidate","rl","found","rangeListAdd","rangeListEach","pool","OddQHexTile","tile","NextId","origin","height","dirty","need","needBytes","Uint16Array","byteLength","boundingBox","centerPoint","pointToIndex","update","orNaN","eachTile","eachDataPoint","loQ","loR","hiQ","hiR","expandBoxTo","tl","br","tlq","tlr","brq","brr","expandBoxToIf","oq","dump","row","un","HexTileTree","minTileArea","maxTileArea","tiles","dirtyTiles","tileRemoved","noop","tileAdded","getTile","removeTiles","goneIDs","dirtyTile","_ensureRoot","HexTileTreeNode","alloc","_ensureTile","box","expand","_getOrCreateTile","zoomPerm","tileOriginOffset","nodeOriginOffset","growTile","tree","originOffset","zoom","tileSize","growthOrigin","growthSize","size","tileNode","_setTile","concrete","_replaceme","replaceme","_setSize","tileparts","tilepart","_mayCompact","doFill","compact","subTiles","newTile","subTile","_getTile","_index","_allocTile","_allocNode","World","stepCount","ents","views","redrawTiming","performance","tmpCP","getEntPos","getEntDir","view","occupiedPositions","FlagVisited","newDir","newState","newDatum","basis","_step","redraw","stepn","didredraw","t0","needsRedraw","t1","redrawTimingStats","delta","removeEnt","setEnts","newEnts","priorEntsLength","apply","addEnt","addView","updateEnts","GLSLShader","source","nextShader","linkWith","myNextShader","compile","typeRes","FRAGMENT_SHADER","VERTEX_SHADER","glShaderType","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","src","lineNo","contextCount","annotateLine","numberLines","repeat","annotateCompileError","getShaderInfoLog","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","log","getProgramInfoLog","oddqPointShader","hexFragShader","hexAngStep","float2","ViewGL","$canvas","topLeftQ","bottomRightQ","maxElement","getContext","perspectiveMatrix","mat4.identity","hexShader","tileWriter","TileWriter","tileBufferer","TileBufferer","entBuffer","EntGLBuffer","maxCellsPerTile","cellSize","cellPallete","bodyPallete","headPallete","antCellColorGen","emptyCellColorGen","bodyColorGen","headColorGen","clearColor","uniform1f","uRadius","updateSize","drawUnvisited","uVP","uPMatrix","cellHalfWidth","rx","cellHalfHeight","ry","viewport","uniform2f","topX","topY","botX","botY","oddEnough","aspectRatio","drawingBufferWidth","drawingBufferHeight","gridWidth","gridHeight","ratio","dx","dy","mat4.ortho","uniformMatrix4fv","setDrawTrace","should","drawTrace","updateColors","resize","COLOR_BUFFER_BIT","drawTiles","drawEntities","ang","angAttr","vert","vertAttr","colorAttr","tileBuffers","ARRAY_BUFFER","vertexAttribPointer","FLOAT","ELEMENT_ARRAY_BUFFER","drawElements","POINTS","UNSIGNED_SHORT","poss","dirs","ensureLen","zip","bodyVertsBuf","bodyColorsBuf","drawArrays","len","stride","setStridedNumbers","headVertsBuf","headColorsBuf","setColorGen","colorGenMaker","extendColorGen","cellGen","deleteBuffer","bufferSize","vertSize","colorSize","maxCells","elementsSize","cellWidth","cellHeight","newTileBuffer","writeTileVerts","writeTileColors","MaskColor","bufferForTileId","dirtyTileBuffers","onWorldTileRemoved","tileBuffer","bufferId","flushTile","flushTileBuffer","bufferFor","nsiSuffix","siSuffix","toSI","nsi","toPrecision","toFixed","si","nextFrame","global","requestAnimationFrame","keycode","metaKey","altKey","kb","button","logError","desc","details","group","groupEnd","hexant","$view","HTMLCanvasElement","$fpsOverlay","$step","$fps","$sps","$redrawTiming","defaultView","makePrompt","$prompt","lastStepTime","goalStepRate","stepRate","locked","paused","showFPS","animTimes","stepTimes","animTiming","FPSInterval","titleBase","document","bindHash","loadHash","colorGen","rate","setStepRate","playpause","stepit","reboot","rulePrompt","colorPrompt","fullscreenElement","exitFullscreen","requestFullscreen","keymap","flatMap","promptIOLoop","autoplay","autorefresh","setTimeout","play","pause","dispatch","documentElement","MouseEvent","hashName","input","revalue","turmiteRuleActions","ok","turmiteRuleHelp","calcSteps","time","sinceLast","throttle","stepWorld","steps","updateFPS","computeFPS","computeSPS","stats","as","totalSteps","fromEntries","innerWidth","innerHeight","clientWidth","clientHeight"],"mappings":"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"}